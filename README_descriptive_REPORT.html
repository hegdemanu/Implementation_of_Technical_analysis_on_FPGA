<!DOCTYPE html>
<html>
<head>
<title>README_descriptive_REPORT.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="fpga-based-technical-analysis-trading-system-comprehensive-documentation">FPGA-Based Technical Analysis Trading System: Comprehensive Documentation</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li>
<p><a href="#introduction">Introduction</a></p>
<ul>
<li><a href="#project-overview">Project Overview</a></li>
<li><a href="#technical-analysis-in-trading">Technical Analysis in Trading</a></li>
<li><a href="#hardware-acceleration-benefits">Hardware Acceleration Benefits</a></li>
<li><a href="#target-applications">Target Applications</a></li>
<li><a href="#fpga-implementation-advantages">FPGA Implementation Advantages</a></li>
<li><a href="#system-capabilities">System Capabilities</a></li>
</ul>
</li>
<li>
<p><a href="#repository-structure">Repository Structure</a></p>
<ul>
<li><a href="#directory-organization">Directory Organization</a></li>
<li><a href="#combined-analysis-components">Combined Analysis Components</a></li>
<li><a href="#moving-average-specific-components">Moving Average Specific Components</a></li>
<li><a href="#rsi-specific-components">RSI Specific Components</a></li>
<li><a href="#file-naming-conventions">File Naming Conventions</a></li>
<li><a href="#documentation-approach">Documentation Approach</a></li>
</ul>
</li>
<li>
<p><a href="#system-architecture">System Architecture</a></p>
<ul>
<li><a href="#high-level-design">High-Level Design</a></li>
<li><a href="#module-interactions">Module Interactions</a></li>
<li><a href="#data-flow-architecture">Data Flow Architecture</a></li>
<li><a href="#clock-domain-strategy">Clock Domain Strategy</a></li>
<li><a href="#control-flow-management">Control Flow Management</a></li>
<li><a href="#interface-specifications">Interface Specifications</a></li>
<li><a href="#system-integration-principles">System Integration Principles</a></li>
</ul>
</li>
<li>
<p><a href="#technical-indicators-implementation">Technical Indicators Implementation</a></p>
<ul>
<li>
<p><a href="#moving-average-implementation">Moving Average Implementation</a></p>
<ul>
<li><a href="#principles-and-theory">Principles and Theory</a></li>
<li><a href="#implementation-algorithm">Implementation Algorithm</a></li>
<li><a href="#optimization-techniques">Optimization Techniques</a></li>
<li><a href="#parameter-configuration">Parameter Configuration</a></li>
<li><a href="#fsm-design-details">FSM Design Details</a></li>
<li><a href="#precision-considerations">Precision Considerations</a></li>
</ul>
</li>
<li>
<p><a href="#rsi-implementation">RSI Implementation</a></p>
<ul>
<li><a href="#rsi-theory-and-calculation">RSI Theory and Calculation</a></li>
<li><a href="#fsm-implementation-approach">FSM Implementation Approach</a></li>
<li><a href="#gainloss-accumulation">Gain/Loss Accumulation</a></li>
<li><a href="#final-calculation-method">Final Calculation Method</a></li>
<li><a href="#edge-case-handling">Edge Case Handling</a></li>
<li><a href="#optimization-details">Optimization Details</a></li>
</ul>
</li>
<li>
<p><a href="#trading-decision-logic">Trading Decision Logic</a></p>
<ul>
<li><a href="#strategy-implementation">Strategy Implementation</a></li>
<li><a href="#signal-generation-criteria">Signal Generation Criteria</a></li>
<li><a href="#threshold-configuration">Threshold Configuration</a></li>
<li><a href="#logic-implementation-details">Logic Implementation Details</a></li>
<li><a href="#signal-timing-considerations">Signal Timing Considerations</a></li>
<li><a href="#extensibility-features">Extensibility Features</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#hardware-design-approach">Hardware Design Approach</a></p>
<ul>
<li>
<p><a href="#memory-management">Memory Management</a></p>
<ul>
<li><a href="#circular-buffer-design">Circular Buffer Design</a></li>
<li><a href="#pointer-management-strategy">Pointer Management Strategy</a></li>
<li><a href="#memory-access-patterns">Memory Access Patterns</a></li>
<li><a href="#fifo-implementation">FIFO Implementation</a></li>
<li><a href="#overflowunderflow-protection">Overflow/Underflow Protection</a></li>
</ul>
</li>
<li>
<p><a href="#computational-efficiency">Computational Efficiency</a></p>
<ul>
<li><a href="#sliding-window-algorithm-details">Sliding Window Algorithm Details</a></li>
<li><a href="#register-sizing-optimization">Register Sizing Optimization</a></li>
<li><a href="#division-implementation-strategies">Division Implementation Strategies</a></li>
<li><a href="#fixed-point-vs-integer-arithmetic">Fixed Point vs Integer Arithmetic</a></li>
<li><a href="#computation-reuse-techniques">Computation Reuse Techniques</a></li>
</ul>
</li>
<li>
<p><a href="#control-logic">Control Logic</a></p>
<ul>
<li><a href="#fsm-implementation-principles">FSM Implementation Principles</a></li>
<li><a href="#state-encoding-techniques">State Encoding Techniques</a></li>
<li><a href="#control-datapath-separation">Control-Datapath Separation</a></li>
<li><a href="#state-transition-management">State Transition Management</a></li>
<li><a href="#reset-strategy">Reset Strategy</a></li>
<li><a href="#flag-and-control-signal-design">Flag and Control Signal Design</a></li>
</ul>
</li>
<li>
<p><a href="#system-integration">System Integration</a></p>
<ul>
<li><a href="#clock-domain-management">Clock Domain Management</a></li>
<li><a href="#parallel-processing-approach">Parallel Processing Approach</a></li>
<li><a href="#synchronous-design-principles">Synchronous Design Principles</a></li>
<li><a href="#interface-definition-standards">Interface Definition Standards</a></li>
<li><a href="#timing-closure-strategies">Timing Closure Strategies</a></li>
<li><a href="#resource-sharing-approaches">Resource Sharing Approaches</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#modules-documentation">Modules Documentation</a></p>
<ul>
<li>
<p><a href="#moving-average-system">Moving Average System</a></p>
<ul>
<li><a href="#memory-module-details">Memory Module Details</a></li>
<li><a href="#moving-average-fsm-implementation">Moving Average FSM Implementation</a></li>
<li><a href="#port-descriptions-and-timing">Port Descriptions and Timing</a></li>
<li><a href="#internal-register-architecture">Internal Register Architecture</a></li>
<li><a href="#state-machine-design">State Machine Design</a></li>
<li><a href="#signal-timing-relationships">Signal Timing Relationships</a></li>
<li><a href="#module-constraints">Module Constraints</a></li>
<li><a href="#integration-guidelines">Integration Guidelines</a></li>
</ul>
</li>
<li>
<p><a href="#rsi-calculator">RSI Calculator</a></p>
<ul>
<li><a href="#price-fifo-module-details">Price FIFO Module Details</a></li>
<li><a href="#rsi-fsm-module-implementation">RSI FSM Module Implementation</a></li>
<li><a href="#state-machine-deep-dive">State Machine Deep Dive</a></li>
<li><a href="#calculation-logic-details">Calculation Logic Details</a></li>
<li><a href="#timing-requirements">Timing Requirements</a></li>
<li><a href="#resource-utilization-analysis">Resource Utilization Analysis</a></li>
<li><a href="#interface-specifications-1">Interface Specifications</a></li>
<li><a href="#integration-considerations">Integration Considerations</a></li>
</ul>
</li>
<li>
<p><a href="#trading-decision-system">Trading Decision System</a></p>
<ul>
<li><a href="#module-implementation-details">Module Implementation Details</a></li>
<li><a href="#signal-processing-logic">Signal Processing Logic</a></li>
<li><a href="#threshold-management">Threshold Management</a></li>
<li><a href="#signal-generation-implementation">Signal Generation Implementation</a></li>
<li><a href="#timing-characteristics">Timing Characteristics</a></li>
<li><a href="#parameterization-details">Parameterization Details</a></li>
<li><a href="#extension-options">Extension Options</a></li>
</ul>
</li>
<li>
<p><a href="#price-memory-fifo">Price Memory (FIFO)</a></p>
<ul>
<li><a href="#circular-buffer-implementation-details">Circular Buffer Implementation Details</a></li>
<li><a href="#readwrite-pointer-management">Read/Write Pointer Management</a></li>
<li><a href="#fullempty-flag-generation">Full/Empty Flag Generation</a></li>
<li><a href="#data-access-timing">Data Access Timing</a></li>
<li><a href="#reset-behavior">Reset Behavior</a></li>
<li><a href="#parameterization-options">Parameterization Options</a></li>
<li><a href="#resource-efficiency-techniques">Resource Efficiency Techniques</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#implementation-optimizations">Implementation Optimizations</a></p>
<ul>
<li>
<p><a href="#sliding-window-optimization">Sliding Window Optimization</a></p>
<ul>
<li><a href="#algorithm-details">Algorithm Details</a></li>
<li><a href="#computational-complexity-analysis">Computational Complexity Analysis</a></li>
<li><a href="#hardware-implementation-efficiency">Hardware Implementation Efficiency</a></li>
<li><a href="#comparison-with-alternative-approaches">Comparison with Alternative Approaches</a></li>
</ul>
</li>
<li>
<p><a href="#memory-usage-optimization">Memory Usage Optimization</a></p>
<ul>
<li><a href="#circular-buffer-efficiency">Circular Buffer Efficiency</a></li>
<li><a href="#pointer-management-details">Pointer Management Details</a></li>
<li><a href="#memory-architecture-considerations">Memory Architecture Considerations</a></li>
<li><a href="#fpga-specific-memory-optimizations">FPGA-Specific Memory Optimizations</a></li>
</ul>
</li>
<li>
<p><a href="#register-width-optimization">Register Width Optimization</a></p>
<ul>
<li><a href="#precision-requirements-analysis">Precision Requirements Analysis</a></li>
<li><a href="#overflow-prevention-strategies">Overflow Prevention Strategies</a></li>
<li><a href="#resource-utilization-tradeoffs">Resource Utilization Tradeoffs</a></li>
<li><a href="#bit-width-selection-methodology">Bit Width Selection Methodology</a></li>
</ul>
</li>
<li>
<p><a href="#parameterized-design-techniques">Parameterized Design Techniques</a></p>
<ul>
<li><a href="#parameter-definition-strategy">Parameter Definition Strategy</a></li>
<li><a href="#compile-time-configurability">Compile-Time Configurability</a></li>
<li><a href="#design-reuse-approaches">Design Reuse Approaches</a></li>
<li><a href="#implementation-flexibility">Implementation Flexibility</a></li>
<li><a href="#parameter-propagation-methodology">Parameter Propagation Methodology</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#performance-considerations">Performance Considerations</a></p>
<ul>
<li>
<p><a href="#clock-domain-analysis">Clock Domain Analysis</a></p>
<ul>
<li><a href="#single-domain-advantages">Single Domain Advantages</a></li>
<li><a href="#clock-frequency-selection">Clock Frequency Selection</a></li>
<li><a href="#fpga-clock-management">FPGA Clock Management</a></li>
<li><a href="#timing-constraint-approach">Timing Constraint Approach</a></li>
</ul>
</li>
<li>
<p><a href="#calculation-latency-details">Calculation Latency Details</a></p>
<ul>
<li><a href="#moving-average-latency-analysis">Moving Average Latency Analysis</a></li>
<li><a href="#rsi-latency-analysis">RSI Latency Analysis</a></li>
<li><a href="#end-to-end-system-latency">End-to-End System Latency</a></li>
<li><a href="#critical-path-identification">Critical Path Identification</a></li>
<li><a href="#latency-optimization-strategies">Latency Optimization Strategies</a></li>
</ul>
</li>
<li>
<p><a href="#throughput-analysis">Throughput Analysis</a></p>
<ul>
<li><a href="#maximum-throughput-calculation">Maximum Throughput Calculation</a></li>
<li><a href="#sustained-performance-evaluation">Sustained Performance Evaluation</a></li>
<li><a href="#bottleneck-identification">Bottleneck Identification</a></li>
<li><a href="#throughput-enhancement-techniques">Throughput Enhancement Techniques</a></li>
</ul>
</li>
<li>
<p><a href="#synchronization-strategy">Synchronization Strategy</a></p>
<ul>
<li><a href="#parallel-calculation-management">Parallel Calculation Management</a></li>
<li><a href="#trigger-signal-distribution">Trigger Signal Distribution</a></li>
<li><a href="#handshaking-protocol-design">Handshaking Protocol Design</a></li>
<li><a href="#pipeline-balancing-approach">Pipeline Balancing Approach</a></li>
</ul>
</li>
<li>
<p><a href="#resource-utilization">Resource Utilization</a></p>
<ul>
<li><a href="#fpga-resource-analysis">FPGA Resource Analysis</a></li>
<li><a href="#logic-element-requirements">Logic Element Requirements</a></li>
<li><a href="#memory-utilization">Memory Utilization</a></li>
<li><a href="#dsp-block-usage">DSP Block Usage</a></li>
<li><a href="#scaling-considerations">Scaling Considerations</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#verification-and-testing">Verification and Testing</a></p>
<ul>
<li>
<p><a href="#moving-average-testbench">Moving Average Testbench</a></p>
<ul>
<li><a href="#testbench-architecture">Testbench Architecture</a></li>
<li><a href="#test-vector-generation">Test Vector Generation</a></li>
<li><a href="#assertion-strategy">Assertion Strategy</a></li>
<li><a href="#result-verification-methodology">Result Verification Methodology</a></li>
<li><a href="#coverage-analysis">Coverage Analysis</a></li>
<li><a href="#corner-case-testing">Corner Case Testing</a></li>
</ul>
</li>
<li>
<p><a href="#rsi-testbench">RSI Testbench</a></p>
<ul>
<li><a href="#test-pattern-design">Test Pattern Design</a></li>
<li><a href="#rsi-calculation-verification">RSI Calculation Verification</a></li>
<li><a href="#state-machine-testing">State Machine Testing</a></li>
<li><a href="#comprehensive-test-cases">Comprehensive Test Cases</a></li>
<li><a href="#edge-case-handling-verification">Edge Case Handling Verification</a></li>
<li><a href="#result-validation-approach">Result Validation Approach</a></li>
</ul>
</li>
<li>
<p><a href="#trading-system-testbench">Trading System Testbench</a></p>
<ul>
<li><a href="#end-to-end-testing-strategy">End-to-End Testing Strategy</a></li>
<li><a href="#integration-test-methodology">Integration Test Methodology</a></li>
<li><a href="#signal-validation-techniques">Signal Validation Techniques</a></li>
<li><a href="#system-level-timing-verification">System-Level Timing Verification</a></li>
<li><a href="#output-analysis-and-reporting">Output Analysis and Reporting</a></li>
<li><a href="#regression-testing-framework">Regression Testing Framework</a></li>
</ul>
</li>
<li>
<p><a href="#verification-methodology">Verification Methodology</a></p>
<ul>
<li><a href="#unit-testing-approach">Unit Testing Approach</a></li>
<li><a href="#directed-testing">Directed Testing</a></li>
<li><a href="#functional-verification">Functional Verification</a></li>
<li><a href="#assertion-based-verification">Assertion-Based Verification</a></li>
<li><a href="#performance-verification">Performance Verification</a></li>
<li><a href="#coverage-driven-verification">Coverage-Driven Verification</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#usage-guide">Usage Guide</a></p>
<ul>
<li>
<p><a href="#integration-with-larger-systems">Integration with Larger Systems</a></p>
<ul>
<li><a href="#top-level-instantiation">Top-Level Instantiation</a></li>
<li><a href="#signal-connection-guidelines">Signal Connection Guidelines</a></li>
<li><a href="#clocking-considerations">Clocking Considerations</a></li>
<li><a href="#reset-management">Reset Management</a></li>
<li><a href="#interface-protocol">Interface Protocol</a></li>
<li><a href="#data-formatting-requirements">Data Formatting Requirements</a></li>
</ul>
</li>
<li>
<p><a href="#parameter-configuration-1">Parameter Configuration</a></p>
<ul>
<li><a href="#moving-average-configuration">Moving Average Configuration</a></li>
<li><a href="#rsi-configuration">RSI Configuration</a></li>
<li><a href="#trading-threshold-configuration">Trading Threshold Configuration</a></li>
<li><a href="#parameter-selection-guidelines">Parameter Selection Guidelines</a></li>
<li><a href="#parameter-impact-analysis">Parameter Impact Analysis</a></li>
<li><a href="#configuration-management-approach">Configuration Management Approach</a></li>
</ul>
</li>
<li>
<p><a href="#example-applications">Example Applications</a></p>
<ul>
<li><a href="#basic-trading-system">Basic Trading System</a></li>
<li><a href="#multi-instrument-implementation">Multi-Instrument Implementation</a></li>
<li><a href="#market-data-integration">Market Data Integration</a></li>
<li><a href="#backtesting-platform">Backtesting Platform</a></li>
<li><a href="#real-time-trading-system">Real-Time Trading System</a></li>
<li><a href="#research-and-development-platform">Research and Development Platform</a></li>
</ul>
</li>
<li>
<p><a href="#implementation-workflow">Implementation Workflow</a></p>
<ul>
<li><a href="#development-environment-setup">Development Environment Setup</a></li>
<li><a href="#simulation-flow">Simulation Flow</a></li>
<li><a href="#synthesis-process">Synthesis Process</a></li>
<li><a href="#implementation-strategy">Implementation Strategy</a></li>
<li><a href="#timing-closure-methodology">Timing Closure Methodology</a></li>
<li><a href="#deployment-guidelines">Deployment Guidelines</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#extension-possibilities">Extension Possibilities</a></p>
<ul>
<li>
<p><a href="#additional-technical-indicators">Additional Technical Indicators</a></p>
<ul>
<li><a href="#exponential-moving-average">Exponential Moving Average</a></li>
<li><a href="#bollinger-bands">Bollinger Bands</a></li>
<li><a href="#macd-implementation">MACD Implementation</a></li>
<li><a href="#stochastic-oscillator">Stochastic Oscillator</a></li>
<li><a href="#volume-indicators">Volume Indicators</a></li>
<li><a href="#custom-indicator-framework">Custom Indicator Framework</a></li>
</ul>
</li>
<li>
<p><a href="#multiple-timeframes">Multiple Timeframes</a></p>
<ul>
<li><a href="#timeframe-management-architecture">Timeframe Management Architecture</a></li>
<li><a href="#multi-timeframe-data-organization">Multi-Timeframe Data Organization</a></li>
<li><a href="#downsampling-implementation">Downsampling Implementation</a></li>
<li><a href="#signal-combination-strategy">Signal Combination Strategy</a></li>
<li><a href="#resource-sharing-approach">Resource Sharing Approach</a></li>
<li><a href="#system-scalability-considerations">System Scalability Considerations</a></li>
</ul>
</li>
<li>
<p><a href="#advanced-trading-strategies">Advanced Trading Strategies</a></p>
<ul>
<li><a href="#moving-average-crossover-implementation">Moving Average Crossover Implementation</a></li>
<li><a href="#multi-indicator-strategies">Multi-Indicator Strategies</a></li>
<li><a href="#volatility-based-position-sizing">Volatility-Based Position Sizing</a></li>
<li><a href="#custom-strategy-framework">Custom Strategy Framework</a></li>
<li><a href="#strategy-parameterization-approach">Strategy Parameterization Approach</a></li>
<li><a href="#strategy-performance-metrics">Strategy Performance Metrics</a></li>
</ul>
</li>
<li>
<p><a href="#hardware-optimizations">Hardware Optimizations</a></p>
<ul>
<li><a href="#pipelining-techniques">Pipelining Techniques</a></li>
<li><a href="#fixed-point-implementation">Fixed-Point Implementation</a></li>
<li><a href="#custom-division-units">Custom Division Units</a></li>
<li><a href="#multi-clock-domain-design">Multi-Clock Domain Design</a></li>
<li><a href="#resource-sharing-strategies">Resource Sharing Strategies</a></li>
<li><a href="#power-optimization-approaches">Power Optimization Approaches</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#design-considerations-and-tradeoffs">Design Considerations and Tradeoffs</a></p>
<ul>
<li>
<p><a href="#integer-vs-fixed-point-arithmetic-1">Integer vs. Fixed-Point Arithmetic</a></p>
<ul>
<li><a href="#precision-analysis">Precision Analysis</a></li>
<li><a href="#resource-impact-comparison">Resource Impact Comparison</a></li>
<li><a href="#implementation-complexity">Implementation Complexity</a></li>
<li><a href="#error-propagation-characteristics">Error Propagation Characteristics</a></li>
<li><a href="#recommended-implementation-approaches">Recommended Implementation Approaches</a></li>
<li><a href="#migration-strategy">Migration Strategy</a></li>
</ul>
</li>
<li>
<p><a href="#fifo-implementation-tradeoffs">FIFO Implementation Tradeoffs</a></p>
<ul>
<li><a href="#shift-register-vs-circular-buffer">Shift Register vs. Circular Buffer</a></li>
<li><a href="#scaling-characteristics">Scaling Characteristics</a></li>
<li><a href="#memory-resource-utilization">Memory Resource Utilization</a></li>
<li><a href="#access-pattern-efficiency">Access Pattern Efficiency</a></li>
<li><a href="#implementation-complexity-comparison">Implementation Complexity Comparison</a></li>
<li><a href="#selection-guidelines">Selection Guidelines</a></li>
</ul>
</li>
<li>
<p><a href="#calculation-timing-tradeoffs">Calculation Timing Tradeoffs</a></p>
<ul>
<li><a href="#deterministic-vs-variable-latency">Deterministic vs. Variable Latency</a></li>
<li><a href="#resource-implications">Resource Implications</a></li>
<li><a href="#throughput-impact-analysis">Throughput Impact Analysis</a></li>
<li><a href="#design-simplicity-considerations">Design Simplicity Considerations</a></li>
<li><a href="#application-specific-selection-criteria">Application-Specific Selection Criteria</a></li>
<li><a href="#hybrid-approach-possibilities">Hybrid Approach Possibilities</a></li>
</ul>
</li>
<li>
<p><a href="#state-machine-complexity-tradeoffs">State Machine Complexity Tradeoffs</a></p>
<ul>
<li><a href="#simplicity-vs-functionality">Simplicity vs. Functionality</a></li>
<li><a href="#error-handling-capabilities">Error Handling Capabilities</a></li>
<li><a href="#edge-case-management">Edge Case Management</a></li>
<li><a href="#resource-utilization-impact">Resource Utilization Impact</a></li>
<li><a href="#verification-complexity-considerations">Verification Complexity Considerations</a></li>
<li><a href="#recommended-design-patterns">Recommended Design Patterns</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#future-work">Future Work</a></p>
<ul>
<li>
<p><a href="#advanced-implementation-features">Advanced Implementation Features</a></p>
<ul>
<li><a href="#full-parameterization-framework">Full Parameterization Framework</a></li>
<li><a href="#alternative-moving-average-types">Alternative Moving Average Types</a></li>
<li><a href="#advanced-strategy-implementations">Advanced Strategy Implementations</a></li>
<li><a href="#market-data-interface-integration">Market Data Interface Integration</a></li>
<li><a href="#configurable-precision-framework">Configurable Precision Framework</a></li>
<li><a href="#multiple-indicator-framework">Multiple Indicator Framework</a></li>
</ul>
</li>
<li>
<p><a href="#performance-enhancements">Performance Enhancements</a></p>
<ul>
<li><a href="#pipelined-architecture-design">Pipelined Architecture Design</a></li>
<li><a href="#clock-domain-crossing-techniques">Clock Domain Crossing Techniques</a></li>
<li><a href="#resource-sharing-implementation">Resource Sharing Implementation</a></li>
<li><a href="#fixed-point-arithmetic-conversion">Fixed-Point Arithmetic Conversion</a></li>
<li><a href="#memory-architecture-optimization">Memory Architecture Optimization</a></li>
<li><a href="#timing-optimization-strategies">Timing Optimization Strategies</a></li>
</ul>
</li>
<li>
<p><a href="#system-extensions">System Extensions</a></p>
<ul>
<li><a href="#backtesting-infrastructure">Backtesting Infrastructure</a></li>
<li><a href="#position-management-module">Position Management Module</a></li>
<li><a href="#risk-control-framework">Risk Control Framework</a></li>
<li><a href="#multi-instrument-support">Multi-Instrument Support</a></li>
<li><a href="#order-execution-integration">Order Execution Integration</a></li>
<li><a href="#performance-monitoring-system">Performance Monitoring System</a></li>
</ul>
</li>
<li>
<p><a href="#verification-improvements">Verification Improvements</a></p>
<ul>
<li><a href="#automated-test-framework">Automated Test Framework</a></li>
<li><a href="#reference-model-development">Reference Model Development</a></li>
<li><a href="#formal-verification-approach">Formal Verification Approach</a></li>
<li><a href="#statistical-performance-analysis">Statistical Performance Analysis</a></li>
<li><a href="#coverage-driven-verification-implementation">Coverage-Driven Verification Implementation</a></li>
<li><a href="#regression-testing-platform">Regression Testing Platform</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#appendices">Appendices</a></p>
<ul>
<li>
<p><a href="#appendix-a-signal-interface-specifications">Appendix A: Signal Interface Specifications</a></p>
<ul>
<li><a href="#module-interface-tables">Module Interface Tables</a></li>
<li><a href="#timing-diagrams">Timing Diagrams</a></li>
<li><a href="#protocol-specifications">Protocol Specifications</a></li>
<li><a href="#signal-constraints">Signal Constraints</a></li>
<li><a href="#default-values-and-reset-states">Default Values and Reset States</a></li>
</ul>
</li>
<li>
<p><a href="#appendix-b-algorithm-details">Appendix B: Algorithm Details</a></p>
<ul>
<li><a href="#moving-average-calculation-derivation">Moving Average Calculation Derivation</a></li>
<li><a href="#rsi-formula-mathematical-foundation">RSI Formula Mathematical Foundation</a></li>
<li><a href="#trading-strategy-mathematical-analysis">Trading Strategy Mathematical Analysis</a></li>
<li><a href="#optimization-algorithm-derivations">Optimization Algorithm Derivations</a></li>
</ul>
</li>
<li>
<p><a href="#appendix-c-resource-utilization-data">Appendix C: Resource Utilization Data</a></p>
<ul>
<li><a href="#fpga-resource-tables">FPGA Resource Tables</a></li>
<li><a href="#synthesis-results-analysis">Synthesis Results Analysis</a></li>
<li><a href="#device-specific-optimization-notes">Device-Specific Optimization Notes</a></li>
<li><a href="#scaling-data">Scaling Data</a></li>
</ul>
</li>
<li>
<p><a href="#appendix-d-performance-benchmarks">Appendix D: Performance Benchmarks</a></p>
<ul>
<li><a href="#latency-measurements">Latency Measurements</a></li>
<li><a href="#throughput-benchmarks">Throughput Benchmarks</a></li>
<li><a href="#clock-frequency-analysis">Clock Frequency Analysis</a></li>
<li><a href="#power-consumption-data">Power Consumption Data</a></li>
<li><a href="#comparison-with-software-implementations">Comparison with Software Implementations</a></li>
</ul>
</li>
<li>
<p><a href="#appendix-e-verification-test-cases">Appendix E: Verification Test Cases</a></p>
<ul>
<li><a href="#test-vector-specifications">Test Vector Specifications</a></li>
<li><a href="#expected-results-documentation">Expected Results Documentation</a></li>
<li><a href="#corner-case-definitions">Corner Case Definitions</a></li>
<li><a href="#verification-coverage-analysis">Verification Coverage Analysis</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#license">License</a></p>
</li>
</ol>
<hr>
<h2 id="1-introduction">1. Introduction</h2>
<h3 id="project-overview">Project Overview</h3>
<p>This comprehensive project implements a hardware-accelerated technical analysis system for financial trading applications using FPGA technology. The design focuses on efficient computation of widely-used technical indicators, including Simple Moving Average (SMA) and Relative Strength Index (RSI), combined with configurable trading decision logic to generate buy and sell signals.</p>
<p>The implementation leverages hardware-specific optimization techniques, applying digital design principles to achieve deterministic, low-latency processing essential for high-frequency trading applications. The design follows a modular architecture with clean separation between components, enabling flexible customization and extension for diverse trading strategies and market environments.</p>
<p>Key objectives of this project include:</p>
<ol>
<li>Demonstrating efficient hardware implementation of common technical indicators</li>
<li>Providing a platform for algorithmic trading strategy development</li>
<li>Showcasing digital design principles applied to financial analysis</li>
<li>Delivering a framework that balances performance with resource utilization</li>
<li>Creating a foundation for extension with additional indicators and strategies</li>
<li>Establishing verification methodologies appropriate for financial applications</li>
</ol>
<p>The system targets FPGA platforms where deterministic processing of market data streams is required, providing significant performance advantages over software implementations while maintaining flexibility through parameterized design.</p>
<h3 id="technical-analysis-in-trading">Technical Analysis in Trading</h3>
<p>Technical analysis in financial markets involves studying price movements and patterns to forecast future price behavior. Unlike fundamental analysis, which examines economic factors and company metrics, technical analysis focuses exclusively on market data, primarily price and volume information. The approach is based on the premise that price action encompasses all relevant market information and that price movements are not completely random but form identifiable patterns over time.</p>
<p>Key principles of technical analysis include:</p>
<ol>
<li><strong>Price Discounts Everything</strong>: All relevant information (economic, political, psychological) is already reflected in price movements.</li>
<li><strong>Price Moves in Trends</strong>: Once established, trends are more likely to continue than reverse.</li>
<li><strong>History Tends to Repeat</strong>: Market patterns and behaviors recur in predictable ways.</li>
</ol>
<p>Technical indicators are mathematical calculations based on price, volume, or open interest that aim to forecast future price movements. These indicators serve several purposes:</p>
<ul>
<li><strong>Trend Identification</strong>: Determining whether the market is in an uptrend, downtrend, or moving sideways</li>
<li><strong>Momentum Measurement</strong>: Assessing the strength or weakness of a trend</li>
<li><strong>Support/Resistance Level Identification</strong>: Finding price levels where trends may reverse</li>
<li><strong>Volatility Analysis</strong>: Measuring market stability or instability</li>
<li><strong>Overbought/Oversold Conditions</strong>: Identifying potential reversal points</li>
</ul>
<p>This project implements two foundational technical indicators:</p>
<ol>
<li>
<p><strong>Simple Moving Average (SMA)</strong>: The arithmetic mean of a set of prices over a specific period, providing a smoothed price curve that helps identify trends by filtering out short-term fluctuations.</p>
</li>
<li>
<p><strong>Relative Strength Index (RSI)</strong>: A momentum oscillator that measures the speed and change of price movements, ranging from 0 to 100 and helping identify potential overbought (values above 70) or oversold (values below 30) conditions.</p>
</li>
</ol>
<p>These indicators, when combined with appropriate trading logic, form the basis for many algorithmic trading strategies, from simple trend-following systems to complex multi-factor approaches.</p>
<h3 id="hardware-acceleration-benefits">Hardware Acceleration Benefits</h3>
<p>Hardware acceleration provides significant advantages for technical analysis and trading applications, delivering performance characteristics that are difficult or impossible to achieve with software implementations alone. Key benefits include:</p>
<ol>
<li>
<p><strong>Deterministic Latency</strong>: Hardware implementations provide consistent, predictable processing times, eliminating the variability inherent in software execution. This determinism is critical for trading systems where timing precision can significantly impact profitability.</p>
</li>
<li>
<p><strong>Ultra-Low Latency</strong>: FPGAs can process market data with nanosecond to microsecond latency, compared to millisecond-scale processing in typical software systems. This order-of-magnitude improvement enables:</p>
<ul>
<li>Faster reaction to market movements</li>
<li>More precise order timing</li>
<li>Ability to capitalize on short-lived market inefficiencies</li>
<li>Reduced slippage in execution</li>
</ul>
</li>
<li>
<p><strong>High Throughput</strong>: Hardware implementations can process millions of market updates per second, enabling:</p>
<ul>
<li>Simultaneous analysis of multiple instruments</li>
<li>Processing of full market depth data</li>
<li>Real-time analysis across multiple timeframes</li>
<li>Combined analysis of interrelated markets</li>
</ul>
</li>
<li>
<p><strong>Parallel Processing</strong>: FPGAs enable true parallel computation of multiple indicators and strategies without the context-switching overhead present in software:</p>
<ul>
<li>Independent calculation paths operate simultaneously</li>
<li>Scalable architecture for multiple instruments</li>
<li>Efficient implementation of multi-factor strategies</li>
<li>Overlapped computation and communication</li>
</ul>
</li>
<li>
<p><strong>Power Efficiency</strong>: Hardware acceleration typically provides better performance-per-watt compared to general-purpose processors:</p>
<ul>
<li>Reduced energy costs for high-frequency systems</li>
<li>Lower thermal management requirements</li>
<li>More efficient co-location in data centers</li>
<li>Smaller physical footprint for equivalent processing</li>
</ul>
</li>
<li>
<p><strong>Dedicated Resources</strong>: Unlike software running on shared systems, FPGA implementations provide dedicated resources with no contention:</p>
<ul>
<li>Elimination of operating system jitter</li>
<li>No resource competition with other applications</li>
<li>Consistent performance under varying market conditions</li>
<li>Immunity to system-level interruptions</li>
</ul>
</li>
<li>
<p><strong>Security Advantages</strong>: Hardware implementations offer inherent security benefits:</p>
<ul>
<li>Proprietary strategies can be more effectively protected</li>
<li>Reduced attack surface compared to software systems</li>
<li>Physical isolation from general-purpose processing</li>
<li>Proprietary algorithm encapsulation</li>
</ul>
</li>
</ol>
<p>These advantages make hardware acceleration particularly valuable in competitive trading environments where speed, determinism, and efficiency provide strategic advantages.</p>
<h3 id="target-applications">Target Applications</h3>
<p>This FPGA-based technical analysis system is designed for several specific application domains where the combination of performance, determinism, and flexibility provides significant advantages:</p>
<ol>
<li>
<p><strong>High-Frequency Trading (HFT)</strong>:</p>
<ul>
<li>Sub-microsecond reaction to market events</li>
<li>Implementation of statistical arbitrage strategies</li>
<li>Market making with minimal spread exposure</li>
<li>Execution of large orders with minimal market impact</li>
<li>Co-location optimization with exchange matching engines</li>
</ul>
</li>
<li>
<p><strong>Low-Latency Trading Systems</strong>:</p>
<ul>
<li>Trend identification and momentum strategies</li>
<li>Technical breakout detection and position entry</li>
<li>News-based algorithmic trading</li>
<li>Cross-market arbitrage opportunities</li>
<li>Implementation of proprietary timing algorithms</li>
</ul>
</li>
<li>
<p><strong>Multi-Instrument Trading Platforms</strong>:</p>
<ul>
<li>Simultaneous analysis of correlated instruments</li>
<li>Portfolio-level risk management</li>
<li>Basket trading and index arbitrage</li>
<li>Sector rotation strategies</li>
<li>Multi-asset class trading systems</li>
</ul>
</li>
<li>
<p><strong>Market Data Processing Systems</strong>:</p>
<ul>
<li>Real-time filtering and normalization</li>
<li>Feed handling and protocol conversion</li>
<li>Time-series construction and management</li>
<li>Multi-feed synchronization</li>
<li>Custom aggregate level creation</li>
</ul>
</li>
<li>
<p><strong>Backtesting and Simulation Environments</strong>:</p>
<ul>
<li>Accelerated historical data analysis</li>
<li>High-speed strategy optimization</li>
<li>Parameter sensitivity testing</li>
<li>Monte Carlo simulation</li>
<li>Walk-forward analysis</li>
</ul>
</li>
<li>
<p><strong>Risk Management Systems</strong>:</p>
<ul>
<li>Real-time position monitoring</li>
<li>Pre-trade risk checks</li>
<li>Limit management</li>
<li>Exposure calculation</li>
<li>Portfolio stress testing</li>
</ul>
</li>
<li>
<p><strong>Research and Development Platforms</strong>:</p>
<ul>
<li>Algorithm prototyping and validation</li>
<li>Comparative indicator analysis</li>
<li>Strategy refinement and optimization</li>
<li>Novel indicator development</li>
<li>Market microstructure research</li>
</ul>
</li>
</ol>
<p>The modular design approach enables adaptation to these diverse application areas through parameter configuration, module selection, and integration with other system components, all while maintaining the core benefits of hardware acceleration.</p>
<h3 id="fpga-implementation-advantages">FPGA Implementation Advantages</h3>
<p>Field-Programmable Gate Arrays (FPGAs) offer unique advantages as an implementation platform for technical analysis and trading systems, combining hardware performance with software-like flexibility:</p>
<ol>
<li>
<p><strong>Reconfigurability</strong>:</p>
<ul>
<li>Adaptation to changing market conditions and strategies</li>
<li>Field updates without hardware replacement</li>
<li>Iterative optimization and refinement</li>
<li>Platform for A/B testing different implementations</li>
<li>Support for evolving financial protocols and standards</li>
</ul>
</li>
<li>
<p><strong>Customized Datapaths</strong>:</p>
<ul>
<li>Tailored processing pipelines for specific indicators</li>
<li>Optimized arithmetic units for financial calculations</li>
<li>Specialized memory architectures for time-series data</li>
<li>Custom interfaces to market data sources</li>
<li>Precise control over processing granularity</li>
</ul>
</li>
<li>
<p><strong>Massively Parallel Architecture</strong>:</p>
<ul>
<li>Simultaneous computation of multiple indicators</li>
<li>Parallel processing of different instruments</li>
<li>Concurrent timeframe analysis</li>
<li>Pipeline parallelism for high throughput</li>
<li>Scalable design with resource proportionality</li>
</ul>
</li>
<li>
<p><strong>Deterministic Timing Control</strong>:</p>
<ul>
<li>Precise clock domain management</li>
<li>Predictable processing latency</li>
<li>Controlled pipeline stages</li>
<li>Exact synchronization with market events</li>
<li>Deterministic resource allocation</li>
</ul>
</li>
<li>
<p><strong>Hardware-Software Co-Design</strong>:</p>
<ul>
<li>Partition functionality between FPGA and CPU</li>
<li>Offload computation-intensive tasks to hardware</li>
<li>Reserve complex decision logic for software</li>
<li>Balance flexibility and performance</li>
<li>Leverage appropriate technology for each function</li>
</ul>
</li>
<li>
<p><strong>Exchange Connectivity Optimization</strong>:</p>
<ul>
<li>Direct implementation of exchange protocols</li>
<li>Hardware-accelerated feed handlers</li>
<li>Optimized TCP/IP or UDP stacks</li>
<li>Custom physical layer interfaces</li>
<li>Low-latency order entry systems</li>
</ul>
</li>
<li>
<p><strong>Development Methodology</strong>:</p>
<ul>
<li>Hardware description languages for precise control</li>
<li>High-level synthesis for complex algorithms</li>
<li>Simulation-based verification</li>
<li>Hardware-in-the-loop testing</li>
<li>Incremental implementation and deployment</li>
</ul>
</li>
<li>
<p><strong>Deployment Flexibility</strong>:</p>
<ul>
<li>Co-location with exchange systems</li>
<li>Integration with existing trading infrastructure</li>
<li>Standalone appliance deployment</li>
<li>Network appliance implementation</li>
<li>Cloud FPGA (F1/Alveo) implementation options</li>
</ul>
</li>
</ol>
<p>These advantages position FPGAs as an ideal platform for implementing technical analysis systems that require both high performance and adaptability to changing market conditions and strategies.</p>
<h3 id="system-capabilities">System Capabilities</h3>
<p>The FPGA-based technical analysis trading system offers a comprehensive set of capabilities designed to support advanced algorithmic trading strategies with exceptional performance characteristics:</p>
<ol>
<li>
<p><strong>Technical Indicator Calculation</strong>:</p>
<ul>
<li>20-period Simple Moving Average (configurable window size)</li>
<li>14-period Relative Strength Index (configurable period)</li>
<li>Extensible framework for additional indicators</li>
<li>Parallel calculation of multiple indicators</li>
<li>Parameterized implementation for customization</li>
</ul>
</li>
<li>
<p><strong>Signal Generation</strong>:</p>
<ul>
<li>Configurable buy/sell threshold settings</li>
<li>Momentum-based mean reversion strategy</li>
<li>Combined indicator approach (price, MA, RSI)</li>
<li>Clean signal timing with minimal latency</li>
<li>Protection against signal oscillation</li>
</ul>
</li>
<li>
<p><strong>Data Management</strong>:</p>
<ul>
<li>Efficient circular buffer implementation</li>
<li>Configurable history depth for each indicator</li>
<li>Sliding window optimization for O(1) calculations</li>
<li>Overflow and underflow protection</li>
<li>Synchronized data access between modules</li>
</ul>
</li>
<li>
<p><strong>Performance Characteristics</strong>:</p>
<ul>
<li>Single-cycle response to new price data</li>
<li>2-4 cycle latency for indicator calculation</li>
<li>Support for 100+ MHz clock frequencies</li>
<li>Throughput of millions of updates per second</li>
<li>Deterministic timing regardless of market conditions</li>
</ul>
</li>
<li>
<p><strong>Resource Efficiency</strong>:</p>
<ul>
<li>Optimized register usage for precision requirements</li>
<li>Minimal memory footprint for price history</li>
<li>Efficient arithmetic implementation</li>
<li>Scalable design for different FPGA sizes</li>
<li>Balance between performance and resource utilization</li>
</ul>
</li>
<li>
<p><strong>Operational Flexibility</strong>:</p>
<ul>
<li>Asynchronous reset for system initialization</li>
<li>Clear completion signaling for downstream processing</li>
<li>Status flags for system monitoring</li>
<li>Configurable parameters for different markets</li>
<li>Support for integration with larger systems</li>
</ul>
</li>
<li>
<p><strong>Verification Framework</strong>:</p>
<ul>
<li>Comprehensive testbenches for all components</li>
<li>Reference data for validation</li>
<li>Result checking mechanisms</li>
<li>Waveform generation for analysis</li>
<li>Documentation of testing methodology</li>
</ul>
</li>
</ol>
<p>These capabilities provide a solid foundation for implementing sophisticated trading strategies with the performance characteristics required for competitive market environments.</p>
<h2 id="2-repository-structure">2. Repository Structure</h2>
<h3 id="directory-organization">Directory Organization</h3>
<p>The repository is organized into a hierarchical structure that separates different aspects of the technical analysis system, enabling focused development and testing of individual components while maintaining a clear path to system integration:</p>
<pre class="hljs"><code><div>Implementation_of_Technical_analysis_on_FPGA/

 Combined_analysis/         # Integrated trading system implementation
    implementation.md      # Detailed implementation documentation
    moving_average_fsm.v   # Moving average FSM implementation
    price_memory.v         # Price memory (FIFO) implementation
    readme.md              # System documentation
    rsi_inc.v              # RSI implementation
    tb_trading_system_singlemem.v  # Testbench for trading system
    trading_decision.v     # Trading decision logic
    trading_system_singlemem.v     # Top-level system integration

 Moving_average/            # Moving average specific implementation
    Implementation Analysis.md      # In-depth analysis
    implementation_Summary.md       # Summary of implementation
    memory.v                        # Memory module for MA
    moving_average_fsm.v            # MA state machine
    readme.md                       # Documentation
    trading_system_tb.v             # MA system testbench

 rsi_verilog_project/                # RSI specific implementation
    implementation_summary.md       # RSI implementation summary
    price_fifo.v                    # Price FIFO for RSI
    readme.md                       # RSI documentation
    rsi_fsm.v                       # RSI state machine
    rsi_testbench.v                 # RSI testbench

 LICENSE                    # MIT License
 README.md                  # Repository overview
</div></code></pre>
<p>This organization follows a modular development approach where:</p>
<ol>
<li>Each technical indicator has its own directory for focused development</li>
<li>The combined analysis directory integrates all components into a complete system</li>
<li>Documentation is distributed alongside the corresponding implementation files</li>
<li>Testbenches are provided for both individual components and integrated systems</li>
<li>License and high-level documentation are maintained at the repository root</li>
</ol>
<p>This structure supports both top-down and bottom-up development approaches, allowing developers to:</p>
<ul>
<li>Focus on individual components in isolation</li>
<li>Understand the complete system through integrated documentation</li>
<li>Follow clear paths for both implementation and testing</li>
<li>Identify dependencies between components</li>
<li>Trace requirements from system specification to implementation</li>
</ul>
<p>The separation of concerns between different directories also enables parallel development by different team members with minimal conflict risk.</p>
<h3 id="combined-analysis-components">Combined Analysis Components</h3>
<p>The <code>Combined_analysis/</code> directory contains the integrated trading system implementation, bringing together all components into a cohesive whole. This directory represents the culmination of the development process, where individual technical indicators and supporting modules are combined into a functional trading system.</p>
<p>Key components in this directory include:</p>
<ol>
<li>
<p><strong>implementation.md</strong>:</p>
<ul>
<li>Comprehensive documentation of the integrated system</li>
<li>Detailed explanation of system architecture</li>
<li>Component interaction specifications</li>
<li>Implementation optimizations</li>
<li>Performance considerations</li>
<li>Usage guidance</li>
</ul>
</li>
<li>
<p><strong>price_memory.v</strong>:</p>
<ul>
<li>Circular FIFO buffer implementation for price history</li>
<li>Configurable depth and width parameters</li>
<li>Full/empty status signaling</li>
<li>Pointer management for efficient memory utilization</li>
<li>Integration with both MA and RSI calculations</li>
</ul>
</li>
<li>
<p><strong>moving_average_fsm.v</strong>:</p>
<ul>
<li>Finite State Machine for moving average calculation</li>
<li>Sliding window algorithm implementation</li>
<li>Extended precision to prevent overflow</li>
<li>Synchronization with price memory</li>
<li>Completion signaling</li>
</ul>
</li>
<li>
<p><strong>rsi_inc.v</strong>:</p>
<ul>
<li>Incremental RSI calculation implementation</li>
<li>Gain/loss tracking and accumulation</li>
<li>RSI formula calculation with protection against division by zero</li>
<li>State management for sequential processing</li>
<li>Integration with price memory</li>
</ul>
</li>
<li>
<p><strong>trading_decision.v</strong>:</p>
<ul>
<li>Trading strategy implementation</li>
<li>Configurable threshold parameters</li>
<li>Signal generation based on indicator conditions</li>
<li>Synchronized output signaling</li>
<li>Clean reset behavior</li>
</ul>
</li>
<li>
<p><strong>trading_system_singlemem.v</strong>:</p>
<ul>
<li>Top-level integration module</li>
<li>Component instantiation and connection</li>
<li>Signal routing between modules</li>
<li>System-level control logic</li>
<li>Interface definition for external systems</li>
</ul>
</li>
<li>
<p><strong>tb_trading_system_singlemem.v</strong>:</p>
<ul>
<li>Comprehensive system testbench</li>
<li>Test vector generation</li>
<li>Result validation</li>
<li>Signal monitoring and reporting</li>
<li>End-to-end functionality verification</li>
</ul>
</li>
</ol>
<p>This directory provides a complete implementation that can be directly synthesized for FPGA deployment, with thorough documentation to support understanding, modification, and integration into larger trading platforms.</p>
<h3 id="moving-average-specific-components">Moving Average Specific Components</h3>
<p>The <code>Moving_average/</code> directory contains a focused implementation of the Simple Moving Average (SMA) indicator, including both the core calculation module and supporting components for testing and documentation:</p>
<ol>
<li>
<p><strong>Implementation Analysis.md</strong>:</p>
<ul>
<li>In-depth technical analysis of the moving average implementation</li>
<li>Detailed explanation of design decisions</li>
<li>Algorithmic complexity analysis</li>
<li>Performance characteristics</li>
<li>Resource utilization evaluation</li>
<li>Optimization techniques</li>
<li>Implementation challenges and solutions</li>
</ul>
</li>
<li>
<p><strong>implementation_Summary.md</strong>:</p>
<ul>
<li>Concise overview of the moving average system</li>
<li>Key features and capabilities</li>
<li>Design approach summary</li>
<li>Interface specifications</li>
<li>Usage guidelines</li>
<li>Performance metrics</li>
</ul>
</li>
<li>
<p><strong>memory.v</strong>:</p>
<ul>
<li>Price history storage implementation for moving average calculation</li>
<li>FIFO buffer design for sequential price access</li>
<li>Management of read/write operations</li>
<li>Status signaling (full, empty, count)</li>
<li>Efficient memory utilization</li>
</ul>
</li>
<li>
<p><strong>moving_average_fsm.v</strong>:</p>
<ul>
<li>Finite State Machine for controlling the calculation process</li>
<li>Sliding window algorithm implementation</li>
<li>Sum maintenance and average calculation</li>
<li>Synchronization with memory module</li>
<li>Completion signaling</li>
</ul>
</li>
<li>
<p><strong>readme.md</strong>:</p>
<ul>
<li>User-oriented documentation</li>
<li>Implementation overview</li>
<li>Usage instructions</li>
<li>Parameter configuration guide</li>
<li>Integration guidance</li>
<li>Performance expectations</li>
</ul>
</li>
<li>
<p><strong>trading_system_tb.v</strong>:</p>
<ul>
<li>Testbench for validating the moving average implementation</li>
<li>Test vector generation</li>
<li>Clock and reset generation</li>
<li>Result verification</li>
<li>Performance measurement</li>
<li>Waveform generation for analysis</li>
</ul>
</li>
</ol>
<p>This directory provides a self-contained implementation of the moving average calculation that can be used independently or integrated into the combined system. The separation allows for focused development and testing of the moving average functionality, with comprehensive documentation to support understanding and modification.</p>
<p>The implementation in this directory may have slight variations from the version in the combined analysis directory, representing either alternative approaches or refinements that were later incorporated into the integrated system.</p>
<h3 id="rsi-specific-components">RSI Specific Components</h3>
<p>The <code>rsi_verilog_project/</code> directory contains a dedicated implementation of the Relative Strength Index (RSI) indicator, with all necessary components for independent development, testing, and documentation:</p>
<ol>
<li>
<p><strong>implementation_summary.md</strong>:</p>
<ul>
<li>Comprehensive explanation of the RSI implementation</li>
<li>Theoretical foundation of RSI calculation</li>
<li>Design architecture overview</li>
<li>State machine explanation</li>
<li>Algorithm details</li>
<li>Performance characteristics</li>
<li>Usage guidance</li>
</ul>
</li>
<li>
<p><strong>price_fifo.v</strong>:</p>
<ul>
<li>Specialized FIFO implementation for RSI price history</li>
<li>Parameterized depth and width configuration</li>
<li>Read/write pointer management</li>
<li>Status flag generation</li>
<li>Efficient memory utilization</li>
<li>Reset behavior specification</li>
</ul>
</li>
<li>
<p><strong>readme.md</strong>:</p>
<ul>
<li>User-focused documentation</li>
<li>RSI theory and application</li>
<li>Implementation overview</li>
<li>Configuration options</li>
<li>Integration guidelines</li>
<li>Performance expectations</li>
<li>Testing approach</li>
</ul>
</li>
<li>
<p><strong>rsi_fsm.v</strong>:</p>
<ul>
<li>Finite State Machine implementation for RSI calculation</li>
<li>State definitions and transitions</li>
<li>Gain/loss accumulation logic</li>
<li>FIFO integration and control</li>
<li>Final RSI calculation</li>
<li>Edge case handling</li>
<li>Completion signaling</li>
</ul>
</li>
<li>
<p><strong>rsi_testbench.v</strong>:</p>
<ul>
<li>Comprehensive verification environment</li>
<li>Test pattern generation</li>
<li>Clock and reset management</li>
<li>Result validation</li>
<li>State transition verification</li>
<li>Performance measurement</li>
<li>Output reporting</li>
</ul>
</li>
</ol>
<p>The RSI implementation follows a more complex state machine approach compared to the moving average, reflecting the additional steps required for RSI calculation:</p>
<ul>
<li>FIFO filling</li>
<li>Initial price capture</li>
<li>Price comparison for gain/loss determination</li>
<li>Accumulation of gains and losses</li>
<li>Final RSI formula calculation</li>
</ul>
<p>This directory provides a standalone RSI implementation that can be used independently or integrated into the combined trading system, with thorough documentation and verification to ensure correctness and performance.</p>
<h3 id="file-naming-conventions">File Naming Conventions</h3>
<p>The repository follows consistent file naming conventions to aid navigation and understanding:</p>
<ol>
<li>
<p><strong>Verilog Implementation Files</strong>:</p>
<ul>
<li>Named according to the module they implement</li>
<li>Use lowercase with underscores to separate words</li>
<li>End with the <code>.v</code> extension</li>
<li>Examples: <code>price_memory.v</code>, <code>moving_average_fsm.v</code>, <code>rsi_inc.v</code></li>
</ul>
</li>
<li>
<p><strong>Testbench Files</strong>:</p>
<ul>
<li>Prefixed with <code>tb_</code> or include <code>testbench</code> in the name</li>
<li>Describe the component being tested</li>
<li>End with the <code>.v</code> extension</li>
<li>Examples: <code>tb_trading_system_singlemem.v</code>, <code>rsi_testbench.v</code></li>
</ul>
</li>
<li>
<p><strong>Documentation Files</strong>:</p>
<ul>
<li>Use descriptive names indicating content type</li>
<li>Written in Markdown format with the <code>.md</code> extension</li>
<li>Include terms like <code>implementation</code>, <code>analysis</code>, or <code>summary</code> to indicate purpose</li>
<li>Examples: <code>implementation.md</code>, <code>Implementation Analysis.md</code>, <code>readme.md</code></li>
</ul>
</li>
<li>
<p><strong>Top-level Integration Files</strong>:</p>
<ul>
<li>Include <code>system</code> in the name to indicate integration role</li>
<li>May include qualifiers like <code>singlemem</code> to indicate implementation approach</li>
<li>Follow standard Verilog naming conventions</li>
<li>Example: <code>trading_system_singlemem.v</code></li>
</ul>
</li>
<li>
<p><strong>Component-Specific Files</strong>:</p>
<ul>
<li>Named to indicate the technical indicator they implement</li>
<li>Include functional qualifiers like <code>fsm</code> or <code>fifo</code></li>
<li>Follow standard Verilog naming conventions</li>
<li>Examples: <code>moving_average_fsm.v</code>, <code>price_fifo.v</code></li>
</ul>
</li>
</ol>
<p>These naming conventions support:</p>
<ul>
<li>Quick identification of file purpose</li>
<li>Clear indication of module functionality</li>
<li>Distinction between implementation and test files</li>
<li>Consistent structure across directories</li>
<li>Easy location of documentation</li>
<li>Transparent identification of dependencies</li>
</ul>
<p>Maintaining these conventions simplifies repository navigation, code review, and integration activities, while reducing the learning curve for new contributors.</p>
<h3 id="documentation-approach">Documentation Approach</h3>
<p>The repository employs a comprehensive documentation approach that distributes information across multiple levels of detail and focus, ensuring that both high-level understanding and implementation details are adequately captured:</p>
<ol>
<li>
<p><strong>Repository-Level Documentation</strong>:</p>
<ul>
<li><code>README.md</code>: High-level overview of the entire project, explaining purpose, structure, and usage</li>
<li><code>LICENSE</code>: Legal terms governing the use, modification, and distribution of the code</li>
</ul>
</li>
<li>
<p><strong>Directory-Level Documentation</strong>:</p>
<ul>
<li><code>readme.md</code> files in each directory providing context for the contained components</li>
<li>Implementation summaries that explain the approach taken for each major component</li>
<li>Analysis documents that delve into design decisions, optimizations, and tradeoffs</li>
</ul>
</li>
<li>
<p><strong>Implementation Documentation</strong>:</p>
<ul>
<li>Detailed comments within Verilog files explaining functionality</li>
<li>Module-level headers describing purpose, parameters, ports, and behavior</li>
<li>Signal naming that reflects functionality</li>
<li>State definitions with explanatory comments</li>
<li>Algorithm explanations for complex calculations</li>
</ul>
</li>
<li>
<p><strong>Interface Documentation</strong>:</p>
<ul>
<li>Port descriptions including direction, width, and purpose</li>
<li>Timing relationships between signals</li>
<li>Protocol specifications for module interaction</li>
<li>Parameter explanations and configuration guidance</li>
<li>Reset behavior and initialization requirements</li>
</ul>
</li>
<li>
<p><strong>Verification Documentation</strong>:</p>
<ul>
<li>Testbench descriptions explaining verification approach</li>
<li>Test vector generation methodology</li>
<li>Expected results and validation criteria</li>
<li>Coverage analysis (where applicable)</li>
<li>Corner case identification and testing</li>
</ul>
</li>
<li>
<p><strong>Performance Documentation</strong>:</p>
<ul>
<li>Latency and throughput characteristics</li>
<li>Resource utilization measurements</li>
<li>Timing constraint information</li>
<li>Scalability analysis</li>
<li>Optimization guidance</li>
</ul>
</li>
</ol>
<p>The documentation is written to serve multiple audiences:</p>
<ul>
<li>New users seeking to understand the system's capabilities</li>
<li>Developers looking to modify or extend functionality</li>
<li>Integrators needing to incorporate the system into larger designs</li>
<li>Reviewers evaluating implementation quality and correctness</li>
<li>Researchers interested in the algorithmic approaches</li>
</ul>
<p>This multi-layered approach ensures that information is available at the appropriate level of detail for different purposes, from high-level overview to detailed implementation specifics, supporting both understanding and practical application of the technical analysis system.</p>
<h2 id="3-system-architecture">3. System Architecture</h2>
<h3 id="high-level-design">High-Level Design</h3>
<p>The technical analysis trading system follows a structured, modular architecture designed to efficiently process market data and generate trading signals. The high-level design emphasizes clear separation of concerns, deterministic data flow, and efficient resource utilization.</p>
<p>At the core of the architecture are three primary functional blocks:</p>
<ol>
<li>
<p><strong>Data Management (Price Memory)</strong>:</p>
<ul>
<li>Maintains history of price data in a circular buffer</li>
<li>Provides both newest and oldest prices for calculation</li>
<li>Tracks buffer fill level and signals when full</li>
<li>Manages efficient memory utilization through pointer manipulation</li>
<li>Serves as the central data repository for all indicator calculations</li>
</ul>
</li>
<li>
<p><strong>Technical Indicator Calculation</strong>:</p>
<ul>
<li>Moving Average Module: Calculates the simple moving average over a configurable window</li>
<li>RSI Module: Calculates the relative strength index using accumulated gains and losses</li>
<li>Each indicator operates independently on the shared price data</li>
<li>Calculation modules signal completion to synchronize downstream processing</li>
</ul>
</li>
<li>
<p><strong>Trading Decision Logic</strong>:</p>
<ul>
<li>Evaluates indicator values against predefined criteria</li>
<li>Implements configurable trading strategy</li>
<li>Generates clean buy/sell signals based on conditions</li>
<li>Synchronizes with indicator calculation timing</li>
<li>Provides the primary output interface to external systems</li>
</ul>
</li>
</ol>
<p>These components are arranged in a pipeline architecture where:</p>
<ol>
<li>New price data enters the system</li>
<li>Prices are stored in the circular buffer</li>
<li>Technical indicators are calculated when sufficient data is available</li>
<li>Trading decisions are made based on the calculated indicators</li>
<li>Buy/sell signals are generated as system outputs</li>
</ol>
<p>The design prioritizes:</p>
<ul>
<li><strong>Modularity</strong>: Each component has a well-defined responsibility and interface</li>
<li><strong>Configurability</strong>: Parameters allow customization without code changes</li>
<li><strong>Efficiency</strong>: Algorithms minimize computational complexity</li>
<li><strong>Determinism</strong>: Processing follows predictable timing patterns</li>
<li><strong>Scalability</strong>: The architecture can be extended with additional indicators</li>
<li><strong>Maintainability</strong>: Clear separation of concerns simplifies modifications</li>
</ul>
<p>This high-level architecture provides the foundation for detailed implementation, with each component refined to meet specific performance and resource utilization goals.</p>
<h3 id="module-interactions">Module Interactions</h3>
<p>The technical analysis system's components interact through a well-defined set of interfaces and data flows, creating a cohesive system while maintaining separation of concerns. These interactions are carefully designed to ensure proper synchronization, data integrity, and efficient processing.</p>
<p>The primary module interactions include:</p>
<ol>
<li>
<p><strong>Price Input to Price Memory</strong>:</p>
<ul>
<li>New price data (<code>price_in</code>) is provided to the system along with a strobe signal (<code>new_price</code>)</li>
<li>The Price Memory module captures this data when <code>write_enable</code> is asserted</li>
<li>The memory updates its internal state, including pointers and counters</li>
<li>The <code>mem_full</code> signal is generated when sufficient prices are collected</li>
</ul>
</li>
<li>
<p><strong>Price Memory to Moving Average FSM</strong>:</p>
<ul>
<li>The <code>oldest_price</code> output from Price Memory is connected to the MA FSM</li>
<li>The newest price (<code>price_in</code>) is directly provided to the MA FSM</li>
<li>When memory is full (<code>mem_full</code>), the MA calculation is triggered through the <code>start</code> signal</li>
<li>The MA FSM processes these prices to calculate the moving average</li>
<li>Upon completion, the <code>done</code> signal is asserted to indicate valid output</li>
</ul>
</li>
<li>
<p><strong>Price Memory to RSI Calculator</strong>:</p>
<ul>
<li>Similarly, the RSI module receives price data from the Price Memory</li>
<li>The <code>new_price_strobe</code> signal synchronizes data acquisition</li>
<li>The <code>mem_count</code> signal indicates available data depth</li>
<li>The RSI module processes prices to calculate gain/loss and final RSI</li>
<li>The RSI <code>done</code> signal indicates calculation completion</li>
</ul>
</li>
<li>
<p><strong>Indicator Modules to Trading Decision</strong>:</p>
<ul>
<li>The Moving Average output (<code>moving_avg</code>) is provided to the Trading Decision module</li>
<li>The RSI output (<code>rsi</code>) is connected to the Trading Decision logic</li>
<li>The current price (<code>price_now</code>) is also provided for comparison</li>
<li>The Trading Decision module evaluates these inputs against thresholds</li>
<li>Buy/sell signals are generated based on the combined conditions</li>
</ul>
</li>
<li>
<p><strong>System-Level Synchronization</strong>:</p>
<ul>
<li>The <code>mem_full</code> signal serves as the primary trigger for calculations</li>
<li>The <code>compute_enable</code> signal (derived from <code>mem_count</code>) ensures sufficient data</li>
<li>Indicator <code>done</code> signals provide synchronization points</li>
<li>All modules share common clock and reset signals</li>
<li>The clock domain is unified for deterministic timing</li>
</ul>
</li>
</ol>
<p>These interactions are implemented through direct port connections in the top-level module:</p>
<pre class="hljs"><code><div>price_memory mem14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.wr_en</span>(new_price),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.full</span>(mem_full),
    <span class="hljs-variable">.count</span>(count)
);

moving_average_fsm ma14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),
    <span class="hljs-variable">.done</span>(ma_done)
);

rsi_inc rsi14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.mem_full</span>(mem_full),
    <span class="hljs-variable">.mem_count</span>(mem_cnt),
    <span class="hljs-variable">.rsi</span>(rsi),
    <span class="hljs-variable">.done</span>(rsi_done)
);

trading_decision dec (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.price_now</span>(price_in),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),
    <span class="hljs-variable">.rsi</span>(rsi),
    <span class="hljs-variable">.buy</span>(buy),
    <span class="hljs-variable">.sell</span>(sell)
);
</div></code></pre>
<p>The careful design of these interactions ensures that:</p>
<ul>
<li>Data flows predictably through the system</li>
<li>Calculations are triggered at appropriate times</li>
<li>Outputs are only used when valid</li>
<li>Synchronization is maintained without complex handshaking</li>
<li>Resource sharing is optimized where appropriate</li>
<li>System behavior is deterministic and verifiable</li>
</ul>
<p>These well-defined interactions simplify system integration, verification, and future extension with additional components.</p>
<h3 id="data-flow-architecture">Data Flow Architecture</h3>
<p>The technical analysis system implements a streamlined data flow architecture optimized for sequential processing of financial time series data. This architecture ensures efficient data movement, minimizes redundant storage, and supports parallel indicator calculation while maintaining data consistency.</p>
<p>The data flow follows a structured path through the system:</p>
<ol>
<li>
<p><strong>Data Ingestion</strong>:</p>
<ul>
<li>New price data enters through the <code>price_in</code> port</li>
<li>The <code>new_price</code> signal indicates valid data</li>
<li>Prices are accepted at the system clock rate when enabled</li>
<li>No preprocessing or normalization is performed</li>
</ul>
</li>
<li>
<p><strong>Price History Management</strong>:</p>
<ul>
<li>The Price Memory module stores incoming prices</li>
<li>A circular buffer maintains the most recent N prices</li>
<li>Write operations add new prices at the current write pointer</li>
<li>Read operations provide the oldest price from the read pointer</li>
<li>Pointers wrap around to implement circular behavior</li>
<li>Counter tracks the number of valid prices in the buffer</li>
</ul>
</li>
<li>
<p><strong>Data Distribution</strong>:</p>
<ul>
<li>Once sufficient prices are collected, data is distributed to indicator modules</li>
<li>The current price (<code>price_in</code>) is provided directly to calculation modules</li>
<li>The oldest price (<code>oldest_price</code>) is provided from memory</li>
<li>All prices between newest and oldest remain in the circular buffer</li>
<li>This approach minimizes data duplication while maintaining access</li>
</ul>
</li>
<li>
<p><strong>Indicator Calculation</strong>:</p>
<ul>
<li>Moving Average and RSI modules process the distributed data</li>
<li>Each module maintains internal state for calculation continuity</li>
<li>MA maintains a running sum for the sliding window</li>
<li>RSI tracks gain/loss accumulators for momentum calculation</li>
<li>Calculations proceed independently but are triggered synchronously</li>
</ul>
</li>
<li>
<p><strong>Decision Processing</strong>:</p>
<ul>
<li>Indicator outputs flow to the Trading Decision module</li>
<li>Current price is compared with Moving Average</li>
<li>RSI value is evaluated against thresholds</li>
<li>Combined conditions generate trading signals</li>
<li>Signal outputs represent the final data flow products</li>
</ul>
</li>
<li>
<p><strong>Output Generation</strong>:</p>
<ul>
<li>Buy/sell signals are generated as primary outputs</li>
<li>Indicator values are also provided as outputs</li>
<li>Status signals indicate system state</li>
<li>Debug outputs provide visibility into internal operation</li>
</ul>
</li>
</ol>
<p>This data flow is characterized by several key design principles:</p>
<ul>
<li><strong>Single Data Path</strong>: Price data follows a single path through the system</li>
<li><strong>Minimal Data Duplication</strong>: Prices are stored only once in the central buffer</li>
<li><strong>Efficient Access Patterns</strong>: Sliding window approach minimizes memory operations</li>
<li><strong>Parallel Processing</strong>: Indicators calculate simultaneously with shared data</li>
<li><strong>Temporal Consistency</strong>: All calculations use the same time window of prices</li>
<li><strong>Streamlined Movement</strong>: Data flows without unnecessary buffering or staging</li>
</ul>
<p>The data flow architecture is visualized in the following diagram:</p>
<pre class="hljs"><code><div>                  Price Input
                      
                      
                 
                  Price   
                  Memory  
                 
                      
         
                                 
                                 
               
    Moving                   RSI     
    Average                Calculator
               
                                 
                                 
         
                      
                      
               
                  Trading   
                 Decision   
               
                      
                      
              Trading Signals
</div></code></pre>
<p>This architecture achieves an optimal balance between performance and resource utilization, enabling efficient calculation of technical indicators with minimal latency and consistent timing characteristics.</p>
<h3 id="clock-domain-strategy">Clock Domain Strategy</h3>
<p>The technical analysis system implements a single clock domain strategy to simplify timing analysis, minimize synchronization issues, and ensure deterministic behavior. This approach leverages the relatively modest clock frequency requirements of financial data processing while eliminating the complexity and potential metastability issues associated with clock domain crossing.</p>
<p>Key aspects of the clock domain strategy include:</p>
<ol>
<li>
<p><strong>Unified Clock Signal</strong>:</p>
<ul>
<li>All modules operate from a single system clock</li>
<li>The clock is distributed with minimal skew</li>
<li>Typical operating frequencies range from 50-200 MHz</li>
<li>All sequential elements are synchronized to this clock</li>
<li>No clock division or multiplication is implemented</li>
</ul>
</li>
<li>
<p><strong>Synchronous Design Principles</strong>:</p>
<ul>
<li>All state transitions occur on the rising edge of the clock</li>
<li>Combinational logic paths are designed for single-cycle timing closure</li>
<li>Registered outputs ensure clean signal transitions</li>
<li>Input synchronization for external signals (when needed)</li>
<li>Avoidance of gated clocks for reliability</li>
</ul>
</li>
<li>
<p><strong>Reset Management</strong>:</p>
<ul>
<li>Asynchronous reset for system initialization</li>
<li>Reset signal is distributed to all modules</li>
<li>Synchronized de-assertion for stability</li>
<li>Defined reset state for all registers</li>
<li>Consistent reset polarity (active high)</li>
</ul>
</li>
<li>
<p><strong>Timing Closure Approach</strong>:</p>
<ul>
<li>Clear timing paths with minimal combinational depth</li>
<li>Pipelining of complex operations where necessary</li>
<li>Balanced logic distribution</li>
<li>Margin for implementation variations</li>
<li>Conservative setup/hold timing</li>
</ul>
</li>
<li>
<p><strong>Performance Considerations</strong>:</p>
<ul>
<li>Maximum clock frequency determined by critical path delay</li>
<li>Division operations often define the critical path</li>
<li>Target frequencies allow substantial margin</li>
<li>Performance scaling with clock frequency</li>
<li>Known latency in clock cycles regardless of frequency</li>
</ul>
</li>
</ol>
<p>The single clock domain approach offers several advantages for this application:</p>
<ul>
<li><strong>Simplified Design</strong>: No complex synchronization or handshaking required</li>
<li><strong>Deterministic Behavior</strong>: Consistent cycle counts for operations</li>
<li><strong>Reduced Complexity</strong>: Elimination of metastability concerns</li>
<li><strong>Improved Reliability</strong>: Fewer potential timing issues</li>
<li><strong>Easier Verification</strong>: Simpler timing analysis and testing</li>
<li><strong>Straightforward Debugging</strong>: Predictable signal relationships</li>
<li><strong>Enhanced Portability</strong>: Less dependency on specific FPGA clock resources</li>
</ul>
<p>For integration with external systems operating on different clock domains, standard synchronization techniques would be implemented at the system boundaries:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Example input synchronization (if needed)</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sync_price_valid;
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    sync_price_valid &lt;= {sync_price_valid[<span class="hljs-number">0</span>], ext_price_valid};
    <span class="hljs-keyword">if</span> (sync_price_valid == <span class="hljs-number">2&#x27;b01</span>) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Rising edge detected, process new price</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>The single clock domain strategy is appropriate for this application because:</p>
<ul>
<li>Financial data typically arrives at rates much lower than achievable clock frequencies</li>
<li>Processing requirements are well within the capabilities of modern FPGAs at moderate frequencies</li>
<li>System complexity does not justify the overhead of multiple clock domains</li>
<li>Deterministic behavior is prioritized over specialized performance optimization</li>
</ul>
<p>This approach creates a robust foundation for the trading system, ensuring reliable operation with predictable timing characteristics.</p>
<h3 id="control-flow-management">Control Flow Management</h3>
<p>The technical analysis system implements a sophisticated control flow strategy that orchestrates operation sequencing, ensures proper data handling, and maintains synchronization between components. This approach combines state machines, handshaking signals, and status flags to create a deterministic and well-coordinated system behavior.</p>
<p>Key elements of the control flow management include:</p>
<ol>
<li>
<p><strong>Finite State Machines (FSMs)</strong>:</p>
<ul>
<li>Each major calculation module implements an FSM to control its operation</li>
<li>FSMs provide clear operational phases with well-defined transitions</li>
<li>State encoding is optimized for clarity and efficient synthesis</li>
<li>Default state transitions protect against unexpected conditions</li>
<li>Reset logic ensures consistent initialization</li>
</ul>
</li>
<li>
<p><strong>Trigger Signals</strong>:</p>
<ul>
<li>The <code>new_price</code> signal initiates data storage operations</li>
<li>The <code>mem_full</code> flag triggers the start of calculations</li>
<li>The <code>compute_enable</code> signal (derived from <code>mem_cnt == 14</code>) initiates both MA and RSI calculations</li>
<li>Internal state transitions provide sequential triggering</li>
</ul>
</li>
<li>
<p><strong>Completion Signaling</strong>:</p>
<ul>
<li>Each calculation module generates a <code>done</code> signal</li>
<li>These signals pulse for one clock cycle to indicate completion</li>
<li>Downstream modules use these signals for synchronization</li>
<li>The combination of done signals can indicate system-wide completion</li>
<li>Done signals are registered to ensure clean transitions</li>
</ul>
</li>
<li>
<p><strong>Status Flags</strong>:</p>
<ul>
<li>The <code>mem_full</code> flag indicates sufficient data for calculation</li>
<li>The <code>mem_cnt</code> value tracks the current data depth</li>
<li>Individual module states provide status information</li>
<li>Error conditions (if implemented) are signaled through dedicated flags</li>
<li>These flags enable conditional operation based on system state</li>
</ul>
</li>
<li>
<p><strong>Flow Control Patterns</strong>:</p>
<ul>
<li><strong>Sequential Operation</strong>: Each module follows a defined sequence of steps</li>
<li><strong>Parallel Processing</strong>: Multiple indicators calculate simultaneously</li>
<li><strong>Conditional Execution</strong>: Operations proceed based on data availability</li>
<li><strong>Completion Acknowledgment</strong>: Done signals mark operation boundaries</li>
<li><strong>State-Based Gating</strong>: Actions are enabled only in appropriate states</li>
</ul>
</li>
</ol>
<p>The primary control flows in the system include:</p>
<ol>
<li>
<p><strong>Price Data Acquisition Flow</strong>:</p>
<pre class="hljs"><code><div>new_price  write_enable  memory update  memory_full flag  calculation trigger
</div></code></pre>
</li>
<li>
<p><strong>Moving Average Calculation Flow</strong>:</p>
<pre class="hljs"><code><div>start  state transition  sum update  division  done signaling  return to idle
</div></code></pre>
</li>
<li>
<p><strong>RSI Calculation Flow</strong>:</p>
<pre class="hljs"><code><div>new_price_strobe  FIFO fill  price comparison  gain/loss accumulation  RSI calculation  done signaling
</div></code></pre>
</li>
<li>
<p><strong>Trading Decision Flow</strong>:</p>
<pre class="hljs"><code><div>indicator updates  condition evaluation  signal generation
</div></code></pre>
</li>
</ol>
<p>These flows are coordinated through a combination of direct control signals and shared system state, ensuring that:</p>
<ul>
<li>Operations occur in the correct sequence</li>
<li>Data dependencies are respected</li>
<li>Calculations use valid input data</li>
<li>Outputs are only considered valid when explicitly indicated</li>
<li>The system maintains a predictable operational pattern</li>
</ul>
<p>The FSM-based approach provides several advantages:</p>
<ul>
<li>Clear operational phases with defined boundaries</li>
<li>Explicit control over transition conditions</li>
<li>Ability to insert wait states if needed</li>
<li>Easy extension with additional states</li>
<li>Straightforward debugging and verification</li>
</ul>
<p>This control flow management strategy creates a deterministic system behavior that can be readily verified and integrated into larger trading platforms, with predictable timing relationships and well-defined operational states.</p>
<h3 id="interface-specifications">Interface Specifications</h3>
<p>The technical analysis system implements clearly defined interfaces for each module, ensuring proper integration, standardized communication, and maintainable code. These interface specifications define the signals, timing relationships, and protocols for interaction between components and with external systems.</p>
<h4 id="1-top-level-system-interface">1. Top-Level System Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_system_singlemem (
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,            <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,            <span class="hljs-comment">// Asynchronous reset (active high)</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_in,       <span class="hljs-comment">// New price data input</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        new_price,      <span class="hljs-comment">// Signal indicating valid new price</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,     <span class="hljs-comment">// Calculated moving average</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,            <span class="hljs-comment">// Calculated RSI value</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        buy,            <span class="hljs-comment">// Buy signal output</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        sell,           <span class="hljs-comment">// Sell signal output</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        mem_full,       <span class="hljs-comment">// Memory full status flag</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]  mem_cnt,        <span class="hljs-comment">// Memory fill count</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] oldest_price,   <span class="hljs-comment">// Oldest price in memory</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        ma_done,        <span class="hljs-comment">// MA calculation complete</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        rsi_done        <span class="hljs-comment">// RSI calculation complete</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>clk</code>: All operations synchronize to the rising edge</li>
<li><code>rst</code>: Active high, asynchronous assertion, synchronous de-assertion</li>
<li><code>price_in</code>: Sampled when <code>new_price</code> is high</li>
<li><code>new_price</code>: Held high for one clock cycle per new price</li>
<li><code>buy</code>/<code>sell</code>: Mutually exclusive signals, registered outputs</li>
<li>Status signals (<code>mem_full</code>, <code>ma_done</code>, <code>rsi_done</code>): Indicate internal state</li>
</ul>
<h4 id="2-price-memory-interface">2. Price Memory Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,    <span class="hljs-comment">// Depth of the FIFO</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>        <span class="hljs-comment">// Data width</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,                <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,                <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> wr_en,              <span class="hljs-comment">// Write enable</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price, <span class="hljs-comment">// New price input</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Oldest price</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> full,              <span class="hljs-comment">// FIFO full flag</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count        <span class="hljs-comment">// FIFO count</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>wr_en</code>: Asserted for one clock cycle to write data</li>
<li><code>new_price</code>: Valid when <code>wr_en</code> is high</li>
<li><code>oldest_price</code>: Valid continuously once FIFO has data</li>
<li><code>full</code>: Asserted when count reaches DEPTH</li>
<li><code>count</code>: Indicates number of valid entries in FIFO</li>
</ul>
<h4 id="3-moving-average-fsm-interface">3. Moving Average FSM Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,                <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,                <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start,              <span class="hljs-comment">// Start calculation</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price, <span class="hljs-comment">// New price</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Oldest price</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,  <span class="hljs-comment">// Calculated moving average</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done                <span class="hljs-comment">// Calculation complete</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>start</code>: Triggers calculation when asserted for one cycle</li>
<li><code>new_price</code>/<code>oldest_price</code>: Must be valid when <code>start</code> is asserted</li>
<li><code>moving_avg</code>: Updated after calculation, valid when <code>done</code> is high</li>
<li><code>done</code>: Pulses high for one cycle when calculation completes</li>
</ul>
<h4 id="4-rsi-calculator-interface">4. RSI Calculator Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> rsi_inc #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,                 <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,                 <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_price_strobe,    <span class="hljs-comment">// New price available</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,  <span class="hljs-comment">// New price data</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Oldest price data</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> mem_full,            <span class="hljs-comment">// Memory full flag</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] mem_count,     <span class="hljs-comment">// Memory count</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,           <span class="hljs-comment">// RSI output (0-100)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done                 <span class="hljs-comment">// Calculation complete</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>new_price_strobe</code>: Signals new price availability</li>
<li><code>new_price</code>/<code>oldest_price</code>: Valid when <code>new_price_strobe</code> is high</li>
<li><code>mem_full</code>/<code>mem_count</code>: Indicate data availability status</li>
<li><code>rsi</code>: Valid when calculation completes, range 0-100</li>
<li><code>done</code>: Pulses high for one cycle when calculation completes</li>
</ul>
<h4 id="5-trading-decision-interface">5. Trading Decision Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR = <span class="hljs-number">8&#x27;d30</span>,  <span class="hljs-comment">// RSI buy threshold</span>
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>  <span class="hljs-comment">// RSI sell threshold</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,                 <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,                 <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_now,    <span class="hljs-comment">// Current price</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,   <span class="hljs-comment">// Moving average value</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,           <span class="hljs-comment">// RSI value</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,                 <span class="hljs-comment">// Buy signal</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell                 <span class="hljs-comment">// Sell signal</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>price_now</code>: Current price value, updated continuously</li>
<li><code>moving_avg</code>/<code>rsi</code>: Indicator values, updated after calculations</li>
<li><code>buy</code>/<code>sell</code>: Registered outputs, mutually exclusive</li>
</ul>
<h4 id="common-interface-characteristics">Common Interface Characteristics</h4>
<p>All module interfaces share these common characteristics:</p>
<ul>
<li><strong>Clock and Reset</strong>: Every module includes clock and reset signals</li>
<li><strong>Parameterization</strong>: Key values are parameterized for flexibility</li>
<li><strong>Registered Outputs</strong>: All outputs are registered for clean timing</li>
<li><strong>Clear Direction</strong>: All signals have explicit direction (input/output)</li>
<li><strong>Width Specification</strong>: All multi-bit signals have explicit width</li>
<li><strong>Status Signals</strong>: Appropriate flags indicate internal state</li>
</ul>
<p>These interface specifications ensure:</p>
<ul>
<li>Clear boundaries between modules</li>
<li>Consistent signal naming and usage</li>
<li>Proper timing relationships</li>
<li>Flexible configuration through parameters</li>
<li>Straightforward integration into larger systems</li>
<li>Ease of verification and testing</li>
</ul>
<p>The standardized interface approach facilitates both independent module development and system integration, creating a robust foundation for the technical analysis system.</p>
<h3 id="system-integration-principles">System Integration Principles</h3>
<p>The technical analysis system implements a set of system integration principles that ensure coherent operation of all components, maintainable architecture, and extensibility for future enhancements. These principles guide the connection and interaction of modules to create a unified system with predictable behavior.</p>
<p>Key system integration principles include:</p>
<ol>
<li>
<p><strong>Hierarchical Integration Structure</strong>:</p>
<ul>
<li>The <code>trading_system_singlemem</code> module serves as the top-level integration point</li>
<li>Individual functional modules are instantiated within this top level</li>
<li>Signals are explicitly connected between modules</li>
<li>Parameters are propagated from top level to components</li>
<li>Interface consistency is maintained across levels</li>
</ul>
</li>
<li>
<p><strong>Signal Naming Conventions</strong>:</p>
<ul>
<li>Consistent naming across module boundaries</li>
<li>Signal names reflect functionality</li>
<li>Prefixes or suffixes indicate signal role</li>
<li>Width included in multi-bit signal names where appropriate</li>
<li>Clear distinction between control, data, and status signals</li>
</ul>
</li>
<li>
<p><strong>Parameter Propagation</strong>:</p>
<ul>
<li>System-level parameters are passed to individual modules</li>
<li>Default parameter values provide sensible behavior if not overridden</li>
<li>Parameter consistency is maintained across related modules</li>
<li>Documentation clarifies parameter relationships</li>
<li>Parameters control behavior without code changes</li>
</ul>
</li>
<li>
<p><strong>Clock and Reset Distribution</strong>:</p>
<ul>
<li>Single clock domain for all modules</li>
<li>Common reset signal with consistent polarity</li>
<li>Synchronous reset release for stability</li>
<li>Defined reset state for all registers</li>
<li>Clean reset paths for all modules</li>
</ul>
</li>
<li>
<p><strong>Control Signal Management</strong>:</p>
<ul>
<li>Clear trigger signals for operations</li>
<li>Explicit completion signaling</li>
<li>Status flags for system state monitoring</li>
<li>Avoidance of complex handshaking where possible</li>
<li>State-based control rather than complex sequencing</li>
</ul>
</li>
<li>
<p><strong>Resource Sharing Strategy</strong>:</p>
<ul>
<li>Common price memory for all indicator calculations</li>
<li>Direct fanout to multiple calculation modules</li>
<li>Independent calculation engines for parallel processing</li>
<li>Shared input and output paths</li>
<li>Minimization of redundant storage</li>
</ul>
</li>
<li>
<p><strong>Interface Consistency</strong>:</p>
<ul>
<li>Standardized port ordering (clock, reset, controls, data, status)</li>
<li>Consistent signal widths for common functions</li>
<li>Standard timing relationships (one-cycle pulses for triggers)</li>
<li>Common protocol for calculation initiation and completion</li>
<li>Clear distinction between inputs and outputs</li>
</ul>
</li>
<li>
<p><strong>Timing Relationship Management</strong>:</p>
<ul>
<li>Defined latency for all operations</li>
<li>Synchronization points at module boundaries</li>
<li>Avoidance of combinational loops</li>
<li>Registered outputs for clean timing</li>
<li>Predictable cycle counts for operations</li>
</ul>
</li>
<li>
<p><strong>Extensibility Approaches</strong>:</p>
<ul>
<li>Modular design for addition of new indicators</li>
<li>Parameterized components for configuration flexibility</li>
<li>Clear interface definitions for future integration</li>
<li>Consistent control structure for new modules</li>
<li>Documentation of integration points</li>
</ul>
</li>
</ol>
<p>The system integration is implemented in the top-level module:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_system_singlemem (
    <span class="hljs-comment">// Port list...</span>
);
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count;

    <span class="hljs-comment">// Price memory instance</span>
    price_memory mem14 (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.wr_en</span>(new_price),
        <span class="hljs-variable">.new_price</span>(price_in),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.full</span>(mem_full),
        <span class="hljs-variable">.count</span>(count)
    );

    <span class="hljs-keyword">assign</span> mem_cnt = count;

    <span class="hljs-comment">// Trigger MA and RSI only after memory is full</span>
    <span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

    <span class="hljs-comment">// Moving Average FSM</span>
    moving_average_fsm ma14 (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.start</span>(compute_enable),
        <span class="hljs-variable">.new_price</span>(price_in),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.moving_avg</span>(moving_avg),
        <span class="hljs-variable">.done</span>(ma_done)
    );

    <span class="hljs-comment">// RSI Incremental FSM</span>
    rsi_inc rsi14 (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
        <span class="hljs-variable">.new_price</span>(price_in),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.mem_full</span>(mem_full),
        <span class="hljs-variable">.mem_count</span>(mem_cnt),
        <span class="hljs-variable">.rsi</span>(rsi),
        <span class="hljs-variable">.done</span>(rsi_done)
    );

    <span class="hljs-comment">// Trading decision logic</span>
    trading_decision dec (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.price_now</span>(price_in),
        <span class="hljs-variable">.moving_avg</span>(moving_avg),
        <span class="hljs-variable">.rsi</span>(rsi),
        <span class="hljs-variable">.buy</span>(buy),
        <span class="hljs-variable">.sell</span>(sell)
    );
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>These integration principles enable:</p>
<ul>
<li>Coherent system behavior</li>
<li>Clear signal flow and control</li>
<li>Maintainable architecture</li>
<li>Testable implementation</li>
<li>Extensible design</li>
<li>Predictable timing</li>
<li>Efficient resource utilization</li>
</ul>
<p>By adhering to these principles, the technical analysis system achieves a robust integration that balances performance, clarity, and flexibility, creating a solid foundation for trading applications.</p>
<h2 id="4-technical-indicators-implementation">4. Technical Indicators Implementation</h2>
<h3 id="moving-average-implementation">Moving Average Implementation</h3>
<h4 id="principles-and-theory">Principles and Theory</h4>
<p>The Simple Moving Average (SMA) is one of the most fundamental and widely used technical indicators in financial analysis. It provides a smoothed price curve by calculating the arithmetic mean of prices over a specific number of periods, helping traders identify trends by filtering out short-term price fluctuations.</p>
<p>The mathematical definition of an n-period Simple Moving Average is:</p>
<p>$$ SMA(n) = \frac{P_1 + P_2 + ... + P_n}{n} $$</p>
<p>Where:</p>
<ul>
<li>$P_1, P_2, ..., P_n$ are the price values over n periods</li>
<li>$n$ is the number of periods (window size)</li>
</ul>
<p>The SMA has several important properties that influence its implementation:</p>
<ol>
<li>
<p><strong>Equal Weighting</strong>: All prices within the window receive equal weight in the calculation, unlike exponential or weighted moving averages that assign higher weights to more recent prices.</p>
</li>
<li>
<p><strong>Lag Characteristic</strong>: The SMA tends to lag behind price movements, with the lag increasing with the window size. This is because historical prices have the same influence as current prices in the calculation.</p>
</li>
<li>
<p><strong>Smoothing Effect</strong>: Larger window sizes produce smoother curves that filter out more short-term fluctuations but increase lag.</p>
</li>
<li>
<p><strong>Trend Indication</strong>: The slope of the SMA line indicates the direction of the trend:</p>
<ul>
<li>Rising SMA suggests an uptrend</li>
<li>Falling SMA suggests a downtrend</li>
<li>Flat SMA suggests a sideways market</li>
</ul>
</li>
<li>
<p><strong>Support/Resistance Function</strong>: SMA can act as dynamic support in uptrends or resistance in downtrends, with commonly used periods (like 20, 50, or 200) often serving as significant levels.</p>
</li>
</ol>
<p>In trading applications, the SMA is typically used for:</p>
<ul>
<li>Trend identification (direction and strength)</li>
<li>Signal generation through price/MA crossovers</li>
<li>Support/resistance level identification</li>
<li>Multiple MA crossover strategies (e.g., golden/death cross)</li>
<li>Component in more complex indicators (e.g., MACD, Bollinger Bands)</li>
</ul>
<p>The implementation challenge for FPGA-based systems is to calculate the SMA efficiently as new prices arrive, minimizing both computational complexity and memory requirements while maintaining accuracy. The sliding window algorithm addresses this challenge by incrementally updating the sum rather than recalculating it for each new price.</p>
<h4 id="implementation-algorithm">Implementation Algorithm</h4>
<p>The moving average implementation uses an efficient sliding window algorithm with O(1) computational complexity per update. This approach maintains a running sum of prices in the window, updating it incrementally as new prices arrive and old prices leave the window, rather than recalculating the entire sum for each new price.</p>
<p>The core algorithm can be described as:</p>
<ol>
<li>Initialize a sum to hold the total of all prices in the window</li>
<li>When a new price arrives:
<ul>
<li>Add the new price to the sum</li>
<li>Subtract the oldest price from the sum</li>
<li>Calculate the average by dividing the sum by the window size</li>
</ul>
</li>
<li>Store the new price in the circular buffer, replacing the oldest price</li>
</ol>
<p>This algorithm is implemented using a Finite State Machine (FSM) with three states:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        sum &lt;= <span class="hljs-number">0</span>; moving_avg &lt;= <span class="hljs-number">0</span>; done &lt;= <span class="hljs-number">0</span>; st &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (st)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
                sum &lt;= sum + new_price - oldest_price;
                moving_avg &lt;= sum / WINDOW;
                done &lt;= <span class="hljs-number">1</span>;
                st &lt;= <span class="hljs-number">2</span>;
            <span class="hljs-keyword">end</span>
            <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">0</span>;
                st &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Computational steps in detail:</p>
<ol>
<li>
<p><strong>State 0 (Idle)</strong>:</p>
<ul>
<li>Wait for the <code>start</code> signal</li>
<li>When <code>start</code> is asserted, transition to State 1</li>
</ul>
</li>
<li>
<p><strong>State 1 (Calculate)</strong>:</p>
<ul>
<li>Update the running sum: <code>sum &lt;= sum + new_price - oldest_price</code></li>
<li>Calculate the moving average: <code>moving_avg &lt;= sum / WINDOW</code></li>
<li>Assert the done flag: <code>done &lt;= 1</code></li>
<li>Transition to State 2</li>
</ul>
</li>
<li>
<p><strong>State 2 (Complete)</strong>:</p>
<ul>
<li>De-assert the done flag: <code>done &lt;= 0</code></li>
<li>Return to the idle state: <code>st &lt;= 0</code></li>
</ul>
</li>
</ol>
<p>This algorithm has several key advantages:</p>
<ol>
<li>
<p><strong>Computational Efficiency</strong>: Only three operations are required per update:</p>
<ul>
<li>One addition (new price to sum)</li>
<li>One subtraction (oldest price from sum)</li>
<li>One division (sum by window size)</li>
</ul>
</li>
<li>
<p><strong>Constant Time Complexity</strong>: The calculation time remains constant regardless of window size, making it O(1) instead of the O(n) complexity of a naive implementation.</p>
</li>
<li>
<p><strong>Memory Efficiency</strong>: Only the running sum needs to be maintained, rather than all individual prices (which are already stored in the price memory).</p>
</li>
<li>
<p><strong>Deterministic Timing</strong>: The calculation completes in a fixed number of clock cycles, providing predictable performance.</p>
</li>
</ol>
<p>The implementation includes careful consideration of numeric precision:</p>
<ul>
<li>The <code>sum</code> register is 64 bits to prevent overflow when accumulating prices</li>
<li>The <code>moving_avg</code> output is 32 bits to accommodate the division result</li>
<li>The division operation is integer division, with potential enhancements for fixed-point implementation</li>
</ul>
<p>This sliding window algorithm enables efficient calculation of the moving average with minimal latency and resource utilization, making it ideal for FPGA implementation in trading systems.</p>
<h4 id="optimization-techniques">Optimization Techniques</h4>
<p>The moving average implementation incorporates several key optimization techniques to enhance performance, minimize resource utilization, and ensure accuracy:</p>
<ol>
<li>
<p><strong>Sliding Window Approach</strong>:</p>
<ul>
<li>The O(1) complexity algorithm is a fundamental optimization</li>
<li>Eliminates the need to recalculate the entire sum for each update</li>
<li>Particularly valuable for larger window sizes</li>
<li>Reduces computational load dramatically</li>
<li>Ensures consistent performance regardless of window size</li>
</ul>
</li>
<li>
<p><strong>Extended Precision for Sum</strong>:</p>
<ul>
<li>64-bit register for the sum provides substantial headroom</li>
<li>Prevents overflow even with large price values and window sizes</li>
<li>Example: With 16-bit prices and a 20-period window:
<ul>
<li>Maximum possible sum: 20 * (2^16 - 1)  1.3 million</li>
<li>64-bit sum register provides ample margin (up to 2^64  18.4 quintillion)</li>
</ul>
</li>
<li>This eliminates the need for complex overflow handling</li>
</ul>
</li>
<li>
<p><strong>Minimal State Machine</strong>:</p>
<ul>
<li>Three-state FSM provides clean control flow with minimal overhead</li>
<li>State encoding optimized for efficiency (2 bits for 3 states)</li>
<li>Linear state progression simplifies logic and timing</li>
<li>Reset state is clearly defined for reliability</li>
<li>Limited state transitions improve predictability</li>
</ul>
</li>
<li>
<p><strong>Register Sizing Optimization</strong>:</p>
<ul>
<li>Each register sized appropriately for its purpose:
<ul>
<li>64-bit sum: Prevents overflow during accumulation</li>
<li>32-bit moving_avg: Accommodates division results</li>
<li>2-bit state register: Minimal size for three states</li>
</ul>
</li>
<li>This balances precision requirements with resource utilization</li>
</ul>
</li>
<li>
<p><strong>Single-Cycle State Transitions</strong>:</p>
<ul>
<li>Each state completes its operations in a single clock cycle</li>
<li>No multi-cycle operations or complex sequencing</li>
<li>Simplifies timing analysis and improves determinism</li>
<li>Enables maximum throughput of one update per cycle</li>
<li>Consistent latency for all calculations</li>
</ul>
</li>
<li>
<p><strong>Efficient Division Implementation</strong>:</p>
<ul>
<li>Integer division by a constant (WINDOW)</li>
<li>Division by powers of 2 can be optimized to shift operations</li>
<li>For arbitrary divisors, synthesis tools can optimize division</li>
<li>Potential for further optimization with fixed-point arithmetic</li>
</ul>
</li>
<li>
<p><strong>Clear Completion Signaling</strong>:</p>
<ul>
<li>The <code>done</code> signal provides clean synchronization</li>
<li>Single-cycle pulse simplifies downstream logic</li>
<li>Consistent protocol for all calculation modules</li>
<li>Eliminates need for complex handshaking</li>
<li>Enables easy integration with other components</li>
</ul>
</li>
<li>
<p><strong>Direct Memory Integration</strong>:</p>
<ul>
<li>Direct connection to price memory for data access</li>
<li>No intermediate buffers or staging registers</li>
<li>Immediate utilization of new and oldest prices</li>
<li>Clean data path from memory to calculation</li>
<li>Minimized latency from data availability to calculation</li>
</ul>
</li>
<li>
<p><strong>Parameter-Based Configuration</strong>:</p>
<ul>
<li>Window size (WINDOW) and data width (DW) are parameterized</li>
<li>Enables compile-time optimization for specific applications</li>
<li>No runtime overhead for configuration</li>
<li>Maintains clean implementation with flexibility</li>
<li>Simplifies adaptation for different markets or strategies</li>
</ul>
</li>
</ol>
<p>These optimization techniques combine to create an efficient, deterministic, and resource-conscious implementation of the moving average calculation, well-suited for FPGA deployment in high-performance trading systems.</p>
<h4 id="parameter-configuration">Parameter Configuration</h4>
<p>The moving average module is designed for flexibility through parameterization, allowing adaptation to different trading strategies, market characteristics, and precision requirements without code changes. This approach enables compile-time optimization while maintaining a clean and consistent implementation.</p>
<p>The module defines two primary parameters:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW     = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<p><strong>Window Size Parameter (WINDOW)</strong>:</p>
<ul>
<li>Default value: 20 periods</li>
<li>Defines the number of price points included in the moving average</li>
<li>Directly affects the smoothing characteristic of the indicator</li>
<li>Influences the lag between price movements and MA response</li>
<li>Typical values in trading applications:
<ul>
<li>5-10: Very short-term trend identification (intraday)</li>
<li>20: Short-term trend identification (days to weeks)</li>
<li>50: Medium-term trend identification (weeks to months)</li>
<li>200: Long-term trend identification (months to years)</li>
</ul>
</li>
</ul>
<p>The window size selection involves a tradeoff between responsiveness and noise filtering:</p>
<ul>
<li>Smaller windows: More responsive to price changes but more susceptible to market noise</li>
<li>Larger windows: Better filtering of noise but increased lag</li>
</ul>
<p><strong>Data Width Parameter (DW)</strong>:</p>
<ul>
<li>Default value: 16 bits</li>
<li>Defines the bit width of price inputs</li>
<li>Affects the range of price values that can be represented</li>
<li>Determines precision for fixed-point implementations</li>
<li>Typical values:
<ul>
<li>16 bits: Standard width for integer prices (0-65,535 range)</li>
<li>24 bits: Extended range for high-value instruments</li>
<li>32 bits: Maximum precision for fixed-point representation</li>
</ul>
</li>
</ul>
<p>The data width selection depends on the instrument characteristics and precision requirements:</p>
<ul>
<li>Typical stock prices: 16 bits sufficient</li>
<li>High-value instruments (e.g., BTC): May require wider representation</li>
<li>Fixed-point implementations: Width determined by integer and fractional requirements</li>
</ul>
<p><strong>Parameter Propagation</strong>:
Parameters are typically configured at the top level and propagated through the hierarchy:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Top-level instantiation with parameter overrides</span>
moving_average_fsm #(
    <span class="hljs-variable">.WINDOW</span>(<span class="hljs-number">50</span>),         <span class="hljs-comment">// 50-period MA for medium-term trend</span>
    <span class="hljs-variable">.DW</span>(<span class="hljs-number">24</span>)              <span class="hljs-comment">// 24-bit price width for extended range</span>
) ma_module (
    <span class="hljs-comment">// Port connections...</span>
);
</div></code></pre>
<p><strong>Impact of Parameter Changes</strong>:</p>
<ol>
<li>
<p><strong>Window Size Impact</strong>:</p>
<ul>
<li>Memory requirements in the price memory module</li>
<li>Division factor in the moving average calculation</li>
<li>Smoothing characteristics of the resulting indicator</li>
<li>Lag characteristics in trend identification</li>
<li>Effectiveness for different market conditions</li>
</ul>
</li>
<li>
<p><strong>Data Width Impact</strong>:</p>
<ul>
<li>Memory requirements for price storage</li>
<li>Sum register width requirements</li>
<li>Division operation precision</li>
<li>Range of representable price values</li>
<li>Resource utilization across the system</li>
</ul>
</li>
</ol>
<p><strong>Configuration Guidelines</strong>:</p>
<ol>
<li>
<p><strong>Market-Based Selection</strong>:</p>
<ul>
<li>Volatile markets: Smaller windows to reduce lag</li>
<li>Stable markets: Larger windows for better filtering</li>
<li>High-value instruments: Wider data width</li>
<li>Decimal price representation: Consider fixed-point implementation</li>
</ul>
</li>
<li>
<p><strong>Strategy-Based Selection</strong>:</p>
<ul>
<li>Trend following: Larger windows (20-50)</li>
<li>Mean reversion: Multiple windows for crossovers</li>
<li>Scalping: Smaller windows (5-10)</li>
<li>Position trading: Larger windows (50-200)</li>
</ul>
</li>
<li>
<p><strong>Resource Consideration</strong>:</p>
<ul>
<li>Larger windows increase memory requirements</li>
<li>Wider data width increases register and logic utilization</li>
<li>Complex division implementations impact DSP usage</li>
<li>Multiple indicator instances multiply resource requirements</li>
</ul>
</li>
</ol>
<p>The parameterized design enables optimization for specific applications while maintaining a consistent implementation, facilitating both customization and maintainability of the moving average module.</p>
<h4 id="fsm-design-details">FSM Design Details</h4>
<p>The Moving Average FSM implements a streamlined state machine design that controls the calculation process with clear states, deterministic transitions, and efficient operation. This approach provides a robust control mechanism that ensures proper sequencing and timing of the moving average calculation.</p>
<p>The FSM is implemented using a 2-bit state register with three distinct states:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] st = <span class="hljs-number">0</span>;  <span class="hljs-comment">// State register initialized to IDLE</span>

<span class="hljs-comment">// State definitions (implicit encoding)</span>
<span class="hljs-comment">// State 0: IDLE - Waiting for start signal</span>
<span class="hljs-comment">// State 1: CALCULATE - Performing calculation</span>
<span class="hljs-comment">// State 2: DONE - Signaling completion</span>
</div></code></pre>
<p><strong>State 0: IDLE</strong></p>
<ul>
<li>The default state after reset</li>
<li>Waits for the <code>start</code> signal to begin calculation</li>
<li>Performs no operations while in this state</li>
<li>Remains in this state until explicitly triggered</li>
<li>Transition: IDLE  CALCULATE when <code>start</code> is asserted</li>
</ul>
<p><strong>State 1: CALCULATE</strong></p>
<ul>
<li>Performs the core moving average calculation</li>
<li>Updates the running sum by adding new price and subtracting oldest price</li>
<li>Calculates the moving average by dividing the sum by the window size</li>
<li>Sets the <code>done</code> flag to indicate calculation completion</li>
<li>Transition: CALCULATE  DONE automatically after one cycle</li>
</ul>
<p><strong>State 2: DONE</strong></p>
<ul>
<li>Maintains the calculated result</li>
<li>Clears the <code>done</code> flag to create a one-cycle pulse</li>
<li>Completes the calculation sequence</li>
<li>Prepares for the next calculation cycle</li>
<li>Transition: DONE  IDLE automatically after one cycle</li>
</ul>
<p>The complete FSM implementation:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        sum &lt;= <span class="hljs-number">0</span>; moving_avg &lt;= <span class="hljs-number">0</span>; done &lt;= <span class="hljs-number">0</span>; st &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (st)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
                sum &lt;= sum + new_price - oldest_price;
                moving_avg &lt;= sum / WINDOW;
                done &lt;= <span class="hljs-number">1</span>;
                st &lt;= <span class="hljs-number">2</span>;
            <span class="hljs-keyword">end</span>
            <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">0</span>;
                st &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>State Transition Diagram</strong>:</p>
<pre class="hljs"><code><div>        start        auto    
      IDLE    CALCULATE  DONE 
     (st=0)                 (st=1)               (st=2)
                             
                                                       
         
                               auto
</div></code></pre>
<p><strong>FSM Design Considerations</strong>:</p>
<ol>
<li>
<p><strong>State Encoding</strong>:</p>
<ul>
<li>Binary encoding (0, 1, 2) for simplicity</li>
<li>2-bit state register accommodates three states</li>
<li>Natural state progression follows binary counting</li>
<li>Minimal logic for next-state determination</li>
<li>Efficient synthesis to hardware</li>
</ul>
</li>
<li>
<p><strong>Reset Behavior</strong>:</p>
<ul>
<li>Asynchronous reset for immediate system initialization</li>
<li>All registers cleared to known states</li>
<li>State reset to IDLE (0)</li>
<li>Sum cleared to prevent incorrect calculations</li>
<li>Done flag cleared to avoid false signals</li>
</ul>
</li>
<li>
<p><strong>Transition Logic</strong>:</p>
<ul>
<li>Minimal conditions for state transitions</li>
<li>Single input (<code>start</code>) triggers calculation</li>
<li>Automatic progression through calculation states</li>
<li>Complete calculation cycle: 3 clock cycles</li>
<li>Clean return to idle state for next operation</li>
</ul>
</li>
<li>
<p><strong>Output Generation</strong>:</p>
<ul>
<li><code>done</code> signal pulsed for exactly one clock cycle</li>
<li><code>moving_avg</code> updated in the CALCULATE state</li>
<li>Registered outputs for clean timing</li>
<li>Output valid when <code>done</code> is asserted</li>
<li>Stable outputs between calculations</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong>:</p>
<ul>
<li>Implicit handling of invalid states</li>
<li>Default transition to IDLE if in unexpected state</li>
<li>Clear initialization on reset</li>
<li>Predictable behavior under all conditions</li>
<li>No complex error recovery needed</li>
</ul>
</li>
<li>
<p><strong>Performance Optimization</strong>:</p>
<ul>
<li>Single-cycle state transitions</li>
<li>Minimal states for required functionality</li>
<li>No wait states or complex sequencing</li>
<li>Direct calculation in a single state</li>
<li>Immediate result generation</li>
</ul>
</li>
</ol>
<p>This streamlined FSM design creates a clean control flow for the moving average calculation, ensuring reliable operation with deterministic timing and minimal resource utilization. The simplicity of the state machine contributes to the overall efficiency and robustness of the moving average implementation.</p>
<h4 id="precision-considerations">Precision Considerations</h4>
<p>The moving average implementation incorporates several precision considerations to ensure accurate calculations while optimizing resource utilization. These considerations address the challenges of representing financial data, preventing overflow, and managing division operations in hardware.</p>
<ol>
<li>
<p><strong>Register Width Selection</strong>:</p>
<ul>
<li>
<p><strong>Sum Register (64-bit)</strong>:</p>
<ul>
<li>Accumulates price values for the moving average calculation</li>
<li>Extended width prevents overflow during accumulation</li>
<li>For n-bit prices and a window of size W:
<ul>
<li>Theoretical maximum sum: W * (2^n - 1)</li>
<li>With 16-bit prices and a 20-period window:
<ul>
<li>Max sum  20 * 65,535  1.3 million</li>
<li>64-bit register provides ample margin (up to 2^64  18.4 quintillion)</li>
</ul>
</li>
</ul>
</li>
<li>Wider than necessary for most applications, but eliminates overflow concerns</li>
</ul>
</li>
<li>
<p><strong>Moving Average Output (32-bit)</strong>:</p>
<ul>
<li>Stores the result of dividing sum by window size</li>
<li>For 16-bit prices, the average cannot exceed the maximum price value (2^16 - 1)</li>
<li>32-bit width provides room for future extension to fixed-point representation</li>
<li>Compatible with standard data bus widths in FPGA architectures</li>
<li>Balances precision with resource utilization</li>
</ul>
</li>
<li>
<p><strong>State Register (2-bit)</strong>:</p>
<ul>
<li>Encodes three states: IDLE (0), CALCULATE (1), and DONE (2)</li>
<li>Minimal width reduces register resource requirements</li>
<li>Provides one additional state value for potential extension</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Division Implementation</strong>:</p>
<ul>
<li>
<p>The moving average calculation requires division by the window size:</p>
<pre class="hljs"><code><div>moving_avg &lt;= sum / WINDOW;
</div></code></pre>
</li>
<li>
<p><strong>Integer Division Characteristics</strong>:</p>
<ul>
<li>Truncates fractional results (rounds toward zero)</li>
<li>Precision loss increases with larger divisors</li>
<li>For price data, this is typically acceptable</li>
<li>Division by a constant is optimized during synthesis</li>
</ul>
</li>
<li>
<p><strong>Optimization for Powers of 2</strong>:</p>
<ul>
<li>When WINDOW is a power of 2 (e.g., 16, 32), division becomes a shift operation:<pre class="hljs"><code><div><span class="hljs-comment">// Optimized implementation for WINDOW = 16</span>
moving_avg &lt;= sum &gt;&gt; <span class="hljs-number">4</span>;  <span class="hljs-comment">// Shift right by 4 bits (divide by 16)</span>
</div></code></pre>
</li>
<li>Significantly more efficient in hardware</li>
<li>Reduces both resource utilization and latency</li>
<li>Many trading applications use power-of-2 window sizes for this reason</li>
</ul>
</li>
<li>
<p><strong>Fixed-Point Considerations</strong>:</p>
<ul>
<li>For applications requiring decimal precision:<pre class="hljs"><code><div><span class="hljs-comment">// Fixed-point division with 8 fractional bits</span>
moving_avg &lt;= (sum &lt;&lt; <span class="hljs-number">8</span>) / WINDOW;  <span class="hljs-comment">// Scale up before division</span>
</div></code></pre>
</li>
<li>Maintains fractional precision through scaling</li>
<li>Requires appropriate interpretation of the result</li>
<li>Increases register width requirements</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Accumulation Error Management</strong>:</p>
<ul>
<li>The sliding window algorithm can accumulate rounding errors over time</li>
<li><strong>Potential Mitigation Strategies</strong>:
<ul>
<li>Periodic recalculation of the complete sum</li>
<li>Extended precision for intermediate calculations</li>
<li>Careful monitoring of error bounds</li>
<li>Fixed-point arithmetic for critical applications</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Overflow Prevention</strong>:</p>
<ul>
<li>The extended sum register prevents overflow in normal operation</li>
<li>For extreme market conditions or very large window sizes:
<ul>
<li>Saturation logic could be added</li>
<li>Overflow detection and handling</li>
<li>Error signaling for diagnostic purposes</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Implementation Tradeoffs</strong>:</p>
<ul>
<li>
<p><strong>Precision vs. Resources</strong>:</p>
<ul>
<li>Wider registers improve precision but increase resource usage</li>
<li>Fixed-point arithmetic enhances precision but adds complexity</li>
<li>Integer division simplifies implementation but limits precision</li>
</ul>
</li>
<li>
<p><strong>Latency vs. Accuracy</strong>:</p>
<ul>
<li>More complex division methods improve accuracy but increase latency</li>
<li>Multi-cycle division can improve resource utilization at the cost of throughput</li>
<li>Approximation methods can reduce latency but introduce error</li>
</ul>
</li>
<li>
<p><strong>Generality vs. Optimization</strong>:</p>
<ul>
<li>Parameterized implementation provides flexibility but may not optimize for specific cases</li>
<li>Hard-coded window sizes allow specific optimizations</li>
<li>Application-specific customization may be warranted for critical systems</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The current implementation balances these considerations with a focus on reliability, deterministic behavior, and sufficient precision for most trading applications, while leaving room for application-specific optimization when needed.</p>
<h3 id="rsi-implementation">RSI Implementation</h3>
<h4 id="rsi-theory-and-calculation">RSI Theory and Calculation</h4>
<p>The Relative Strength Index (RSI) is a momentum oscillator developed by J. Welles Wilder in 1978 that measures the speed and magnitude of price movements. It oscillates between 0 and 100, with readings above 70 typically considered overbought and readings below 30 considered oversold. The RSI is widely used to identify potential reversal points, momentum changes, and divergence between price and momentum.</p>
<p><strong>Mathematical Foundation</strong>:</p>
<p>The RSI is calculated using the ratio of average gains to average losses over a specified period:</p>
<p>$$RSI = 100 - \frac{100}{1 + RS}$$</p>
<p>Where RS (Relative Strength) is:</p>
<p>$$RS = \frac{Average:Gain}{Average:Loss}$$</p>
<p>This can be alternatively expressed as:</p>
<p>$$RSI = 100 \times \frac{Average:Gain}{Average:Gain + Average:Loss}$$</p>
<p>The calculation involves several steps:</p>
<ol>
<li>
<p><strong>Calculate Price Changes</strong>:</p>
<ul>
<li>For each period, determine if there was a gain (positive change) or loss (negative change)</li>
<li>Gain = Current Price - Previous Price (if positive, otherwise 0)</li>
<li>Loss = Previous Price - Current Price (if positive, otherwise 0)</li>
</ul>
</li>
<li>
<p><strong>Calculate Average Gain and Loss</strong>:</p>
<ul>
<li>For the first calculation (when no previous average exists):
<ul>
<li>Average Gain = Sum of Gains over the period / Period length</li>
<li>Average Loss = Sum of Losses over the period / Period length</li>
</ul>
</li>
<li>For subsequent calculations (using Wilder's smoothing method):
<ul>
<li>Average Gain = ((Previous Average Gain  (period-1)) + Current Gain) / period</li>
<li>Average Loss = ((Previous Average Loss  (period-1)) + Current Loss) / period</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Calculate RS and RSI</strong>:</p>
<ul>
<li>RS = Average Gain / Average Loss</li>
<li>RSI = 100 - (100 / (1 + RS)) or RSI = 100  (Average Gain / (Average Gain + Average Loss))</li>
</ul>
</li>
</ol>
<p><strong>Implementation Approaches</strong>:</p>
<p>There are two common methods for calculating RSI:</p>
<ol>
<li>
<p><strong>Simple Method (Used in this implementation)</strong>:</p>
<ul>
<li>Directly sum all gains and losses over the period</li>
<li>Calculate RSI using total gains and losses</li>
<li>Simpler to implement and requires less state</li>
<li>Works well for fixed-length windows</li>
</ul>
</li>
<li>
<p><strong>Wilder's Smoothing Method</strong>:</p>
<ul>
<li>Uses exponential smoothing of gains and losses</li>
<li>Maintains running averages that are updated incrementally</li>
<li>Produces smoother RSI values</li>
<li>Requires maintaining more state variables</li>
</ul>
</li>
</ol>
<p>The implemented RSI calculator uses the Simple Method with a default period of 14, which is the traditional period recommended by Wilder and widely used in technical analysis.</p>
<p><strong>Trading Applications of RSI</strong>:</p>
<ol>
<li>
<p><strong>Overbought/Oversold Conditions</strong>:</p>
<ul>
<li>RSI &gt; 70: Potentially overbought, may signal a selling opportunity</li>
<li>RSI &lt; 30: Potentially oversold, may signal a buying opportunity</li>
</ul>
</li>
<li>
<p><strong>Divergence Analysis</strong>:</p>
<ul>
<li>Bullish Divergence: Price makes a lower low but RSI makes a higher low</li>
<li>Bearish Divergence: Price makes a higher high but RSI makes a lower high</li>
</ul>
</li>
<li>
<p><strong>Centerline Crossovers</strong>:</p>
<ul>
<li>RSI crossing above 50: Potentially indicating increasing bullish momentum</li>
<li>RSI crossing below 50: Potentially indicating increasing bearish momentum</li>
</ul>
</li>
<li>
<p><strong>Failure Swings</strong>:</p>
<ul>
<li>Reversal signals that occur without crossing overbought/oversold thresholds</li>
</ul>
</li>
<li>
<p><strong>Support/Resistance Levels</strong>:</p>
<ul>
<li>RSI often respects support and resistance levels, even when not visible on price charts</li>
</ul>
</li>
</ol>
<p>The RSI implementation in this system focuses on efficiently calculating the indicator value while managing the computational challenges inherent in FPGA implementation, particularly around gain/loss accumulation and division operations.</p>
<h4 id="fsm-implementation-approach">FSM Implementation Approach</h4>
<p>The RSI implementation employs a sophisticated Finite State Machine (FSM) approach to manage the sequential process of calculating the Relative Strength Index. This state-based design provides a clear operational flow, ensures proper data handling, and creates a deterministic calculation process suitable for hardware implementation.</p>
<p>The RSI FSM implements a 6-state machine to control the calculation process:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">3&#x27;b000</span>,
           FILL_FIFO = <span class="hljs-number">3&#x27;b001</span>,
           READ_INIT = <span class="hljs-number">3&#x27;b010</span>,
           READ_WAIT = <span class="hljs-number">3&#x27;b011</span>,
           COMPARE   = <span class="hljs-number">3&#x27;b100</span>,
           DONE      = <span class="hljs-number">3&#x27;b101</span>;
</div></code></pre>
<p>Each state serves a specific purpose in the calculation sequence:</p>
<p>The FSM state transitions follow this pattern:</p>
<pre class="hljs"><code><div>                  
                       
        IDLE 
                               
                          
                                 
                                 
                        
                                
    FILL_FIFO                   
                                
                        
                                 
                                 
                       
                                
    READ_INIT                   
                                
                       
                                 
                                 
                
                              
    COMPARE  DONE 
                           
             
        
        
   
            
   READ_WAIT
               
      
                
         
</div></code></pre>
<p>This diagram shows how the states connect to form a complete calculation cycle, with the READ_WAIT and COMPARE states forming a loop that processes each price pair until all samples have been analyzed.</p>
<p>The 3-bit state encoding provides efficient implementation while accommodating all required states, with a clear distinction between operational phases.</p>
<p>The FSM implementation includes several key design considerations:</p>
<ol>
<li>
<p><strong>State Management</strong>:</p>
<ul>
<li>3-bit state register accommodates six distinct states</li>
<li>Clear state transitions based on well-defined conditions</li>
<li>Default state (IDLE) for initialization and between calculations</li>
<li>Linear progression through primary calculation phases</li>
<li>Cyclic pattern between COMPARE and READ_WAIT for sample processing</li>
</ul>
</li>
<li>
<p><strong>Resource Optimization</strong>:</p>
<ul>
<li>Minimal state register width (3 bits)</li>
<li>Efficient state encoding for synthesis</li>
<li>Single-cycle transitions where possible</li>
<li>Reuse of control signals across states</li>
<li>Balanced distribution of operations</li>
</ul>
</li>
<li>
<p><strong>Timing Management</strong>:</p>
<ul>
<li>One-cycle delay handling for FIFO operations</li>
<li>Explicit synchronization using the <code>read_delay</code> flag</li>
<li>Clear delineation between control and calculation phases</li>
<li>Predictable cycle count for complete calculation</li>
<li>Deterministic operation regardless of input data</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong>:</p>
<ul>
<li>Protection against division by zero in final calculation</li>
<li>Empty FIFO detection to prevent underflow</li>
<li>Counter-based sample tracking to prevent overprocessing</li>
<li>Clear reset behavior for system initialization</li>
<li>Default case for unexpected state values</li>
</ul>
</li>
<li>
<p><strong>Interface Considerations</strong>:</p>
<ul>
<li>Clean <code>done</code> signal generation for downstream synchronization</li>
<li>Clear relationship between input signals and state transitions</li>
<li>Consistent protocol for FIFO read/write operations</li>
<li>Well-defined completion signaling</li>
<li>Observable state for debugging and verification</li>
</ul>
</li>
</ol>
<p>This FSM approach creates a robust, deterministic framework for the RSI calculation process, ensuring reliable operation with predictable timing characteristics and clear operational phases.</p>
<h4 id="gainloss-accumulation">Gain/Loss Accumulation</h4>
<p>The RSI calculation fundamentally depends on accurately tracking price gains and losses over a specified period. The implementation uses an efficient approach to accumulate these values, enabling accurate RSI calculation with minimal computational overhead.</p>
<p>The gain/loss accumulation process occurs primarily in the READ_WAIT state, where consecutive prices are compared to determine price changes:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (price_out &gt; prev_price)
    gain_sum &lt;= gain_sum + (price_out - prev_price);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_out &lt; prev_price)
    loss_sum &lt;= loss_sum + (prev_price - price_out);
</div></code></pre>
<p>This approach implements several key features:</p>
<ol>
<li>
<p><strong>Direct Comparison Logic</strong>:</p>
<ul>
<li>Straightforward comparison between current and previous prices</li>
<li>Binary decision between gain and loss accumulation</li>
<li>No calculation when prices are equal</li>
<li>Absolute value approach for loss calculation</li>
<li>Integer precision for all comparisons</li>
</ul>
</li>
<li>
<p><strong>Accumulator Design</strong>:</p>
<ul>
<li>32-bit registers for both gain_sum and loss_sum</li>
<li>Initialized to zero at the start of each calculation cycle</li>
<li>Sequential accumulation as each price pair is processed</li>
<li>No normalization or averaging during accumulation</li>
<li>Sufficient width to prevent overflow for typical price ranges</li>
</ul>
</li>
<li>
<p><strong>Sequential Processing</strong>:</p>
<ul>
<li>Prices are processed in pairs as they are read from the FIFO</li>
<li>Each price becomes the &quot;previous price&quot; for the next comparison</li>
<li>Consistent ordering ensures correct gain/loss identification</li>
<li>Sample counter tracks progress through the price history</li>
<li>Complete processing of all available samples</li>
</ul>
</li>
<li>
<p><strong>Optimization Considerations</strong>:</p>
<ul>
<li>Only one comparison path is active per cycle (gain or loss)</li>
<li>Integer arithmetic for efficient implementation</li>
<li>Direct accumulation without intermediate storage</li>
<li>Single-cycle update for each price pair</li>
<li>No division operations during accumulation phase</li>
</ul>
</li>
<li>
<p><strong>Example Calculation Sequence</strong>:</p>
<p>For a sequence of prices [100, 98, 101, 99, 102]:</p>
<table>
<thead>
<tr>
<th>Cycle</th>
<th>prev_price</th>
<th>curr_price</th>
<th>Change</th>
<th>Action</th>
<th>gain_sum</th>
<th>loss_sum</th>
</tr>
</thead>
<tbody>
<tr>
<td>Init</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Initialize</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>100</td>
<td>98</td>
<td>-2</td>
<td>Add to loss</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>98</td>
<td>101</td>
<td>+3</td>
<td>Add to gain</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>101</td>
<td>99</td>
<td>-2</td>
<td>Add to loss</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>99</td>
<td>102</td>
<td>+3</td>
<td>Add to gain</td>
<td>6</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>This accumulation approach efficiently tracks the total gains and losses over the specified period, providing the necessary inputs for the final RSI calculation while maintaining accuracy and computational efficiency.</p>
<p>The accumulators are designed with sufficient width (32 bits) to handle typical price ranges and window sizes without overflow concerns, similar to the approach used in the moving average calculation but tailored to the specific requirements of RSI calculation.</p>
<h4 id="final-calculation-method">Final Calculation Method</h4>
<p>The RSI calculation culminates in the DONE state, where the accumulated gains and losses are used to compute the final RSI value according to the standard formula. This critical step implements the core mathematical relationship that defines the Relative Strength Index.</p>
<p>The final calculation is implemented as:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> ((gain_sum + loss_sum) &gt; <span class="hljs-number">0</span>)
    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
<span class="hljs-keyword">else</span>
    rsi &lt;= <span class="hljs-number">0</span>;
</div></code></pre>
<p>This implementation incorporates several important considerations:</p>
<ol>
<li>
<p><strong>Mathematical Foundation</strong>:</p>
<ul>
<li>Implements the formula RSI = 100  (Average Gain / (Average Gain + Average Loss))</li>
<li>Uses the accumulated sums directly without additional averaging</li>
<li>Calculation produces values in the standard 0-100 range</li>
<li>Consistent with traditional RSI interpretation (&gt;70 overbought, &lt;30 oversold)</li>
<li>Integer arithmetic provides sufficient precision for trading applications</li>
</ul>
</li>
<li>
<p><strong>Division Implementation</strong>:</p>
<ul>
<li>Integer division operation with 100 scaling factor</li>
<li>Division denominator is the sum of gains and losses</li>
<li>Numerator is the gain_sum scaled by 100</li>
<li>Result range is properly constrained to 0-100</li>
<li>Consistent with the 8-bit output representation</li>
</ul>
</li>
<li>
<p><strong>Special Case Handling</strong>:</p>
<ul>
<li>Explicit check for zero denominator: <code>(gain_sum + loss_sum) &gt; 0</code></li>
<li>Default value of 0 when no price changes have occurred</li>
<li>Protection against division by zero errors</li>
<li>Deterministic behavior for all input conditions</li>
<li>Graceful handling of edge cases</li>
</ul>
</li>
<li>
<p><strong>Numerical Considerations</strong>:</p>
<ul>
<li>Integer division truncates fractional results (rounds toward zero)</li>
<li>Precision is limited to whole-number RSI values (sufficient for most applications)</li>
<li>Pre-scaling by 100 ensures meaningful integer results</li>
<li>8-bit output register accommodates the full 0-100 range</li>
<li>No loss of significant information in the conversion</li>
</ul>
</li>
<li>
<p><strong>Timing Aspects</strong>:</p>
<ul>
<li>Calculation occurs entirely within the DONE state</li>
<li>Single-cycle computation for efficiency</li>
<li>Result is immediately available with the done signal</li>
<li>Clean transition back to IDLE after calculation</li>
<li>Deterministic latency from accumulation completion to result</li>
</ul>
</li>
</ol>
<p>The direct implementation of the RSI formula provides several advantages:</p>
<ul>
<li>Computational efficiency with minimal operations</li>
<li>Clear relationship to the mathematical definition</li>
<li>Predictable output range and behavior</li>
<li>Easily verifiable results</li>
<li>Compatible with standard RSI interpretation</li>
</ul>
<p>This final calculation approach balances accuracy with implementation efficiency, providing reliable RSI values suitable for technical analysis applications while minimizing resource utilization and maintaining deterministic timing characteristics.</p>
<h4 id="edge-case-handling">Edge Case Handling</h4>
<p>The RSI implementation incorporates specific mechanisms to handle edge cases and special conditions that might arise during calculation. These approaches ensure robust operation even under unusual market conditions or data patterns.</p>
<ol>
<li>
<p><strong>Division by Zero Protection</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> ((gain_sum + loss_sum) &gt; <span class="hljs-number">0</span>)
    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
<span class="hljs-keyword">else</span>
    rsi &lt;= <span class="hljs-number">0</span>;
</div></code></pre>
<ul>
<li>Explicit check for zero denominator</li>
<li>Default RSI value of 0 when no price changes have occurred</li>
<li>Prevents potential hardware failure from illegal division</li>
<li>Provides deterministic behavior for all input patterns</li>
<li>Consistent with RSI interpretation (no momentum = 0)</li>
</ul>
</li>
<li>
<p><strong>First Sample Handling</strong>:</p>
<ul>
<li>Special logic in the READ_INIT state isolates the first price</li>
<li>Prevents invalid comparison before two prices are available</li>
<li>Establishes a baseline for subsequent comparisons</li>
<li>Creates consistent starting conditions</li>
<li>Ensures proper sequencing from the beginning</li>
</ul>
</li>
<li>
<p><strong>Equal Prices Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (price_out &gt; prev_price)
    gain_sum &lt;= gain_sum + (price_out - prev_price);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_out &lt; prev_price)
    loss_sum &lt;= loss_sum + (prev_price - price_out);
<span class="hljs-comment">// No action when prices are equal</span>
</div></code></pre>
<ul>
<li>Explicit conditions for both gain and loss cases</li>
<li>No accumulation when consecutive prices are identical</li>
<li>Avoids unnecessary calculations</li>
<li>Correctly handles periods of price stability</li>
<li>Maintains accurate representation of market momentum</li>
</ul>
</li>
<li>
<p><strong>FIFO Empty Detection</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (sample_cnt &lt; <span class="hljs-number">19</span> &amp;&amp; !fifo_empty) <span class="hljs-keyword">begin</span>
    fifo_rd_en &lt;= <span class="hljs-number">1</span>;
    read_delay &lt;= <span class="hljs-number">1</span>;
    state &lt;= READ_WAIT;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Explicit check for FIFO empty condition</li>
<li>Prevents read attempts from an empty buffer</li>
<li>Ensures data validity throughout calculation</li>
<li>Protects against timing issues</li>
<li>Maintains FIFO integrity</li>
</ul>
</li>
<li>
<p><strong>Sample Count Tracking</strong>:</p>
<ul>
<li>Explicit counter for processed samples</li>
<li>Comparison against expected count (19 for 20 samples)</li>
<li>Ensures complete processing of all required data</li>
<li>Prevents premature calculation completion</li>
<li>Maintains consistent window size for calculation</li>
</ul>
</li>
<li>
<p><strong>Reset Behavior</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    state &lt;= IDLE;
    fifo_wr_en &lt;= <span class="hljs-number">0</span>;
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    done &lt;= <span class="hljs-number">0</span>;
    rsi &lt;= <span class="hljs-number">0</span>;
    sample_cnt &lt;= <span class="hljs-number">0</span>;
    gain_sum &lt;= <span class="hljs-number">0</span>;
    loss_sum &lt;= <span class="hljs-number">0</span>;
    prev_price &lt;= <span class="hljs-number">0</span>;
    read_delay &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Complete initialization of all registers</li>
<li>Known starting state for all variables</li>
<li>Clean FIFO control signals</li>
<li>Consistent output values after reset</li>
<li>Predictable behavior during system initialization</li>
</ul>
</li>
<li>
<p><strong>Read Delay Management</strong>:</p>
<ul>
<li>Explicit flag (<code>read_delay</code>) tracks FIFO read timing</li>
<li>Compensates for one-cycle delay in data availability</li>
<li>Ensures proper sequencing of price comparisons</li>
<li>Prevents race conditions in data processing</li>
<li>Maintains data integrity throughout calculation</li>
</ul>
</li>
<li>
<p><strong>Signal Timing Coordination</strong>:</p>
<ul>
<li>One-cycle pulses for control signals</li>
<li>Clear separation between sequential operations</li>
<li>Explicit state transitions for operational phases</li>
<li>Predictable timing relationships</li>
<li>Deterministic cycle count for complete calculation</li>
</ul>
</li>
</ol>
<p>These edge case handling mechanisms collectively ensure that the RSI calculation remains robust and accurate across all market conditions and data patterns, preventing errors that might otherwise arise from special conditions or unusual price sequences.</p>
<h4 id="optimization-details">Optimization Details</h4>
<p>The RSI implementation incorporates several optimization techniques to enhance performance, minimize resource utilization, and ensure efficient operation on FPGA platforms:</p>
<ol>
<li>
<p><strong>Incremental Calculation Approach</strong>:</p>
<ul>
<li>Direct accumulation of gains and losses without recalculation</li>
<li>O(1) complexity per price update</li>
<li>Elimination of redundant calculations</li>
<li>Minimal memory access requirements</li>
<li>Efficient utilization of computational resources</li>
</ul>
</li>
<li>
<p><strong>Register Sizing Optimization</strong>:</p>
<ul>
<li>32-bit accumulators for gain_sum and loss_sum
<ul>
<li>Sufficient width to prevent overflow (typical price changes * period)</li>
<li>Balanced precision and resource utilization</li>
</ul>
</li>
<li>16-bit price registers (prev_price, curr_price)
<ul>
<li>Compatible with standard price representation</li>
<li>Sufficient range for typical financial instruments</li>
</ul>
</li>
<li>3-bit state register
<ul>
<li>Minimal width for six states</li>
<li>Efficient encoding for hardware implementation</li>
</ul>
</li>
<li>8-bit RSI output
<ul>
<li>Precisely matches 0-100 range requirement</li>
<li>No wasted bits or unnecessary precision</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Memory Management</strong>:</p>
<ul>
<li>Price FIFO implements efficient circular buffer</li>
<li>Direct access to price values without redundant storage</li>
<li>Minimal pointer management</li>
<li>Synchronized read/write operations</li>
<li>Clear full/empty indicators for control flow</li>
</ul>
</li>
<li>
<p><strong>Control Flow Optimization</strong>:</p>
<ul>
<li>State-based processing eliminates complex control logic</li>
<li>Deterministic transitions minimize conditional branches</li>
<li>Single-cycle state updates where possible</li>
<li>Clear operational phases with minimal overhead</li>
<li>Predictable cycle count for verification</li>
</ul>
</li>
<li>
<p><strong>Calculation Efficiency</strong>:</p>
<ul>
<li>Direct integer arithmetic for all operations</li>
<li>Division only performed once at calculation completion</li>
<li>No complex mathematical functions</li>
<li>Minimal intermediate storage requirements</li>
<li>Single-path execution for most operations</li>
</ul>
</li>
<li>
<p><strong>Interface Efficiency</strong>:</p>
<ul>
<li>Clean one-cycle pulses for control signals</li>
<li>Minimal handshaking overhead</li>
<li>Direct data paths between modules</li>
<li>Consistent protocol across interfaces</li>
<li>Clear completion signaling</li>
</ul>
</li>
<li>
<p><strong>FSM Structure Optimization</strong>:</p>
<ul>
<li>Balanced state distribution for functionality</li>
<li>Minimal transitions between states</li>
<li>Linear progression through primary calculation phases</li>
<li>Clear separation of initialization, processing, and completion</li>
<li>Default state handling for robustness</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Considerations</strong>:</p>
<ul>
<li>Register reuse where appropriate</li>
<li>Minimal intermediate storage</li>
<li>Efficient arithmetic implementation</li>
<li>Balance between sequential and combinational logic</li>
<li>Predictable synthesis to FPGA resources</li>
</ul>
</li>
<li>
<p><strong>Potential Advanced Optimizations</strong>:</p>
<ul>
<li>Fixed-point arithmetic for improved precision</li>
<li>Pipelined division for higher throughput</li>
<li>Resource sharing between calculation modules</li>
<li>Parameterized implementation for different window sizes</li>
<li>Clock gating for power efficiency in inactive states</li>
</ul>
</li>
</ol>
<p>These optimization techniques collectively create an implementation that balances performance, resource utilization, and calculation accuracy, providing efficient RSI computation suitable for real-time trading applications on FPGA platforms. The design particularly emphasizes deterministic timing and predictable resource requirements, key considerations for hardware implementation.</p>
<h3 id="trading-decision-logic">Trading Decision Logic</h3>
<h4 id="strategy-implementation">Strategy Implementation</h4>
<p>The trading decision module implements a momentum-based mean reversion strategy that combines trend analysis (using price vs. moving average) with momentum indicators (RSI) to generate buy and sell signals. This approach aims to identify potential reversal points in the market where price action is likely to revert to the mean after reaching extreme conditions.</p>
<p>The strategy logic is implemented with a straightforward approach:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
)(
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_now,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         sell
);
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            buy  &lt;= <span class="hljs-number">0</span>;
            sell &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
            sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This implementation defines a specific trading strategy with the following characteristics:</p>
<ol>
<li>
<p><strong>Buy Signal Conditions</strong>:</p>
<ul>
<li>Price is ABOVE the moving average (indicates uptrend)</li>
<li>RSI is BELOW the buy threshold (indicates oversold condition)</li>
<li>Both conditions must be true simultaneously</li>
<li>Default threshold: RSI &lt; 30 (traditional oversold level)</li>
</ul>
</li>
<li>
<p><strong>Sell Signal Conditions</strong>:</p>
<ul>
<li>Price is BELOW the moving average (indicates downtrend)</li>
<li>RSI is ABOVE the sell threshold (indicates overbought condition)</li>
<li>Both conditions must be true simultaneously</li>
<li>Default threshold: RSI &gt; 70 (traditional overbought level)</li>
</ul>
</li>
<li>
<p><strong>Strategy Rationale</strong>:</p>
<ul>
<li><strong>Trend Confirmation</strong>: The price vs. MA comparison confirms the primary trend direction</li>
<li><strong>Momentum Divergence</strong>: The RSI identifies potential reversal points through overbought/oversold conditions</li>
<li><strong>Mean Reversion Principle</strong>: The strategy assumes prices will revert to the mean after reaching extremes</li>
<li><strong>Contrary Trading</strong>: Buying during oversold conditions and selling during overbought conditions</li>
</ul>
</li>
<li>
<p><strong>Strategy Characteristics</strong>:</p>
<ul>
<li><strong>Type</strong>: Counter-trend, mean reversion</li>
<li><strong>Timeframe</strong>: Determined by MA period (default: 20) and RSI period (default: 14)</li>
<li><strong>Risk Profile</strong>: Moderate (requires confirmation from multiple indicators)</li>
<li><strong>Applicability</strong>: Works best in range-bound markets, less effective in strong trends</li>
<li><strong>Signal Frequency</strong>: Depends on market volatility and threshold settings</li>
</ul>
</li>
</ol>
<p>The strategy implementation is intentionally streamlined for efficiency and clarity, with parameterized thresholds allowing for customization to different market conditions and risk preferences without changing the core logic.</p>
<h4 id="signal-generation-criteria">Signal Generation Criteria</h4>
<p>The trading decision module generates buy and sell signals based on specific combinations of technical indicator values. These criteria are carefully designed to identify potential trading opportunities while minimizing false signals.</p>
<p>The signal generation logic is implemented as:</p>
<pre class="hljs"><code><div>buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);
</div></code></pre>
<p>This logic implements several key concepts for technical trading:</p>
<ol>
<li>
<p><strong>Buy Signal Criteria</strong>:</p>
<p>A buy signal is generated when both of these conditions are true:</p>
<ul>
<li><strong>Price &gt; Moving Average</strong>: This indicates an uptrend is in progress</li>
<li><strong>RSI &lt; BUY_RSI_THR (default: 30)</strong>: This indicates an oversold condition</li>
</ul>
<p>This combination identifies situations where:</p>
<ul>
<li>The market is in an overall uptrend (price above MA)</li>
<li>The price has temporarily pulled back (low RSI)</li>
<li>There is a higher probability of upward price movement</li>
<li>The risk/reward ratio is favorable for long positions</li>
</ul>
</li>
<li>
<p><strong>Sell Signal Criteria</strong>:</p>
<p>A sell signal is generated when both of these conditions are true:</p>
<ul>
<li><strong>Price &lt; Moving Average</strong>: This indicates a downtrend is in progress</li>
<li><strong>RSI &gt; SELL_RSI_THR (default: 70)</strong>: This indicates an overbought condition</li>
</ul>
<p>This combination identifies situations where:</p>
<ul>
<li>The market is in an overall downtrend (price below MA)</li>
<li>The price has temporarily rallied (high RSI)</li>
<li>There is a higher probability of downward price movement</li>
<li>The risk/reward ratio is favorable for short positions</li>
</ul>
</li>
<li>
<p><strong>Signal Logic Implementation</strong>:</p>
<ul>
<li><strong>AND Logic</strong>: Both conditions must be true simultaneously</li>
<li><strong>Registered Outputs</strong>: Signals are synchronized to the clock</li>
<li><strong>Mutual Exclusivity</strong>: Buy and sell conditions are mutually exclusive by design</li>
<li><strong>Clean Reset</strong>: Both signals are cleared on system reset</li>
<li><strong>Continuous Evaluation</strong>: Conditions are re-evaluated on every clock cycle</li>
</ul>
</li>
<li>
<p><strong>Threshold Considerations</strong>:</p>
<ul>
<li><strong>Default Values</strong>: Based on traditional technical analysis practices
<ul>
<li>RSI &lt; 30: Standard oversold threshold</li>
<li>RSI &gt; 70: Standard overbought threshold</li>
</ul>
</li>
<li><strong>Parameterization</strong>: Thresholds can be adjusted without code changes</li>
<li><strong>Customization Options</strong>:
<ul>
<li>More aggressive thresholds: 20/80 for fewer but stronger signals</li>
<li>More conservative thresholds: 40/60 for more frequent but weaker signals</li>
<li>Asymmetric thresholds: Different values for buy vs. sell to match market characteristics</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Signal Quality Factors</strong>:</p>
<ul>
<li><strong>Confirmation</strong>: Using multiple indicators reduces false signals</li>
<li><strong>Confluence</strong>: Both trend and momentum must align for signal generation</li>
<li><strong>Timeliness</strong>: Signals occur at potential market turning points</li>
<li><strong>Clarity</strong>: Binary output provides clear action indication</li>
<li><strong>Flexibility</strong>: Parameterized thresholds allow strategy tuning</li>
</ul>
</li>
</ol>
<p>These signal generation criteria implement a specific trading approach that aims to:</p>
<ul>
<li>Enter long positions during uptrends when prices have pulled back</li>
<li>Enter short positions during downtrends when prices have rallied</li>
<li>Avoid trading against the primary trend</li>
<li>Use extreme RSI readings to identify potential reversal points</li>
<li>Wait for confluence between different technical indicators</li>
</ul>
<h4 id="threshold-configuration">Threshold Configuration</h4>
<p>The trading decision module implements a parameterized approach to threshold configuration, allowing customization of the strategy sensitivity without code changes. This design enables adaptation to different market conditions, instruments, and trading preferences through simple parameter adjustments.</p>
<p>The threshold parameters are defined at the module level:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<p>These parameters control the RSI levels at which buy and sell signals are generated, offering several key advantages:</p>
<ol>
<li>
<p><strong>Default Configuration</strong>:</p>
<ul>
<li><strong>BUY_RSI_THR = 30</strong>: The traditional oversold level for RSI</li>
<li><strong>SELL_RSI_THR = 70</strong>: The traditional overbought level for RSI</li>
<li>These values follow standard technical analysis practices</li>
<li>Provide a balanced approach for most market conditions</li>
<li>Offer a starting point for strategy customization</li>
</ul>
</li>
<li>
<p><strong>Parameter Format</strong>:</p>
<ul>
<li>8-bit width (8'd) matching the RSI output range (0-100)</li>
<li>Explicit values for clarity and documentation</li>
<li>Compile-time constants for efficiency</li>
<li>Direct integration with signal generation logic</li>
<li>Clear relationship to standard RSI interpretation</li>
</ul>
</li>
<li>
<p><strong>Customization Options</strong>:</p>
<ul>
<li>
<p><strong>Conservative Settings</strong>:</p>
<ul>
<li>BUY_RSI_THR = 40, SELL_RSI_THR = 60</li>
<li>Generates more frequent signals</li>
<li>Smaller expected price movements</li>
<li>Lower risk per trade</li>
<li>Higher trading frequency</li>
<li>More suitable for range-bound markets</li>
</ul>
</li>
<li>
<p><strong>Aggressive Settings</strong>:</p>
<ul>
<li>BUY_RSI_THR = 20, SELL_RSI_THR = 80</li>
<li>Generates fewer signals</li>
<li>Larger expected price movements</li>
<li>Higher risk per trade</li>
<li>Lower trading frequency</li>
<li>More suitable for volatile markets</li>
</ul>
</li>
<li>
<p><strong>Asymmetric Settings</strong>:</p>
<ul>
<li>Different thresholds for buy and sell signals</li>
<li>Accommodates market asymmetry (e.g., bull vs. bear markets)</li>
<li>Adapts to instrument-specific characteristics</li>
<li>Implements directional bias when appropriate</li>
<li>Supports various market regimes</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Implementation Mechanism</strong>:</p>
<ul>
<li>Parameters override at instantiation time:</li>
</ul>
<pre class="hljs"><code><div>trading_decision #(
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">25</span>),     <span class="hljs-comment">// More aggressive buy threshold</span>
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">75</span>)     <span class="hljs-comment">// More aggressive sell threshold</span>
) decision_module (
    <span class="hljs-comment">// Port connections</span>
);
</div></code></pre>
<ul>
<li>No runtime overhead for configuration</li>
<li>Clear documentation through explicit values</li>
<li>Consistent application throughout the module</li>
<li>Easy modification for different strategies</li>
</ul>
</li>
<li>
<p><strong>Market Adaptation Guidelines</strong>:</p>
<ul>
<li>
<p><strong>Volatile Markets</strong>:</p>
<ul>
<li>More extreme thresholds (20/80)</li>
<li>Reduces false signals during high volatility</li>
<li>Captures larger price movements</li>
</ul>
</li>
<li>
<p><strong>Range-Bound Markets</strong>:</p>
<ul>
<li>Less extreme thresholds (40/60)</li>
<li>Captures more mean-reversion opportunities</li>
<li>Increases trading frequency</li>
</ul>
</li>
<li>
<p><strong>Trending Markets</strong>:</p>
<ul>
<li>Asymmetric thresholds based on trend direction</li>
<li>Bias toward trend continuation</li>
<li>Reduced counter-trend signals</li>
</ul>
</li>
<li>
<p><strong>Specific Instruments</strong>:</p>
<ul>
<li>Custom thresholds based on historical behavior</li>
<li>Adapted to instrument volatility characteristics</li>
<li>Optimized for typical price patterns</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>This parameterized threshold approach provides flexibility while maintaining a clear and efficient implementation, enabling strategy customization without compromising the core decision logic or hardware efficiency.</p>
<h4 id="logic-implementation-details">Logic Implementation Details</h4>
<p>The trading decision module implements a straightforward combinational logic approach with registered outputs to generate trading signals. This design prioritizes simplicity, efficiency, and clear signal generation while maintaining deterministic timing characteristics.</p>
<p>The core logic implementation consists of:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        buy  &lt;= <span class="hljs-number">0</span>;
        sell &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
        sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>This implementation incorporates several important design considerations:</p>
<ol>
<li>
<p><strong>Combinational Logic Structure</strong>:</p>
<ul>
<li>Simple AND operation for each signal condition</li>
<li>Direct comparison between inputs and thresholds</li>
<li>Minimal gate depth for efficiency</li>
<li>Clear relationship between inputs and outputs</li>
<li>Straightforward synthesis to hardware</li>
</ul>
</li>
<li>
<p><strong>Signal Timing Control</strong>:</p>
<ul>
<li>Synchronous evaluation on clock rising edge</li>
<li>Single-cycle latency from input change to output update</li>
<li>Registered outputs for clean signal transitions</li>
<li>Consistent timing regardless of input values</li>
<li>Deterministic behavior for downstream components</li>
</ul>
</li>
<li>
<p><strong>Reset Handling</strong>:</p>
<ul>
<li>Asynchronous reset for immediate signal clearing</li>
<li>Both signals initialized to inactive (0)</li>
<li>Clean startup behavior</li>
<li>Safe default condition</li>
<li>Consistent with system-wide reset strategy</li>
</ul>
</li>
<li>
<p><strong>Bitwidth Management</strong>:</p>
<ul>
<li>Moving average truncation to match price width: <code>moving_avg[15:0]</code></li>
<li>Equal-width comparison between price and MA</li>
<li>Direct comparison between 8-bit RSI and threshold values</li>
<li>Compatibility with signal widths from indicator modules</li>
<li>Efficient implementation without unnecessary extensions</li>
</ul>
</li>
<li>
<p><strong>Signal Characteristics</strong>:</p>
<ul>
<li>Binary outputs (buy/sell active or inactive)</li>
<li>Mutually exclusive signals by design</li>
<li>Persistent until conditions change</li>
<li>Clear encoding of trading actions</li>
<li>Simple interface for downstream systems</li>
</ul>
</li>
<li>
<p><strong>Hardware Implementation Efficiency</strong>:</p>
<ul>
<li>Minimal register usage (two 1-bit registers)</li>
<li>Simple comparators for condition evaluation</li>
<li>Direct input connections without buffering</li>
<li>Clean synchronous design for FPGA implementation</li>
<li>Low resource utilization</li>
</ul>
</li>
<li>
<p><strong>Logic Verification Approach</strong>:</p>
<ul>
<li>Exhaustive testing of all condition combinations</li>
<li>Verification of mutual exclusivity</li>
<li>Reset behavior validation</li>
<li>Timing consistency checking</li>
<li>Edge case coverage</li>
</ul>
</li>
</ol>
<p>The logic implementation follows a deliberate minimalist approach, implementing only the essential functionality while maintaining reliability and clarity. This design choice prioritizes:</p>
<ul>
<li>Deterministic behavior under all conditions</li>
<li>Clear relationship between inputs and outputs</li>
<li>Efficient hardware implementation</li>
<li>Straightforward verification and validation</li>
<li>Maintainable code structure</li>
</ul>
<p>This approach creates a robust trading signal generation mechanism with predictable behavior, clear functionality, and efficient resource utilization.</p>
<h4 id="signal-timing-considerations">Signal Timing Considerations</h4>
<p>The trading decision module incorporates specific timing considerations to ensure that signals are generated with appropriate synchronization, persistence, and clarity. These timing aspects are critical for reliable integration with downstream trading systems and proper market interaction.</p>
<p>Key timing considerations in the signal generation include:</p>
<ol>
<li>
<p><strong>Synchronous Evaluation</strong>:</p>
<ul>
<li>All signal conditions are evaluated on the rising edge of the clock</li>
<li>Input sampling occurs simultaneously for all conditions</li>
<li>Consistent evaluation timing regardless of market conditions</li>
<li>Single-cycle latency from input change to output update</li>
<li>Deterministic behavior for system integration</li>
</ul>
</li>
<li>
<p><strong>Signal Persistence</strong>:</p>
<ul>
<li>Signals remain active as long as the conditions are met</li>
<li>No artificial duration limitation or pulse generation</li>
<li>Signals deactivate immediately when conditions change</li>
<li>Allows downstream systems to determine appropriate action timing</li>
<li>Creates clear entrance and exit points for positions</li>
</ul>
</li>
<li>
<p><strong>Signal Transition Characteristics</strong>:</p>
<ul>
<li>Clean transitions due to registered outputs</li>
<li>No glitches or intermediate states</li>
<li>Single-cycle update for all signal changes</li>
<li>Clear identification of condition changes</li>
<li>Minimal transition latency</li>
</ul>
</li>
<li>
<p><strong>Relationship to Indicator Updates</strong>:</p>
<ul>
<li>Trading signals update on the clock cycle after indicator changes</li>
<li>MA and RSI updates immediately reflect in signal evaluation</li>
<li>Price changes propagate through indicators to signals</li>
<li>Consistent timing relationship throughout the system</li>
<li>Predictable delay from price input to signal generation</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Considerations</strong>:</p>
<ul>
<li>Single clock domain for all evaluation and signal generation</li>
<li>No clock domain crossing issues</li>
<li>Synchronous operation with other system components</li>
<li>Consistent timing across the entire trading system</li>
<li>Simplified timing analysis and verification</li>
</ul>
</li>
<li>
<p><strong>Potential Signal Sequences</strong>:</p>
<p>For a typical price movement crossing the moving average with RSI changes:</p>
<table>
<thead>
<tr>
<th>Cycle</th>
<th>Price vs MA</th>
<th>RSI Condition</th>
<th>Buy Signal</th>
<th>Sell Signal</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Price &lt; MA</td>
<td>RSI = 35</td>
<td>0</td>
<td>0</td>
<td>Neither condition met</td>
</tr>
<tr>
<td>2</td>
<td>Price &lt; MA</td>
<td>RSI = 25</td>
<td>0</td>
<td>0</td>
<td>RSI &lt; 30, but wrong trend</td>
</tr>
<tr>
<td>3</td>
<td>Price &gt; MA</td>
<td>RSI = 25</td>
<td>1</td>
<td>0</td>
<td>Buy conditions met</td>
</tr>
<tr>
<td>4</td>
<td>Price &gt; MA</td>
<td>RSI = 35</td>
<td>0</td>
<td>0</td>
<td>RSI no longer &lt; 30</td>
</tr>
<tr>
<td>5</td>
<td>Price &gt; MA</td>
<td>RSI = 75</td>
<td>0</td>
<td>0</td>
<td>RSI &gt; 70, but wrong trend</td>
</tr>
<tr>
<td>6</td>
<td>Price &lt; MA</td>
<td>RSI = 75</td>
<td>0</td>
<td>1</td>
<td>Sell conditions met</td>
</tr>
<tr>
<td>7</td>
<td>Price &lt; MA</td>
<td>RSI = 65</td>
<td>0</td>
<td>0</td>
<td>RSI no longer &gt; 70</td>
</tr>
</tbody>
</table>
<p>This sequence demonstrates how signals are generated only when both conditions are met and persist only while both conditions remain satisfied.</p>
</li>
<li>
<p><strong>Reset Timing</strong>:</p>
<ul>
<li>Asynchronous reset immediately clears all signals</li>
<li>No delay between reset assertion and signal deactivation</li>
<li>Clean startup state with no active signals</li>
<li>Predictable behavior during system initialization</li>
<li>Safety mechanism for error conditions</li>
</ul>
</li>
<li>
<p><strong>Edge Case Handling</strong>:</p>
<ul>
<li>Threshold equality is handled explicitly ( or )</li>
<li>No timing hysteresis implemented (could be added if needed)</li>
<li>Oscillation prevention relies on threshold separation</li>
<li>Consistent handling of price/MA equality conditions</li>
<li>Deterministic behavior at boundary conditions</li>
</ul>
</li>
</ol>
<p>These timing considerations ensure that the trading signals are generated with appropriate synchronization to system timing, clear activation and deactivation points, and reliable propagation of condition changes, creating a robust foundation for algorithmic trading implementation.</p>
<h4 id="extensibility-features">Extensibility Features</h4>
<p>The trading decision module is designed with extension and customization in mind, providing several features that enable adaptation to different trading strategies, market conditions, and system requirements without major code modifications.</p>
<p>Key extensibility features include:</p>
<ol>
<li>
<p><strong>Parameterized Thresholds</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
<span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
</div></code></pre>
<ul>
<li>Configurable at instantiation time</li>
<li>No code changes required for threshold adjustment</li>
<li>Enable strategy tuning for different market conditions</li>
<li>Support backtesting of multiple threshold combinations</li>
<li>Allow adaptation to instrument-specific characteristics</li>
</ul>
</li>
<li>
<p><strong>Clean Signal Interface</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell
</div></code></pre>
<ul>
<li>Binary outputs for direct integration</li>
<li>Independent signals for flexible downstream handling</li>
<li>Registered outputs for timing predictability</li>
<li>Standard active-high logic for clarity</li>
<li>Minimal interface complexity</li>
</ul>
</li>
<li>
<p><strong>Modular Integration</strong>:</p>
<ul>
<li>Clear input requirements from indicator modules</li>
<li>Simple instantiation in larger systems</li>
<li>Well-defined timing relationships</li>
<li>Standard synchronous design patterns</li>
<li>Minimal dependencies for easy replacement</li>
</ul>
</li>
<li>
<p><strong>Strategy Extension Approaches</strong>:</p>
<ul>
<li>
<p><strong>Additional Indicators</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Extended module with MACD indicator</span>
<span class="hljs-keyword">module</span> trading_decision_ext #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_now,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> macd_positive,  <span class="hljs-comment">// New indicator input</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell
);
    <span class="hljs-comment">// Extended logic incorporating new indicator</span>
    buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR) &amp;&amp; macd_positive;
    sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR) &amp;&amp; !macd_positive;
</div></code></pre>
</li>
<li>
<p><strong>Alternative Strategies</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Trend-following instead of mean-reversion</span>
buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; <span class="hljs-number">50</span>) &amp;&amp; (rsi &lt; <span class="hljs-number">70</span>);
sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; <span class="hljs-number">50</span>) &amp;&amp; (rsi &gt; <span class="hljs-number">30</span>);
</div></code></pre>
</li>
<li>
<p><strong>Multiple Timeframe Support</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Incorporating multiple timeframe confirmation</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg_short,
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg_long,

buy  &lt;= (moving_avg_short &gt; moving_avg_long) &amp;&amp; (rsi &lt; BUY_RSI_THR);
sell &lt;= (moving_avg_short &lt; moving_avg_long) &amp;&amp; (rsi &gt; SELL_RSI_THR);
</div></code></pre>
</li>
<li>
<p><strong>Signal Filtering</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding signal persistence requirements</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] buy_counter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] sell_counter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">wire</span> buy_condition = (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
<span class="hljs-keyword">wire</span> sell_condition = (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);

<span class="hljs-comment">// Only assert signals after conditions met for multiple cycles</span>
buy &lt;= (buy_counter &gt;= <span class="hljs-number">3</span>);
sell &lt;= (sell_counter &gt;= <span class="hljs-number">3</span>);

<span class="hljs-comment">// Update counters</span>
<span class="hljs-keyword">if</span> (buy_condition) buy_counter &lt;= (buy_counter &lt; <span class="hljs-number">15</span>) ? buy_counter + <span class="hljs-number">1</span> : buy_counter;
<span class="hljs-keyword">else</span> buy_counter &lt;= <span class="hljs-number">0</span>;

<span class="hljs-keyword">if</span> (sell_condition) sell_counter &lt;= (sell_counter &lt; <span class="hljs-number">15</span>) ? sell_counter + <span class="hljs-number">1</span> : sell_counter;
<span class="hljs-keyword">else</span> sell_counter &lt;= <span class="hljs-number">0</span>;
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Output Extension Options</strong>:</p>
<ul>
<li>
<p><strong>Signal Strength Indication</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding signal strength output</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] buy_strength,
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] sell_strength,

<span class="hljs-comment">// Calculate signal strength based on condition margin</span>
buy_strength &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) ? (BUY_RSI_THR - rsi) : <span class="hljs-number">8&#x27;d0</span>;
sell_strength &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) ? (rsi - SELL_RSI_THR) : <span class="hljs-number">8&#x27;d0</span>;
</div></code></pre>
</li>
<li>
<p><strong>Position Sizing Signals</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding position size recommendation</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] position_size,  <span class="hljs-comment">// 0-15 scale</span>

<span class="hljs-comment">// Size based on signal strength</span>
position_size &lt;= (buy) ? (BUY_RSI_THR - rsi) / <span class="hljs-number">5</span> :
                (sell) ? (rsi - SELL_RSI_THR) / <span class="hljs-number">5</span> : <span class="hljs-number">4&#x27;d0</span>;
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Integration with Risk Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding risk control inputs</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> trading_allowed,
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> max_positions_reached,

<span class="hljs-comment">// Modified signal generation with risk constraints</span>
buy &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR) &amp;&amp;
       trading_allowed &amp;&amp; !max_positions_reached;
</div></code></pre>
</li>
</ol>
<p>These extensibility features enable the trading decision module to evolve with changing requirements, support multiple trading strategies, and integrate with more complex trading systems while maintaining the core functionality and performance characteristics.</p>
<h2 id="5-hardware-design-approach">5. Hardware Design Approach</h2>
<h3 id="memory-management">Memory Management</h3>
<h4 id="circular-buffer-design">Circular Buffer Design</h4>
<p>The price memory module implements a circular buffer design to efficiently store and manage price history. This approach provides an optimal solution for maintaining a sliding window of price data while minimizing resource utilization and operational complexity.</p>
<p>The circular buffer design is implemented as follows:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,    <span class="hljs-comment">// Depth of the FIFO</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>        <span class="hljs-comment">// Data width</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk, rst, wr_en,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> full,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count
);

    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];  <span class="hljs-comment">// Memory array</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Write pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;         <span class="hljs-comment">// Read pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] item_count = <span class="hljs-number">0</span>;       <span class="hljs-comment">// Item count in FIFO</span>
</div></code></pre>
<p>This circular buffer implementation incorporates several key design elements:</p>
<ol>
<li>
<p><strong>Memory Structure</strong>:</p>
<ul>
<li>Fixed-size array: <code>reg [DW-1:0] mem [0:DEPTH-1];</code></li>
<li>Parameterized depth (default: 14 elements)</li>
<li>Parameterized data width (default: 16 bits)</li>
<li>Sequential memory for efficient FPGA implementation</li>
<li>Linear address space with circular access pattern</li>
</ul>
</li>
<li>
<p><strong>Pointer Management</strong>:</p>
<ul>
<li>Write pointer (<code>write_ptr</code>) indicates the next position to write</li>
<li>Read pointer (<code>read_ptr</code>) indicates the oldest valid data location</li>
<li>5-bit pointer width allows addressing up to 32 elements</li>
<li>Circular behavior through modulo arithmetic: <code>(ptr + 1) % DEPTH</code></li>
<li>Independent pointers enable flexible buffer management</li>
</ul>
</li>
<li>
<p><strong>Capacity Tracking</strong>:</p>
<ul>
<li>Item counter (<code>item_count</code>) tracks the number of valid elements</li>
<li>6-bit width accommodates counts up to 32 (greater than DEPTH)</li>
<li>Full condition: <code>item_count == DEPTH</code></li>
<li>Empty condition (implicit): <code>item_count == 0</code></li>
<li>Count output provides fill level information to other modules</li>
</ul>
</li>
<li>
<p><strong>Operational Modes</strong>:</p>
<ul>
<li>
<p><strong>Filling Phase</strong>:</p>
<ul>
<li>Write pointer advances with each new price</li>
<li>Read pointer remains at initial position</li>
<li>Item count increases until reaching DEPTH</li>
<li>Data accumulates until buffer is full</li>
</ul>
</li>
<li>
<p><strong>Steady State Operation</strong>:</p>
<ul>
<li>Both pointers advance with each new price</li>
<li>Constant distance maintained between pointers</li>
<li>Item count remains equal to DEPTH</li>
<li>Oldest price is overwritten with each new price</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The circular buffer implementation includes logic for both phases:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        write_ptr &lt;= <span class="hljs-number">0</span>;
        read_ptr &lt;= <span class="hljs-number">0</span>;
        item_count &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Filling phase: write new price, increment count</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            item_count &lt;= item_count + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Steady state: overwrite oldest price</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ol start="5">
<li>
<p><strong>Data Access Model</strong>:</p>
<ul>
<li>Write access: Direct indexing with write pointer</li>
<li>Read access: Direct indexing with read pointer</li>
<li>Continuous output: <code>assign oldest_price = mem[read_ptr];</code></li>
<li>Single-cycle access for both read and write operations</li>
<li>Synchronous write, asynchronous read architecture</li>
</ul>
</li>
<li>
<p><strong>Buffer Visualization</strong>:</p>
<p>During the filling phase:</p>
<pre class="hljs"><code><div>Memory:   [ 0 | 1 | 2 | 3 | ... | DEPTH-1 ]
                                 
                             write_ptr
read_ptr  0
item_count increases
</div></code></pre>
<p>During steady state:</p>
<pre class="hljs"><code><div>Memory:   [ 0 | 1 | 2 | ... | DEPTH-1 ]
                           
        read_ptr        write_ptr
item_count = DEPTH
</div></code></pre>
<p>After several updates:</p>
<pre class="hljs"><code><div>Memory:   [ 0 | 1 | 2 | ... | DEPTH-1 ]
                       
                write_ptr read_ptr
item_count = DEPTH
</div></code></pre>
</li>
</ol>
<p>The circular buffer design provides several advantages for the price history application:</p>
<ul>
<li>Efficient memory utilization (fixed size allocation)</li>
<li>Constant-time access to both newest and oldest prices</li>
<li>Automatic overwriting of obsolete data</li>
<li>Simple pointer arithmetic for address calculation</li>
<li>Clear indication of buffer status through count and full flag</li>
</ul>
<h4 id="pointer-management-strategy">Pointer Management Strategy</h4>
<p>The price memory module implements a sophisticated pointer management strategy that maintains proper data sequencing, ensures correct access to both newest and oldest prices, and handles the transition between filling and steady-state operation seamlessly.</p>
<p>The pointer management is implemented through two key registers:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Points to next location to write</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;   <span class="hljs-comment">// Points to oldest valid data</span>
</div></code></pre>
<p>These pointers are manipulated according to specific rules that maintain the circular buffer's integrity:</p>
<ol>
<li>
<p><strong>Initialization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    write_ptr &lt;= <span class="hljs-number">0</span>;
    read_ptr &lt;= <span class="hljs-number">0</span>;
    item_count &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Both pointers reset to zero on system reset</li>
<li>Item count clears to indicate empty buffer</li>
<li>Creates a known starting state for predictable operation</li>
<li>Ensures proper sequencing from system startup</li>
<li>Reestablishes initial conditions after errors</li>
</ul>
</li>
<li>
<p><strong>Write Pointer Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
    mem[write_ptr] &lt;= new_price;
    write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Incremented after each write operation</li>
<li>Wraps around to zero when reaching DEPTH</li>
<li>Modulo operation implements circular behavior</li>
<li>Constantly advances regardless of buffer state</li>
<li>Points to the next location to be written</li>
</ul>
</li>
<li>
<p><strong>Read Pointer Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (wr_en &amp;&amp; item_count == DEPTH) <span class="hljs-keyword">begin</span>
    read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Remains at initial position during filling phase</li>
<li>Starts advancing once buffer is full</li>
<li>Maintains same increment pattern as write pointer</li>
<li>Circular addressing through modulo operation</li>
<li>Always points to the oldest valid data</li>
</ul>
</li>
<li>
<p><strong>Pointer Relationship Invariants</strong>:</p>
<ul>
<li>During filling: <code>write_ptr - read_ptr = item_count</code> (linear addressing)</li>
<li>During steady state: <code>(write_ptr - read_ptr) % DEPTH = 0</code> (full buffer)</li>
<li>Pointers may cross during operation (write_ptr &lt; read_ptr)</li>
<li>Maximum distance between pointers is DEPTH-1</li>
<li>Pointers converge when buffer is empty or full</li>
</ul>
</li>
<li>
<p><strong>Pointer Width Considerations</strong>:</p>
<ul>
<li>5-bit width supports buffer sizes up to 32 elements</li>
<li>Extra bit beyond addressing requirements prevents overflow</li>
<li>Same width for both pointers maintains consistency</li>
<li>Sufficient for parameterized DEPTH up to 32</li>
<li>Efficient implementation on FPGA hardware</li>
</ul>
</li>
<li>
<p><strong>Advanced Pointer Operations</strong>:</p>
<p>The implementation handles several key scenarios:</p>
<ul>
<li>
<p><strong>Buffer Filling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Only increment write pointer, read_ptr stays at 0</span>
    write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
    item_count &lt;= item_count + <span class="hljs-number">1</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
</li>
<li>
<p><strong>Buffer Full (Steady State)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Increment both pointers, maintaining full state</span>
    write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
    read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
</li>
<li>
<p><strong>Pointer Wrapping</strong>:
The modulo operation <code>(ptr + 1) % DEPTH</code> handles wrapping automatically:</p>
<ul>
<li>When <code>ptr == DEPTH-1</code>, the next value becomes 0</li>
<li>Creates seamless circular addressing</li>
<li>Handles arbitrary buffer sizes (parameterized)</li>
<li>Efficient implementation in hardware</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Visualization of Pointer Movement</strong>:</p>
<p>Initial state:</p>
<pre class="hljs"><code><div>Memory: [ 0 | 1 | 2 | 3 | ... | DEPTH-1 ]
          
        read_ptr
        write_ptr
</div></code></pre>
<p>After several writes (filling):</p>
<pre class="hljs"><code><div>Memory: [ A | B | C | D | ... | - ]
                         
       read_ptr      write_ptr
</div></code></pre>
<p>After buffer fills and more writes:</p>
<pre class="hljs"><code><div>Memory: [ I | J | E | F | G | H ]
                         
              read_ptr  write_ptr
</div></code></pre>
<p>After another write (oldest data overwritten):</p>
<pre class="hljs"><code><div>Memory: [ I | J | K | F | G | H ]
                           
                 read_ptr  write_ptr
</div></code></pre>
</li>
</ol>
<p>This pointer management strategy creates a robust circular buffer implementation that efficiently handles both the initial filling phase and continuous operation, providing reliable access to the sliding window of price data required for technical indicator calculations.</p>
<h4 id="memory-access-patterns">Memory Access Patterns</h4>
<p>The price memory module implements specific memory access patterns designed to support efficient calculation of technical indicators. These patterns enable optimal data flow while minimizing access conflicts and ensuring data consistency.</p>
<p>The key memory access patterns include:</p>
<ol>
<li>
<p><strong>Write-Only Access Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
    mem[write_ptr] &lt;= new_price;
    <span class="hljs-comment">// Pointer management...</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Single write port to memory array</li>
<li>Synchronous write operation on clock edge</li>
<li>Controlled by write enable signal</li>
<li>Occurs at location indicated by write pointer</li>
<li>Sequential access pattern following pointer movement</li>
</ul>
</li>
<li>
<p><strong>Read-Only Access Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">assign</span> oldest_price = mem[read_ptr];
</div></code></pre>
<ul>
<li>Continuous read access to oldest price</li>
<li>Asynchronous read operation</li>
<li>No explicit read enable required</li>
<li>Location determined by read pointer</li>
<li>Provides immediate access to oldest data</li>
</ul>
</li>
<li>
<p><strong>Access Timing Relationship</strong>:</p>
<ul>
<li>Writes occur on rising clock edge</li>
<li>Reads available continuously</li>
<li>One-cycle latency between write and read availability</li>
<li>No read-before-write conflicts</li>
<li>Sequential consistency maintained</li>
</ul>
</li>
<li>
<p><strong>Read-After-Write Considerations</strong>:</p>
<ul>
<li>New data available on the clock cycle after writing</li>
<li>Read of just-written data occurs only after pointer update</li>
<li>Circular buffer structure ensures proper aging of data</li>
<li>No explicit forwarding or bypassing required</li>
<li>Natural flow from newest to oldest through buffer aging</li>
</ul>
</li>
<li>
<p><strong>Data Flow Visualization</strong>:</p>
<p>For a buffer of depth 4, the data flow pattern is:</p>
<pre class="hljs"><code><div>Initial state:
mem: [ - | - | - | - ]

After write #1:
mem: [ A | - | - | - ]
     write_ptr  1

After write #2:
mem: [ A | B | - | - ]
     write_ptr  2

After write #3:
mem: [ A | B | C | - ]
     write_ptr  3

After write #4:
mem: [ A | B | C | D ]
     write_ptr  0
     read_ptr  0
     oldest_price = A

After write #5:
mem: [ E | B | C | D ]
     write_ptr  1
     read_ptr  1
     oldest_price = B
</div></code></pre>
<p>This visualization demonstrates how data flows through the buffer, with oldest values continuously replaced by newest values once the buffer is full.</p>
</li>
<li>
<p><strong>Access Pattern for Technical Indicators</strong>:</p>
<ul>
<li>
<p>Moving Average calculation:</p>
<ul>
<li>Access to oldest_price for subtraction from sum</li>
<li>Direct access to new_price for addition to sum</li>
<li>No need to access intermediate values</li>
</ul>
</li>
<li>
<p>RSI calculation:</p>
<ul>
<li>Sequential comparison of consecutive prices</li>
<li>Access to oldest_price for pointer movement</li>
<li>No random access to arbitrary elements</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Access Conflict Avoidance</strong>:</p>
<ul>
<li>No simultaneous read/write to same address
<ul>
<li>Write occurs at write_ptr</li>
<li>Read occurs at read_ptr</li>
<li>Pointers never point to same address during operation</li>
</ul>
</li>
<li>No concurrent modification of same data</li>
<li>Clear separation between read and write operations</li>
<li>Deterministic access pattern for verification</li>
</ul>
</li>
<li>
<p><strong>Memory Interface Optimization</strong>:</p>
<ul>
<li>Single read port (oldest_price) reduces interface complexity</li>
<li>Asynchronous read simplifies timing requirements</li>
<li>Synchronous write aligns with FPGA memory structures</li>
<li>Minimal control signals (only write_enable)</li>
<li>Clean separation between control and data paths</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Considerations</strong>:</p>
<ul>
<li>Implementation maps efficiently to FPGA memory resources</li>
<li>Small buffer sizes can use distributed RAM</li>
<li>Larger sizes can leverage block RAM resources</li>
<li>Single-port memory structure reduces resource requirements</li>
<li>Consistent access pattern improves synthesis results</li>
</ul>
</li>
</ol>
<p>These memory access patterns provide an efficient and deterministic mechanism for maintaining the sliding window of price data required by the technical indicators, ensuring proper data aging, consistent access to both newest and oldest values, and streamlined data flow through the system.</p>
<h4 id="fifo-implementation">FIFO Implementation</h4>
<p>The price memory module implements a First-In-First-Out (FIFO) buffer using a circular buffer approach. This FIFO implementation provides the storage backbone for the technical analysis system, maintaining the historical price data needed for indicator calculations.</p>
<p>The core FIFO functionality is implemented as follows:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,    <span class="hljs-comment">// Depth of the FIFO</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>        <span class="hljs-comment">// Data width</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk, rst, wr_en,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> full,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count
);

    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];  <span class="hljs-comment">// FIFO memory array</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Write pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;         <span class="hljs-comment">// Read pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] item_count = <span class="hljs-number">0</span>;       <span class="hljs-comment">// Item count in FIFO</span>

    <span class="hljs-keyword">assign</span> full = (item_count == DEPTH);   <span class="hljs-comment">// FIFO full flag</span>
    <span class="hljs-keyword">assign</span> count = item_count;             <span class="hljs-comment">// Output current count</span>
    <span class="hljs-keyword">assign</span> oldest_price = mem[read_ptr];   <span class="hljs-comment">// Oldest price is at read pointer</span>
</div></code></pre>
<p>This FIFO design incorporates several important features and considerations:</p>
<ol>
<li>
<p><strong>FIFO Operation Principles</strong>:</p>
<ul>
<li>Sequential data storage: First price in is the first price out</li>
<li>Automatic data aging as buffer fills</li>
<li>Oldest data automatically discarded when full</li>
<li>Fixed depth maintains consistent window size</li>
<li>Continuous operation with new data replacing oldest</li>
</ul>
</li>
<li>
<p><strong>FIFO Control Signals</strong>:</p>
<ul>
<li><code>wr_en</code>: Controls writing of new data to the FIFO</li>
<li><code>full</code>: Indicates FIFO has reached capacity</li>
<li><code>count</code>: Provides current fill level</li>
<li>No explicit read enable (continuous output)</li>
<li>Synchronous write, asynchronous read design</li>
</ul>
</li>
<li>
<p><strong>FIFO Writing Logic</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        write_ptr &lt;= <span class="hljs-number">0</span>;
        read_ptr &lt;= <span class="hljs-number">0</span>;
        item_count &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// If FIFO is not full, write to memory and increment count</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            item_count &lt;= item_count + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// If FIFO is full, overwrite oldest data</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Two distinct operating modes based on fill level</li>
<li>Automatic transition from filling to steady-state</li>
<li>Consistent pointer update logic</li>
<li>Atomic write operation with pointer updates</li>
<li>Clear separation between fill phase and steady-state</li>
</ul>
</li>
<li>
<p><strong>FIFO Reading Method</strong>:</p>
<ul>
<li>Continuous output of oldest value</li>
<li><code>assign oldest_price = mem[read_ptr];</code></li>
<li>No explicit read operation required</li>
<li>Read pointer updates automatically in full state</li>
<li>Asynchronous output for immediate availability</li>
</ul>
</li>
<li>
<p><strong>Special FIFO Characteristics</strong>:</p>
<ul>
<li><strong>Auto-discard</strong>: Automatically overwrites oldest data when full</li>
<li><strong>Fixed Window</strong>: Maintains constant-size sliding window</li>
<li><strong>Dual Mode</strong>: Functions as standard FIFO until full, then as circular buffer</li>
<li><strong>Single Element Reading</strong>: Only exposes oldest element (specialized for MA/RSI)</li>
<li><strong>Status Reporting</strong>: Provides both full flag and count for system coordination</li>
</ul>
</li>
<li>
<p><strong>FIFO State Visualization</strong>:</p>
<p>The FIFO progresses through distinct states during operation:</p>
<ul>
<li>
<p><strong>Empty State</strong>:</p>
<pre class="hljs"><code><div>mem: [ - | - | ... | - ]
read_ptr = write_ptr = 0
item_count = 0
full = 0
</div></code></pre>
</li>
<li>
<p><strong>Partially Filled State</strong>:</p>
<pre class="hljs"><code><div>mem: [ A | B | C | - | ... | - ]
read_ptr = 0
write_ptr = 3
item_count = 3
full = 0
</div></code></pre>
</li>
<li>
<p><strong>Full State</strong>:</p>
<pre class="hljs"><code><div>mem: [ A | B | C | ... | N ]
read_ptr = 0
write_ptr = 0
item_count = DEPTH
full = 1
</div></code></pre>
</li>
<li>
<p><strong>Steady State Operation</strong> (after additional writes):</p>
<pre class="hljs"><code><div>mem: [ O | P | C | ... | N ]
read_ptr = 2
write_ptr = 2
item_count = DEPTH
full = 1
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Overflow/Underflow Handling</strong>:</p>
<ul>
<li>No explicit overflow protection (by design)</li>
<li>Oldest data automatically discarded when full</li>
<li>No read operations when empty (count tracking)</li>
<li>Status signals prevent improper operations</li>
<li>Robust behavior under all operating conditions</li>
</ul>
</li>
</ol>
<p>This specialized FIFO implementation provides the foundation for the technical analysis system, maintaining the historical price window required for indicator calculations while optimizing for the specific access patterns and operational requirements of the system.</p>
<h4 id="overflowunderflow-protection">Overflow/Underflow Protection</h4>
<p>The price memory module incorporates specific mechanisms to handle overflow and underflow conditions, ensuring reliable operation under all circumstances. These protections prevent data corruption, maintain system integrity, and create predictable behavior even in edge cases.</p>
<p>The protection mechanisms include:</p>
<ol>
<li>
<p><strong>Overflow Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Still filling: increment count</span>
    item_count &lt;= item_count + <span class="hljs-number">1</span>;
<span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Already full: maintain count and advance both pointers</span>
    read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Automatic transition to circular buffer mode when full</li>
<li>Oldest data discarded when new data arrives in full state</li>
<li>No counter overflow due to conditional increment</li>
<li>Consistent FIFO size maintained regardless of input rate</li>
<li>Designed behavior rather than error condition</li>
</ul>
</li>
<li>
<p><strong>Underflow Prevention</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">assign</span> oldest_price = mem[read_ptr];  <span class="hljs-comment">// Always output current oldest price</span>
<span class="hljs-keyword">assign</span> full = (item_count == DEPTH);  <span class="hljs-comment">// Only signal full when actually full</span>
</div></code></pre>
<ul>
<li>No explicit read operation that could create underflow</li>
<li>Continuous output of current oldest price</li>
<li>Downstream modules use status signals for validity</li>
<li>System design prevents reading from empty buffer</li>
<li>Clear indication of data availability through count</li>
</ul>
</li>
<li>
<p><strong>Boundary Condition Handling</strong>:</p>
<ul>
<li>
<p><strong>Reset Condition</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    write_ptr &lt;= <span class="hljs-number">0</span>;
    read_ptr &lt;= <span class="hljs-number">0</span>;
    item_count &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Complete initialization to empty state</li>
<li>Known starting condition for predictable behavior</li>
<li>All status flags reflect empty state</li>
<li>Clean system state before operation</li>
<li>Synchronizes FIFO state with system reset</li>
</ul>
</li>
<li>
<p><strong>Write to Full Buffer</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (item_count == DEPTH) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Overwrite the oldest data</span>
    mem[write_ptr] &lt;= new_price;
    write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
    read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Automatically discards oldest data</li>
<li>Maintains constant buffer size</li>
<li>Updates both pointers atomically</li>
<li>No overflow condition generated</li>
<li>Intentional design for sliding window</li>
</ul>
</li>
<li>
<p><strong>Empty Buffer Reading</strong>:</p>
<ul>
<li>No explicit read operation to trigger underflow</li>
<li>Continuous output of current read location</li>
<li>Status signals indicate data validity</li>
<li>System-level coordination prevents invalid use</li>
<li>Implementation avoids error states</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Pointer Protection</strong>:</p>
<ul>
<li>5-bit pointers for addressing up to DEPTH=14 locations</li>
<li>Extra width provides margin against overflow</li>
<li>Modulo operation ensures valid addressing: <code>(ptr + 1) % DEPTH</code></li>
<li>Prevents pointers from exceeding valid range</li>
<li>Hardware-efficient implementation of wrapping</li>
</ul>
</li>
<li>
<p><strong>Counter Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// During filling phase</span>
item_count &lt;= item_count + <span class="hljs-number">1</span>;

<span class="hljs-comment">// During steady state (full)</span>
<span class="hljs-comment">// item_count remains unchanged</span>
</div></code></pre>
<ul>
<li>6-bit counter width accommodates DEPTH=14 plus margin</li>
<li>Conditional increment prevents overflow</li>
<li>No decrement during operation (specialized for application)</li>
<li>Counter saturates at DEPTH value</li>
<li>Provides reliable status information</li>
</ul>
</li>
<li>
<p><strong>Full/Empty Flag Logic</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">assign</span> full = (item_count == DEPTH);
<span class="hljs-comment">// Empty implicitly when item_count == 0</span>
</div></code></pre>
<ul>
<li>Direct comparison for reliable status</li>
<li>No complex derived conditions</li>
<li>Unambiguous state indication</li>
<li>Single-bit flags for simple integration</li>
<li>Immediate status updates with counter changes</li>
</ul>
</li>
<li>
<p><strong>System-Level Protection</strong>:</p>
<ul>
<li><code>compute_enable</code> signal derived from fill level</li>
<li>Calculation modules only activate when sufficient data available</li>
<li>Status monitoring prevents premature processing</li>
<li>Handshaking between modules for coordination</li>
<li>Consistent operation across system boundary</li>
</ul>
</li>
</ol>
<p>These protection mechanisms ensure that the price memory module maintains data integrity and operational reliability under all conditions. The approach treats overflow as a designed behavior rather than an error condition, implementing a circular buffer policy that automatically discards the oldest data when new data arrives in a full buffer. This aligns perfectly with the sliding window requirement of technical analysis indicators, where only the most recent N prices are relevant for calculation.</p>
<h3 id="computational-efficiency">Computational Efficiency</h3>
<h4 id="sliding-window-algorithm-details">Sliding Window Algorithm Details</h4>
<p>The technical analysis system implements an efficient sliding window algorithm for calculating the moving average. This algorithm achieves O(1) computational complexity per update, regardless of window size, making it significantly more efficient than naive approaches.</p>
<p>The sliding window algorithm is implemented in the Moving Average FSM module:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW     = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]  st = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            sum &lt;= <span class="hljs-number">0</span>; moving_avg &lt;= <span class="hljs-number">0</span>; done &lt;= <span class="hljs-number">0</span>; st &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (st)
                <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;
                <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
                    sum &lt;= sum + new_price - oldest_price;
                    moving_avg &lt;= sum / WINDOW;
                    done &lt;= <span class="hljs-number">1</span>;
                    st &lt;= <span class="hljs-number">2</span>;
                <span class="hljs-keyword">end</span>
                <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">0</span>;
                    st &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>The sliding window algorithm operates through the following key steps:</p>
<ol>
<li>
<p><strong>Algorithm Initialization</strong>:</p>
<ul>
<li>When the system starts, the sum register is initialized to zero</li>
<li>As prices fill the buffer, the sum accumulates the initial window values</li>
<li>Once the buffer is full, the sliding window operation begins</li>
<li>The initial sum represents the total of all prices in the window</li>
</ul>
</li>
<li>
<p><strong>Core Sliding Window Operation</strong>:</p>
<pre class="hljs"><code><div>sum &lt;= sum + new_price - oldest_price;
</div></code></pre>
<ul>
<li>When a new price arrives, it is added to the running sum</li>
<li>Simultaneously, the oldest price is subtracted from the sum</li>
<li>This maintains the sum of exactly WINDOW prices</li>
<li>No recalculation of the entire sum is needed</li>
<li>Operation complexity remains constant regardless of window size</li>
</ul>
</li>
<li>
<p><strong>Moving Average Calculation</strong>:</p>
<pre class="hljs"><code><div>moving_avg &lt;= sum / WINDOW;
</div></code></pre>
<ul>
<li>The moving average is calculated by dividing the sum by the window size</li>
<li>Single division operation per update</li>
<li>Results in the arithmetic mean of all prices in the window</li>
<li>Division by constant value (optimization opportunity)</li>
<li>Consistent precision across all calculations</li>
</ul>
</li>
<li>
<p><strong>Computational Complexity Analysis</strong>:</p>
<ul>
<li>
<p><strong>Naive Approach</strong> (not implemented):</p>
<pre class="hljs"><code><div>sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; WINDOW; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
    sum = sum + prices[i];
<span class="hljs-keyword">end</span>
moving_avg = sum / WINDOW;
</div></code></pre>
<ul>
<li>O(n) complexity, where n is the window size</li>
<li>Requires accessing all prices in the window</li>
<li>Recomputes the entire sum for each new price</li>
<li>Resource utilization and latency increase with window size</li>
<li>Inefficient for larger window sizes</li>
</ul>
</li>
<li>
<p><strong>Sliding Window Approach</strong> (implemented):</p>
<pre class="hljs"><code><div>sum = sum + new_price - oldest_price;
moving_avg = sum / WINDOW;
</div></code></pre>
<ul>
<li>O(1) complexity, independent of window size</li>
<li>Constant operation count for any window size</li>
<li>Minimal memory access (just newest and oldest prices)</li>
<li>Consistent performance as window size increases</li>
<li>Efficient for all practical window sizes</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Operation Count Comparison</strong>:</p>
<p>For a window size of 20:</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Additions</th>
<th>Subtractions</th>
<th>Divisions</th>
<th>Memory Accesses</th>
<th>Total Operations</th>
</tr>
</thead>
<tbody>
<tr>
<td>Naive</td>
<td>20</td>
<td>0</td>
<td>1</td>
<td>20</td>
<td>41</td>
</tr>
<tr>
<td>Sliding Window</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>This represents an approximately 8 reduction in operation count, with the advantage growing for larger window sizes.</p>
</li>
<li>
<p><strong>Implementation Considerations</strong>:</p>
<ul>
<li>
<p><strong>Sum Register Width</strong>:</p>
<ul>
<li>64-bit width prevents overflow during accumulation</li>
<li>Supports large price values and window sizes</li>
<li>Provides margin for growth without modification</li>
</ul>
</li>
<li>
<p><strong>Division Operation</strong>:</p>
<ul>
<li>Integer division for simplicity</li>
<li>Optimizable when WINDOW is a power of 2 (shift operation)</li>
<li>Potential for fixed-point implementation for better precision</li>
</ul>
</li>
<li>
<p><strong>Edge Case Handling</strong>:</p>
<ul>
<li>Calculation only begins when buffer is full</li>
<li>Clean reset behavior for sum register</li>
<li>Explicit state machine control</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Performance Benefits</strong>:</p>
<ul>
<li>Constant cycle count per update</li>
<li>Deterministic timing regardless of window size</li>
<li>Minimal resource utilization</li>
<li>Scalable to larger window sizes without performance impact</li>
<li>Simplified verification due to consistent behavior</li>
</ul>
</li>
</ol>
<p>The sliding window algorithm exemplifies the optimization approach used throughout the technical analysis system, focusing on computational efficiency, minimal resource utilization, and deterministic performance characteristics suitable for hardware implementation.</p>
<h4 id="register-sizing-optimization">Register Sizing Optimization</h4>
<p>The technical analysis system implements careful register sizing optimization to balance precision requirements with resource utilization. Each register is sized based on its specific role, range requirements, and performance impact, creating an efficient implementation that maintains calculation accuracy.</p>
<p>Key register sizing decisions include:</p>
<ol>
<li>
<p><strong>Price Data Registers (16-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,     <span class="hljs-comment">// DW=16 by default</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
<span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];      <span class="hljs-comment">// Price storage array</span>
</div></code></pre>
<ul>
<li>16-bit width accommodates typical price values</li>
<li>Sufficient range for most financial instruments</li>
<li>Standardized width across all price-related registers</li>
<li>Parameterized for flexibility (DW parameter)</li>
<li>Efficient FPGA memory utilization</li>
</ul>
<p><strong>Range Analysis</strong>:</p>
<ul>
<li>16-bit unsigned: 0 to 65,535</li>
<li>Sufficient for integer price representation</li>
<li>Covers typical stock and commodity price ranges</li>
<li>Could represent fixed-point values with scaling</li>
</ul>
</li>
<li>
<p><strong>Moving Average Sum Register (64-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Accumulator for MA calculation</span>
</div></code></pre>
<ul>
<li>Extended width prevents overflow during accumulation</li>
<li>Accommodates sum of multiple price values</li>
<li>Provides substantial margin beyond requirements</li>
<li>Eliminates need for overflow detection/handling</li>
<li>Simplifies implementation at minimal resource cost</li>
</ul>
<p><strong>Theoretical Requirements</strong>:</p>
<ul>
<li>For 16-bit prices and window size of 20:
<ul>
<li>Maximum possible sum: 20 * (2^16 - 1)  1.3 million</li>
<li>Required bits: log2(1.3 million)  21 bits</li>
</ul>
</li>
<li>64-bit implementation provides 43 bits of margin</li>
<li>Allows for future expansion of price width or window size</li>
</ul>
</li>
<li>
<p><strong>Moving Average Output Register (32-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,  <span class="hljs-comment">// Calculated moving average</span>
</div></code></pre>
<ul>
<li>32-bit width accommodates division results</li>
<li>Maintains precision after integer division</li>
<li>Standard data bus width for efficient integration</li>
<li>Sufficient range for all possible average values</li>
<li>Provides margin for fixed-point implementation</li>
</ul>
<p><strong>Precision Considerations</strong>:</p>
<ul>
<li>Result of division cannot exceed maximum price (16 bits)</li>
<li>Additional width accommodates future enhancements</li>
<li>Standardized interface width for system integration</li>
<li>Aligned with common processor data width</li>
</ul>
</li>
<li>
<p><strong>RSI Accumulators (32-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] gain_sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// Accumulator for gains</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] loss_sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// Accumulator for losses</span>
</div></code></pre>
<ul>
<li>32-bit width for gain and loss accumulators</li>
<li>Accommodates accumulation of price differences</li>
<li>Prevents overflow during extended operation</li>
<li>Balanced resource utilization for precision requirements</li>
<li>Consistent width for related registers</li>
</ul>
<p><strong>Range Requirements</strong>:</p>
<ul>
<li>Maximum single gain/loss = maximum price  65,535</li>
<li>For 14-period RSI with all gains/losses:
<ul>
<li>Maximum accumulated value: 14 * 65,535  0.92 million</li>
<li>Required bits: log2(0.92 million)  20 bits</li>
</ul>
</li>
<li>32-bit implementation provides 12 bits of margin</li>
</ul>
</li>
<li>
<p><strong>RSI Output Register (8-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,  <span class="hljs-comment">// RSI value (0-100)</span>
</div></code></pre>
<ul>
<li>8-bit width perfectly matches RSI range (0-100)</li>
<li>No wasted bits or unnecessary precision</li>
<li>Efficient resource utilization</li>
<li>Clear relationship to RSI definition</li>
<li>Standard representation for technical indicators</li>
</ul>
<p><strong>Precision Analysis</strong>:</p>
<ul>
<li>Maximum RSI value is 100, requiring 7 bits</li>
<li>8-bit implementation allows for future range extension</li>
<li>Integer precision sufficient for trading decisions</li>
<li>Consistent with traditional RSI interpretation</li>
</ul>
</li>
<li>
<p><strong>State Registers (Minimal Width)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] st = <span class="hljs-number">0</span>;     <span class="hljs-comment">// MA FSM state (3 states)</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;  <span class="hljs-comment">// RSI FSM state (6 states)</span>
</div></code></pre>
<ul>
<li>Minimal bit width to encode required states</li>
<li>2 bits for 3-state MA FSM (states 0-2)</li>
<li>3 bits for 6-state RSI FSM (states 0-5)</li>
<li>Efficient encoding for hardware implementation</li>
<li>Clear relationship between register and state count</li>
</ul>
</li>
<li>
<p><strong>Counter Registers</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] item_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// FIFO counter (0 to DEPTH)</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] sample_cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// RSI sample counter</span>
</div></code></pre>
<ul>
<li>Width sized to accommodate maximum count plus margin</li>
<li>6 bits for item_count (maximum value = DEPTH = 14)</li>
<li>5 bits for sample_cnt (maximum value = 19)</li>
<li>Prevention of counter overflow</li>
<li>Efficient implementation of counting logic</li>
</ul>
</li>
<li>
<p><strong>Pointer Registers</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;  <span class="hljs-comment">// FIFO write pointer</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;   <span class="hljs-comment">// FIFO read pointer</span>
</div></code></pre>
<ul>
<li>5-bit width allows addressing up to 32 locations</li>
<li>Sufficient for buffer depth of 14/20</li>
<li>Consistent width for related pointers</li>
<li>Efficient implementation of circular addressing</li>
<li>Prevents address overflow during wrapping</li>
</ul>
</li>
</ol>
<p>These register sizing optimizations collectively create an efficient implementation that balances precision requirements with resource utilization, ensuring accurate calculations while minimizing FPGA resource consumption and maintaining clear relationships between register widths and functional requirements.</p>
<h4 id="division-implementation-strategies">Division Implementation Strategies</h4>
<p>The technical analysis system implements division operations for both the moving average and RSI calculations. The division implementation strategy balances accuracy, resource utilization, and performance considerations while maintaining deterministic behavior.</p>
<p>The core division operations in the system include:</p>
<ol>
<li>
<p><strong>Moving Average Division</strong>:</p>
<pre class="hljs"><code><div>moving_avg &lt;= sum / WINDOW;  <span class="hljs-comment">// WINDOW = 20 by default</span>
</div></code></pre>
<ul>
<li>Divides the accumulated sum by the window size</li>
<li>Constant divisor (WINDOW parameter)</li>
<li>Single division operation per calculation</li>
<li>Integer division with truncation</li>
<li>Direct implementation in Verilog</li>
</ul>
</li>
<li>
<p><strong>RSI Division</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> ((gain_sum + loss_sum) &gt; <span class="hljs-number">0</span>)
    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
<span class="hljs-keyword">else</span>
    rsi &lt;= <span class="hljs-number">0</span>;
</div></code></pre>
<ul>
<li>More complex with variable divisor (gain_sum + loss_sum)</li>
<li>Pre-scaling by 100 for percentage calculation</li>
<li>Division protection for zero denominator</li>
<li>Integer division with truncation</li>
<li>Result constrained to 0-100 range</li>
</ul>
</li>
</ol>
<p>The implementation includes several strategies and considerations:</p>
<ol>
<li>
<p><strong>Integer Division Characteristics</strong>:</p>
<ul>
<li>Truncates fractional results (rounds toward zero)</li>
<li>Limited precision for non-integer results</li>
<li>Efficient implementation in hardware</li>
<li>Predictable behavior for all inputs</li>
<li>Sufficient for technical analysis applications</li>
</ul>
</li>
<li>
<p><strong>Synthesis Optimization Options</strong>:</p>
<ul>
<li>For constant divisors (like WINDOW), synthesis tools can optimize:
<ul>
<li>Division by powers of 2 becomes shift operations</li>
<li>Division by other constants becomes multiply-shift combinations</li>
<li>Specialized division circuits for specific values</li>
<li>Resource-efficient implementations</li>
<li>Reduced latency compared to general division</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Division by Powers of 2</strong>:
When WINDOW is a power of 2 (e.g., 16, 32), the division can be implemented as:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// For WINDOW = 16 (2^4)</span>
moving_avg &lt;= sum &gt;&gt; <span class="hljs-number">4</span>;  <span class="hljs-comment">// Right shift by 4 bits</span>
</div></code></pre>
<ul>
<li>Single shift operation</li>
<li>Minimal resource utilization</li>
<li>Single-cycle execution</li>
<li>Exact binary division</li>
<li>Optimal performance</li>
</ul>
</li>
<li>
<p><strong>Division by Non-Power-of-2 Constants</strong>:
For values like WINDOW = 20, optimized implementations include:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Method 1: Multiply-shift approximation</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] scaled_dividend = sum * <span class="hljs-number">32&#x27;d3355443</span>;  <span class="hljs-comment">// Magic number: 2^26 / 20</span>
moving_avg &lt;= scaled_dividend &gt;&gt; <span class="hljs-number">26</span>;

<span class="hljs-comment">// Method 2: Reciprocal multiplication</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] reciprocal = <span class="hljs-number">32&#x27;h0_0083126</span>;  <span class="hljs-comment">// Fixed-point 1/20 with 24 fraction bits</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] product = sum * reciprocal;
moving_avg &lt;= product &gt;&gt; <span class="hljs-number">24</span>;
</div></code></pre>
<ul>
<li>Replaces division with multiplication and shift</li>
<li>Typically more efficient in FPGA hardware</li>
<li>May introduce small calculation errors</li>
<li>Often synthesized automatically by tools</li>
<li>Balances accuracy and resource utilization</li>
</ul>
</li>
<li>
<p><strong>Variable Divisor Handling</strong> (for RSI):</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Standard approach</span>
rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);

<span class="hljs-comment">// Alternative: Scaled integer approximation</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] total = gain_sum + loss_sum;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] scaled_gain = (gain_sum &lt;&lt; <span class="hljs-number">7</span>);  <span class="hljs-comment">// Scale by 128</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ratio = scaled_gain / total;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] scaled_rsi = (ratio * <span class="hljs-number">100</span>) &gt;&gt; <span class="hljs-number">7</span>;
rsi &lt;= scaled_rsi &gt; <span class="hljs-number">100</span> ? <span class="hljs-number">100</span> : scaled_rsi;
</div></code></pre>
<ul>
<li>Multiple approaches depending on precision needs</li>
<li>Tradeoff between accuracy and resource utilization</li>
<li>Scaling improves precision for integer division</li>
<li>Potential for FPGA-specific optimizations</li>
<li>Flexibility based on application requirements</li>
</ul>
</li>
<li>
<p><strong>FPGA-Specific Division Resources</strong>:</p>
<ul>
<li>Modern FPGAs offer several implementation options:
<ul>
<li>LUT-based division for small operands</li>
<li>DSP block utilization for multiplication in approximation methods</li>
<li>Dedicated division IP cores for complex requirements</li>
<li>Pipelined implementations for higher throughput</li>
<li>Latency vs. resource tradeoffs</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Implementation Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Division Strategy</th>
<th>Latency</th>
<th>Resource Usage</th>
<th>Accuracy</th>
<th>Scalability</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct Integer</td>
<td>High</td>
<td>High</td>
<td>Limited</td>
<td>Good</td>
</tr>
<tr>
<td>Power-of-2 Shift</td>
<td>Low</td>
<td>Minimal</td>
<td>Exact</td>
<td>Excellent</td>
</tr>
<tr>
<td>Multiply-Shift</td>
<td>Medium</td>
<td>Medium</td>
<td>Approx.</td>
<td>Good</td>
</tr>
<tr>
<td>Reciprocal Mult.</td>
<td>Medium</td>
<td>Medium</td>
<td>Approx.</td>
<td>Good</td>
</tr>
<tr>
<td>IP Core</td>
<td>Variable</td>
<td>High</td>
<td>High</td>
<td>Excellent</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Current Implementation Approach</strong>:</p>
<ul>
<li>Straightforward integer division in Verilog</li>
<li>Relies on synthesis tool optimization</li>
<li>Acceptable precision for technical indicators</li>
<li>Deterministic behavior for all inputs</li>
<li>Balances implementation complexity and performance</li>
</ul>
</li>
</ol>
<p>These division implementation strategies provide several options for balancing accuracy, resource utilization, and performance based on specific application requirements. The current implementation uses direct integer division with synthesis optimizations, which provides sufficient accuracy for technical analysis applications while maintaining implementation simplicity.</p>
<h4 id="fixed-point-vs-integer-arithmetic">Fixed Point vs Integer Arithmetic</h4>
<p>The technical analysis system primarily uses integer arithmetic for calculations, but the design considerations and tradeoffs between fixed-point and integer arithmetic were carefully evaluated during development.</p>
<ol>
<li>
<p><strong>Current Integer Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average calculation</span>
moving_avg &lt;= sum / WINDOW;

<span class="hljs-comment">// RSI calculation</span>
rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
</div></code></pre>
<ul>
<li>Pure integer arithmetic with truncation</li>
<li>No decimal precision in calculations</li>
<li>Simplified implementation and verification</li>
<li>Reduced resource requirements</li>
<li>Sufficient for many trading applications</li>
</ul>
</li>
<li>
<p><strong>Fixed-Point Alternative</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Example 16.16 fixed-point implementation (16 integer bits, 16 fractional)</span>

<span class="hljs-comment">// Moving Average calculation</span>
moving_avg &lt;= (sum &lt;&lt; <span class="hljs-number">16</span>) / WINDOW;  <span class="hljs-comment">// Scale up before division</span>

<span class="hljs-comment">// RSI calculation with 8.24 format</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] scaled_gain = gain_sum &lt;&lt; <span class="hljs-number">24</span>;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] total = gain_sum + loss_sum;
rsi &lt;= ((scaled_gain / total) * <span class="hljs-number">100</span>) &gt;&gt; <span class="hljs-number">24</span>;
</div></code></pre>
<ul>
<li>Maintains fractional precision through scaling</li>
<li>More accurate representation of decimal values</li>
<li>Requires careful scaling management</li>
<li>Increased implementation complexity</li>
<li>Additional resource requirements for wider datapaths</li>
</ul>
</li>
<li>
<p><strong>Implementation Considerations</strong>:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Integer Arithmetic</th>
<th>Fixed-Point Arithmetic</th>
</tr>
</thead>
<tbody>
<tr>
<td>Precision</td>
<td>Limited to whole numbers</td>
<td>Configurable decimal precision</td>
</tr>
<tr>
<td>Resource Usage</td>
<td>Lower</td>
<td>Higher (wider datapaths)</td>
</tr>
<tr>
<td>Implementation</td>
<td>Simpler</td>
<td>More complex</td>
</tr>
<tr>
<td>Overflow Risk</td>
<td>Lower (narrower values)</td>
<td>Higher (scaling operations)</td>
</tr>
<tr>
<td>Rounding Control</td>
<td>Limited (truncation)</td>
<td>Configurable rounding modes</td>
</tr>
<tr>
<td>Error Accumulation</td>
<td>Higher for repeated ops</td>
<td>Lower with sufficient precision</td>
</tr>
<tr>
<td>FPGA Mapping</td>
<td>Efficient</td>
<td>Requires careful optimization</td>
</tr>
<tr>
<td>Verification</td>
<td>Straightforward</td>
<td>More complex test scenarios</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Application-Specific Considerations</strong>:</p>
<ul>
<li>
<p><strong>Price Representation</strong>:</p>
<ul>
<li>Integer: Suitable for whole-number prices (stocks, commodities)</li>
<li>Fixed-point: Better for forex or fractional price instruments</li>
</ul>
</li>
<li>
<p><strong>Indicator Precision Requirements</strong>:</p>
<ul>
<li>Moving Average: Integer often sufficient</li>
<li>RSI: Near range boundaries (0-30, 70-100), added precision may help</li>
<li>More complex indicators: May benefit from fixed-point</li>
</ul>
</li>
<li>
<p><strong>Signal Generation Thresholds</strong>:</p>
<ul>
<li>Binary decisions (buy/sell) often work well with integer</li>
<li>Fine-grained position sizing might benefit from fixed-point</li>
<li>Strategy sensitivity analysis may require higher precision</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Migration Path to Fixed-Point</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Parameterized fixed-point definition</span>
<span class="hljs-keyword">parameter</span> FRAC_BITS = <span class="hljs-number">16</span>;

<span class="hljs-comment">// Moving Average with configurable precision</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] scaled_sum = sum &lt;&lt; FRAC_BITS;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] scaled_window = WINDOW &lt;&lt; FRAC_BITS;
moving_avg &lt;= scaled_sum / scaled_window;
</div></code></pre>
<ul>
<li>Gradual transition possible through parameterization</li>
<li>Configurable precision based on application needs</li>
<li>Maintain compatibility with existing modules</li>
<li>Selective application to critical calculations</li>
<li>Performance impact can be isolated and managed</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Impact</strong>:</p>
<ul>
<li>Register width increases (1.5-2 typical)</li>
<li>More complex arithmetic operations</li>
<li>Potential DSP usage for multiplication</li>
<li>Additional logic for scaling and rounding</li>
<li>Synthesis optimizations may mitigate some impacts</li>
</ul>
</li>
<li>
<p><strong>Current Decision Rationale</strong>:</p>
<ul>
<li>
<p>Integer arithmetic selected for:</p>
<ul>
<li>Implementation simplicity</li>
<li>Reduced resource requirements</li>
<li>Sufficient precision for implemented indicators</li>
<li>Clear behavior and verification</li>
<li>Compatibility with price representation</li>
</ul>
</li>
<li>
<p>Design allows future migration to fixed-point when:</p>
<ul>
<li>More sophisticated indicators are added</li>
<li>Higher precision requirements emerge</li>
<li>Additional resources become available</li>
<li>Specific trading strategies require it</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The current integer arithmetic implementation provides a solid foundation with appropriate precision for the implemented technical indicators, while maintaining clear design, efficient resource utilization, and straightforward verification. The system architecture supports future migration to fixed-point arithmetic when required for specific applications or enhanced precision.</p>
<h4 id="computation-reuse-techniques">Computation Reuse Techniques</h4>
<p>The technical analysis system implements several computation reuse techniques to enhance efficiency, minimize redundant calculations, and reduce resource utilization. These techniques optimize the implementation while maintaining calculation accuracy.</p>
<p>Key computation reuse approaches include:</p>
<ol>
<li>
<p><strong>Running Sum Maintenance</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average calculation</span>
sum &lt;= sum + new_price - oldest_price;
</div></code></pre>
<ul>
<li>Maintains a running sum instead of recalculating</li>
<li>Reuses previous sum value for efficiency</li>
<li>Requires only two operations per update</li>
<li>Constant complexity regardless of window size</li>
<li>Enables O(1) moving average calculation</li>
</ul>
</li>
<li>
<p><strong>Shared Memory Architecture</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Price Memory module used by both indicators</span>
price_memory mem14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.wr_en</span>(new_price),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.full</span>(mem_full),
    <span class="hljs-variable">.count</span>(count)
);
</div></code></pre>
<ul>
<li>Single price history buffer shared by multiple indicators</li>
<li>Eliminates redundant storage of identical data</li>
<li>Consistent price history across calculations</li>
<li>Reduced memory resource requirements</li>
<li>Simplified data management</li>
</ul>
</li>
<li>
<p><strong>Common Input Processing</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Both indicators triggered by same condition</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

<span class="hljs-comment">// Moving Average FSM</span>
moving_average_fsm ma14 (
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);

<span class="hljs-comment">// RSI module</span>
rsi_inc rsi14 (
    <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Single trigger condition for multiple operations</li>
<li>Shared control signals reduce logic duplication</li>
<li>Synchronized calculation timing</li>
<li>Consistent behavior across modules</li>
<li>Reduced control logic complexity</li>
</ul>
</li>
<li>
<p><strong>Direct Data Routing</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Direct routing of price data to modules</span>
<span class="hljs-variable">.new_price</span>(price_in),
<span class="hljs-variable">.oldest_price</span>(oldest_price),
</div></code></pre>
<ul>
<li>Current price passes directly to all modules</li>
<li>Avoids redundant buffering or storage</li>
<li>Minimizes data path latency</li>
<li>Reduces register usage</li>
<li>Maintains data consistency across modules</li>
</ul>
</li>
<li>
<p><strong>Efficient Gain/Loss Calculation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// RSI calculation optimized branch logic</span>
<span class="hljs-keyword">if</span> (price_out &gt; prev_price)
    gain_sum &lt;= gain_sum + (price_out - prev_price);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_out &lt; prev_price)
    loss_sum &lt;= loss_sum + (prev_price - price_out);
</div></code></pre>
<ul>
<li>Mutually exclusive calculation paths</li>
<li>Only one accumulator updated per comparison</li>
<li>Direct calculation of absolute difference</li>
<li>No redundant calculations or storage</li>
<li>Simplified data flow through calculation</li>
</ul>
</li>
<li>
<p><strong>Temporal Computation Reuse</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Reuse of calculation results across cycles</span>
prev_price &lt;= price_out;  <span class="hljs-comment">// Store for next cycle</span>
</div></code></pre>
<ul>
<li>Values calculated once and stored for future use</li>
<li>Avoids recalculation of unchanged values</li>
<li>Enables incremental processing approach</li>
<li>Maintains calculation state efficiently</li>
<li>Supports sliding window algorithm</li>
</ul>
</li>
<li>
<p><strong>Parallel Indicator Calculation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Simultaneous calculation of multiple indicators</span>
moving_average_fsm ma14 (...);
rsi_inc rsi14 (...);
</div></code></pre>
<ul>
<li>Concurrent processing of different indicators</li>
<li>Shared input data from common memory</li>
<li>Independent calculation paths</li>
<li>Maximizes computational throughput</li>
<li>Efficient resource utilization</li>
</ul>
</li>
<li>
<p><strong>Indicator-Specific Optimizations</strong>:</p>
<ul>
<li>
<p><strong>Moving Average</strong>:</p>
<ul>
<li>Efficient sliding window algorithm</li>
<li>Minimal processing per price update</li>
<li>Sum maintenance optimization</li>
</ul>
</li>
<li>
<p><strong>RSI</strong>:</p>
<ul>
<li>Incremental gain/loss accumulation</li>
<li>Direct comparison with previous values</li>
<li>Selective accumulator updates</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>These computation reuse techniques collectively enhance the efficiency of the technical analysis system, minimizing redundant calculations, optimizing memory usage, and creating streamlined data flows. The approach focuses on maintaining calculation state where beneficial, sharing common data between modules, and implementing algorithms that minimize computational complexity for each price update.</p>
<h3 id="control-logic">Control Logic</h3>
<h4 id="fsm-implementation-principles">FSM Implementation Principles</h4>
<p>The technical analysis system implements Finite State Machines (FSMs) to control the sequence of operations for indicator calculations. These FSMs follow specific design principles that enhance clarity, reliability, and efficiency in hardware implementation.</p>
<p>Key FSM implementation principles include:</p>
<ol>
<li>
<p><strong>Clear State Definition</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average FSM states</span>
<span class="hljs-comment">// State 0: Idle - Wait for start signal</span>
<span class="hljs-comment">// State 1: Calculate - Update sum and compute average</span>
<span class="hljs-comment">// State 2: Done - Signal completion and return to idle</span>

<span class="hljs-comment">// RSI FSM states</span>
<span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">3&#x27;b000</span>,
           FILL_FIFO = <span class="hljs-number">3&#x27;b001</span>,
           READ_INIT = <span class="hljs-number">3&#x27;b010</span>,
           READ_WAIT = <span class="hljs-number">3&#x27;b011</span>,
           COMPARE   = <span class="hljs-number">3&#x27;b100</span>,
           DONE      = <span class="hljs-number">3&#x27;b101</span>;
</div></code></pre>
<ul>
<li>Explicit state enumeration with descriptive comments</li>
<li>State constants with meaningful names (when using parameters)</li>
<li>Minimal states for required functionality</li>
<li>Clear relationship between states and operations</li>
<li>Logical progression through calculation sequence</li>
</ul>
</li>
<li>
<p><strong>Single Process State Machine</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
        state &lt;= IDLE;
        <span class="hljs-comment">// Register initialization</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Default assignments</span>
        
        <span class="hljs-keyword">case</span> (state)
            <span class="hljs-comment">// State-specific logic</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Combined next-state logic and output logic</li>
<li>Single always block for entire state machine</li>
<li>Sequential design with synchronous state transitions</li>
<li>Clear reset behavior</li>
<li>Simplified synthesis to hardware</li>
</ul>
</li>
<li>
<p><strong>Explicit State Transitions</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">case</span> (state)
    IDLE: <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (start) state &lt;= FILL_FIFO;
    <span class="hljs-keyword">end</span>
    
    FILL_FIFO: <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (fifo_full) state &lt;= READ_INIT;
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Additional states...</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Clear conditions for each state transition</li>
<li>Explicit assignments to next state</li>
<li>Deterministic transition behavior</li>
<li>Predictable execution flow</li>
<li>Simple verification of state sequences</li>
</ul>
</li>
<li>
<p><strong>Default Signal Assignments</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Default signal assignments</span>
done &lt;= <span class="hljs-number">0</span>;
fifo_wr_en &lt;= <span class="hljs-number">0</span>;
fifo_rd_en &lt;= <span class="hljs-number">0</span>;

<span class="hljs-keyword">case</span> (state)
    <span class="hljs-comment">// Override defaults in specific states</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Default values assigned before case statement</li>
<li>Explicit overrides in specific states</li>
<li>Prevents latches from unassigned signals</li>
<li>Clear signal behavior in all states</li>
<li>Robust synthesis to hardware</li>
</ul>
</li>
<li>
<p><strong>Registered Outputs</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// In the DONE state</span>
done &lt;= <span class="hljs-number">1</span>;
rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
</div></code></pre>
<ul>
<li>All outputs registered (sequential logic)</li>
<li>Clean timing on output signals</li>
<li>No combinational outputs from state machine</li>
<li>Consistent output behavior</li>
<li>Simplified timing analysis</li>
</ul>
</li>
<li>
<p><strong>Reset Initialization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    state &lt;= IDLE;      <span class="hljs-comment">// Reset to idle state</span>
    sum &lt;= <span class="hljs-number">0</span>;           <span class="hljs-comment">// Clear calculation registers</span>
    moving_avg &lt;= <span class="hljs-number">0</span>;    <span class="hljs-comment">// Clear outputs</span>
    done &lt;= <span class="hljs-number">0</span>;          <span class="hljs-comment">// Clear control signals</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Complete initialization of all registers</li>
<li>Known starting state for predictable behavior</li>
<li>Default inactive values for control signals</li>
<li>Clear data registers to prevent invalid calculations</li>
<li>Robust startup behavior</li>
</ul>
</li>
<li>
<p><strong>One-Hot Encoded Flag Signals</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Only one flag active at a time</span>
done &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">// Default inactive</span>

<span class="hljs-keyword">case</span> (state)
    DONE: <span class="hljs-keyword">begin</span>
        done &lt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// Only active in DONE state</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Control flags have single activation state</li>
<li>Clear flag behavior across all states</li>
<li>Mutually exclusive signal activation</li>
<li>Simplified downstream logic</li>
<li>Deterministic behavior for system integration</li>
</ul>
</li>
<li>
<p><strong>State Transition Diagrams</strong>:</p>
<p>Moving Average FSM:</p>
<pre class="hljs"><code><div>        start        auto    
      IDLE    CALCULATE  DONE 
     (st=0)                 (st=1)               (st=2)
                             
                                                       
         
                               auto
</div></code></pre>
<p>RSI FSM (simplified):</p>
<pre class="hljs"><code><div>                  
                       
      IDLE 
                               
                          
                        
  FILL_FIFO                      
                        
                                 
               
  READ_INIT DONE 
        
       
  
  COMPARE 
  
      
 
 READ_WAIT
 
</div></code></pre>
<ul>
<li>Visual representation of state relationships</li>
<li>Clear transition conditions</li>
<li>Cyclical and linear paths identified</li>
<li>Simplified understanding of complex FSMs</li>
<li>Aid for verification and debugging</li>
</ul>
</li>
</ol>
<p>These FSM implementation principles create robust, deterministic state machines that efficiently control the calculation sequence for technical indicators. The approach emphasizes clarity, predictability, and efficient hardware implementation, resulting in reliable control logic that orchestrates the data flow and computational elements of the system.</p>
<h4 id="state-encoding-techniques">State Encoding Techniques</h4>
<p>The technical analysis system employs specific state encoding techniques for the Finite State Machines (FSMs) that control indicator calculations. These encoding approaches balance clarity, hardware efficiency, and reliable operation.</p>
<p>Key state encoding techniques include:</p>
<ol>
<li>
<p><strong>Binary Encoding for Moving Average FSM</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] st = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 2-bit state register for 3 states</span>

<span class="hljs-comment">// States implicitly defined:</span>
<span class="hljs-comment">// st = 0: IDLE</span>
<span class="hljs-comment">// st = 1: CALCULATE</span>
<span class="hljs-comment">// st = 2: DONE</span>
</div></code></pre>
<ul>
<li>2-bit encoding for 3 states (values 0-2)</li>
<li>Natural binary counting sequence</li>
<li>Minimal bits for required states</li>
<li>Simple incremental transitions</li>
<li>Efficient encoding for small state machines</li>
</ul>
</li>
<li>
<p><strong>Explicit Constants for RSI FSM</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">3&#x27;b000</span>,
           FILL_FIFO = <span class="hljs-number">3&#x27;b001</span>,
           READ_INIT = <span class="hljs-number">3&#x27;b010</span>,
           READ_WAIT = <span class="hljs-number">3&#x27;b011</span>,
           COMPARE   = <span class="hljs-number">3&#x27;b100</span>,
           DONE      = <span class="hljs-number">3&#x27;b101</span>;

<span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = IDLE;  <span class="hljs-comment">// 3-bit state register</span>
</div></code></pre>
<ul>
<li>Named constants for each state</li>
<li>3-bit encoding for 6 states</li>
<li>Binary values chosen for clarity</li>
<li>Explicit state values for documentation</li>
<li>Self-documenting code with named states</li>
</ul>
</li>
<li>
<p><strong>Sequential Value Assignment</strong>:</p>
<ul>
<li>
<p>Moving Average FSM:</p>
<ul>
<li>States follow simple counting sequence: 0, 1, 2</li>
<li>Linear progression through states</li>
<li>Natural relationship between state order and value</li>
</ul>
</li>
<li>
<p>RSI FSM:</p>
<ul>
<li>State values assigned in logical groups:
<ul>
<li>Initial states: 000 (IDLE), 001 (FILL_FIFO)</li>
<li>Reading states: 010 (READ_INIT), 011 (READ_WAIT)</li>
<li>Processing states: 100 (COMPARE), 101 (DONE)</li>
</ul>
</li>
<li>Related states have related binary patterns</li>
<li>Simplified next-state logic</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Encoding Efficiency Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Encoding Technique</th>
<th>Bits Required</th>
<th>States Supported</th>
<th>Hardware Efficiency</th>
<th>Coding Clarity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binary</td>
<td>log2(n)</td>
<td>2^b</td>
<td>High</td>
<td>Moderate</td>
</tr>
<tr>
<td>One-Hot</td>
<td>n</td>
<td>n</td>
<td>Low</td>
<td>High</td>
</tr>
<tr>
<td>Gray Code</td>
<td>log2(n)</td>
<td>2^b</td>
<td>Moderate</td>
<td>Low</td>
</tr>
<tr>
<td>Current Binary</td>
<td>2-3 bits</td>
<td>3-6 states</td>
<td>High</td>
<td>High</td>
</tr>
</tbody>
</table>
<p>The current implementation uses binary encoding, providing an optimal balance of register size and clarity for the relatively small state machines in the system.</p>
</li>
<li>
<p><strong>State Register Width Considerations</strong>:</p>
<ul>
<li>
<p>Moving Average FSM: 2-bit register for 3 states</p>
<ul>
<li>Minimal width for required states</li>
<li>One unused state value (3)</li>
<li>No impact on hardware efficiency</li>
</ul>
</li>
<li>
<p>RSI FSM: 3-bit register for 6 states</p>
<ul>
<li>Accommodates all required states</li>
<li>Two unused state values (6, 7)</li>
<li>Minimal resource overhead</li>
<li>Potential for future extension</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Alternative Encoding Options</strong>:</p>
<ul>
<li>
<p><strong>One-Hot Encoding Option</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// For RSI FSM with 6 states</span>
<span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">6&#x27;b000001</span>,
           FILL_FIFO = <span class="hljs-number">6&#x27;b000010</span>,
           READ_INIT = <span class="hljs-number">6&#x27;b000100</span>,
           READ_WAIT = <span class="hljs-number">6&#x27;b001000</span>,
           COMPARE   = <span class="hljs-number">6&#x27;b010000</span>,
           DONE      = <span class="hljs-number">6&#x27;b100000</span>;

<span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] state = IDLE;  <span class="hljs-comment">// 6-bit register</span>
</div></code></pre>
<ul>
<li>One bit per state (6 bits for 6 states)</li>
<li>Simplified next-state logic</li>
<li>Clearer state transitions</li>
<li>Increased register width</li>
<li>Less efficient resource utilization</li>
</ul>
</li>
<li>
<p><strong>Gray Code Option</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// For RSI FSM with 6 states</span>
<span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">3&#x27;b000</span>,
           FILL_FIFO = <span class="hljs-number">3&#x27;b001</span>,
           READ_INIT = <span class="hljs-number">3&#x27;b011</span>,
           READ_WAIT = <span class="hljs-number">3&#x27;b010</span>,
           COMPARE   = <span class="hljs-number">3&#x27;b110</span>,
           DONE      = <span class="hljs-number">3&#x27;b111</span>;
</div></code></pre>
<ul>
<li>Only one bit changes between adjacent states</li>
<li>Reduced transition glitches</li>
<li>More complex value assignment</li>
<li>Less intuitive state values</li>
<li>Same register width as binary encoding</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Encoding Implementation Impact</strong>:</p>
<ul>
<li>
<p><strong>Synthesis Results</strong>:</p>
<ul>
<li>Binary encoding typically produces efficient logic</li>
<li>Modern FPGA synthesis tools can optimize state machines</li>
<li>Register width directly impacts resource utilization</li>
<li>State transition logic complexity affects LUT usage</li>
<li>Encoding choice affects routing and timing</li>
</ul>
</li>
<li>
<p><strong>Verification Considerations</strong>:</p>
<ul>
<li>Binary encoding provides clear state progression</li>
<li>Named constants enhance debugging readability</li>
<li>Waveform analysis simplified with sequential values</li>
<li>State values visible in simulation</li>
<li>Straightforward mapping between code and behavior</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The current binary encoding approach provides an effective balance between hardware efficiency and code clarity, using minimal register bits while maintaining readable state definitions and transitions. The explicit state constants in the RSI FSM enhance code maintainability while preserving the hardware efficiency of binary encoding.</p>
<h4 id="control-datapath-separation">Control-Datapath Separation</h4>
<p>The technical analysis system implements a clear separation between control logic and datapath components, following a fundamental hardware design principle that enhances modularity, maintainability, and verification.</p>
<p>Key aspects of this control-datapath separation include:</p>
<ol>
<li>
<p><strong>Control Logic Isolation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// State machine for control flow</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        state &lt;= IDLE;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">if</span> (start) state &lt;= CALCULATE;
            CALCULATE: state &lt;= DONE;
            DONE: state &lt;= IDLE;
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Dedicated state machines for sequencing operations</li>
<li>Clear state transitions based on control conditions</li>
<li>Isolation from data processing logic</li>
<li>Focused responsibility for operational flow</li>
<li>Simplified verification of control sequences</li>
</ul>
</li>
<li>
<p><strong>Datapath Logic Encapsulation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Datapath operations in each state</span>
<span class="hljs-keyword">case</span> (state)
    CALCULATE: <span class="hljs-keyword">begin</span>
        sum &lt;= sum + new_price - oldest_price;
        moving_avg &lt;= sum / WINDOW;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Data operations triggered by control states</li>
<li>Clear association between state and computations</li>
<li>Focused logic for data transformation</li>
<li>Arithmetic operations isolated from control flow</li>
<li>Simplified verification of calculation correctness</li>
</ul>
</li>
<li>
<p><strong>Control Signal Generation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Control signal generation</span>
done &lt;= (state == DONE);  <span class="hljs-comment">// Control signal depends on state</span>

<span class="hljs-comment">// Or more explicitly:</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        done &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == DONE) <span class="hljs-keyword">begin</span>
        done &lt;= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        done &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Explicit mapping from states to control signals</li>
<li>Clear relationship between FSM state and system control</li>
<li>Dedicated logic for control signal management</li>
<li>Consistent control behavior</li>
<li>Simplified debugging of control flow</li>
</ul>
</li>
<li>
<p><strong>Datapath Structure</strong>:</p>
<ul>
<li><strong>Price Memory</strong>: Datapath component for storing price history</li>
<li><strong>Accumulators</strong>: Sum, gain_sum, loss_sum registers</li>
<li><strong>Calculation Units</strong>: Division and comparison operations</li>
<li><strong>Output Registers</strong>: moving_avg, rsi result registers</li>
<li>Clear flow of data through dedicated components</li>
</ul>
</li>
<li>
<p><strong>Interface Between Control and Datapath</strong>:</p>
<ul>
<li>
<p><strong>Trigger Signals</strong>:</p>
<ul>
<li>start: Initiates calculation sequence</li>
<li>compute_enable: Triggers indicator calculations</li>
<li>fifo_wr_en/fifo_rd_en: Controls memory operations</li>
</ul>
</li>
<li>
<p><strong>Status Signals</strong>:</p>
<ul>
<li>memory_full: Indicates data availability</li>
<li>read_delay: Synchronizes data access timing</li>
<li>done: Signals calculation completion</li>
</ul>
</li>
<li>
<p><strong>Well-defined interfaces</strong> between control and datapath elements</p>
</li>
</ul>
</li>
<li>
<p><strong>Module-Level Separation</strong>:</p>
<ul>
<li><strong>Price Memory</strong>: Primarily datapath with minimal control</li>
<li><strong>Moving Average FSM</strong>: Integrated control and datapath</li>
<li><strong>RSI FSM</strong>: More complex control with multiple datapath elements</li>
<li><strong>Trading Decision</strong>: Simple control with conditional datapath</li>
<li><strong>Top-Level Integration</strong>: System-level control connecting datapath modules</li>
</ul>
</li>
<li>
<p><strong>Benefits of Separation</strong>:</p>
<ul>
<li>
<p><strong>Enhanced Testability</strong>:</p>
<ul>
<li>Control logic can be verified independently</li>
<li>Datapath functionality tested separately</li>
<li>Simplified test case development</li>
<li>Focused verification for each aspect</li>
<li>Comprehensive coverage with targeted tests</li>
</ul>
</li>
<li>
<p><strong>Improved Maintainability</strong>:</p>
<ul>
<li>Localized changes for control modifications</li>
<li>Isolated updates for calculation refinements</li>
<li>Reduced risk of unintended interactions</li>
<li>Clear documentation of system behavior</li>
<li>Easier understanding of complex operations</li>
</ul>
</li>
<li>
<p><strong>Design Reuse Opportunities</strong>:</p>
<ul>
<li>Control logic can be adapted for different calculations</li>
<li>Datapath components can be reused with different controllers</li>
<li>Modular enhancements for specific functions</li>
<li>Scalable architecture for additional features</li>
<li>Simplified integration of new components</li>
</ul>
</li>
<li>
<p><strong>Efficient Hardware Implementation</strong>:</p>
<ul>
<li>Clean mapping to hardware structures</li>
<li>Control typically maps to state machines/LUTs</li>
<li>Datapath maps to ALUs, multipliers, registers</li>
<li>Optimized resource utilization</li>
<li>Improved timing closure</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Implementation Patterns</strong>:</p>
<ul>
<li>
<p><strong>Small Modules</strong>: Moving Average combines control and datapath in single module</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Compact integration for simple functionality</span>
<span class="hljs-keyword">module</span> moving_average_fsm #(parameters) (ports);
    <span class="hljs-comment">// Both control (FSM) and datapath (sum, division) in one module</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>
<p><strong>Complex Modules</strong>: RSI separates internal control and datapath</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> rsi_inc #(parameters) (ports);
    <span class="hljs-comment">// Internal separation of control (state machine)</span>
    <span class="hljs-comment">// and datapath (accumulators, calculation)</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>
<p><strong>System Level</strong>: Explicit module separation by function</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Top-level integration shows separation</span>
price_memory mem14 (...);       <span class="hljs-comment">// Primarily datapath</span>
moving_average_fsm ma14 (...);  <span class="hljs-comment">// Mixed control/datapath</span>
rsi_inc rsi14 (...);            <span class="hljs-comment">// Mixed control/datapath</span>
trading_decision dec (...);      <span class="hljs-comment">// Simple control/datapath</span>
</div></code></pre>
</li>
</ul>
</li>
</ol>
<p>This control-datapath separation creates a clean architectural structure that enhances design clarity, simplifies verification, and improves maintainability. The approach is applied consistently throughout the system, with the level of separation scaled appropriately for the complexity of each module.</p>
<h4 id="state-transition-management">State Transition Management</h4>
<p>The technical analysis system implements sophisticated state transition management to ensure proper sequencing of operations, clear control flow, and reliable system behavior. This approach creates deterministic execution paths through the calculation process.</p>
<p>Key aspects of state transition management include:</p>
<ol>
<li>
<p><strong>Condition-Based Transitions</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average FSM</span>
<span class="hljs-keyword">case</span> (st)
    <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;         <span class="hljs-comment">// Transition on external trigger</span>
    <span class="hljs-number">1</span>: st &lt;= <span class="hljs-number">2</span>;                    <span class="hljs-comment">// Unconditional transition</span>
    <span class="hljs-number">2</span>: st &lt;= <span class="hljs-number">0</span>;                    <span class="hljs-comment">// Return to idle</span>
<span class="hljs-keyword">endcase</span>

<span class="hljs-comment">// RSI FSM</span>
<span class="hljs-keyword">case</span> (state)
    IDLE: <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (start) state &lt;= FILL_FIFO;  <span class="hljs-comment">// External trigger</span>
    <span class="hljs-keyword">end</span>
    
    FILL_FIFO: <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (fifo_full) state &lt;= READ_INIT;  <span class="hljs-comment">// Transition on data condition</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Other states...</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Clear conditional expressions for state changes</li>
<li>Explicit transition conditions for each state</li>
<li>Combination of external triggers and internal conditions</li>
<li>Deterministic progression through operational sequence</li>
<li>Straightforward relationship between conditions and transitions</li>
</ul>
</li>
<li>
<p><strong>Transition Trigger Categories</strong>:</p>
<ul>
<li>
<p><strong>External Control Triggers</strong>:</p>
<ul>
<li><code>start</code> signal initiates calculation sequence</li>
<li><code>new_price</code> indicates data availability</li>
<li>System-level control for orchestration</li>
</ul>
</li>
<li>
<p><strong>Data Status Conditions</strong>:</p>
<ul>
<li><code>fifo_full</code> indicates sufficient data for calculation</li>
<li><code>mem_count &gt;= 14</code> enables computation</li>
<li><code>fifo_empty</code> prevents underflow conditions</li>
</ul>
</li>
<li>
<p><strong>Processing Completion</strong>:</p>
<ul>
<li>Counter-based completion (<code>sample_cnt &lt; 19</code>)</li>
<li>Internal processing flags (<code>read_delay</code>)</li>
<li>Single-cycle operation completion</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>State Sequencing Patterns</strong>:</p>
<ul>
<li>
<p><strong>Linear Sequence</strong> (Moving Average FSM):</p>
<pre class="hljs"><code><div>IDLE  CALCULATE  DONE  IDLE
</div></code></pre>
<ul>
<li>Straightforward progression through states</li>
<li>Simple, predictable execution path</li>
<li>Minimal control logic complexity</li>
<li>Consistent operational behavior</li>
<li>Clear beginning and end points</li>
</ul>
</li>
<li>
<p><strong>Branching Sequences</strong> (RSI FSM):</p>
<pre class="hljs"><code><div>IDLE  FILL_FIFO  READ_INIT  COMPARE  READ_WAIT  DONE  IDLE
                                  ___________|
</div></code></pre>
<ul>
<li>Multiple possible paths through states</li>
<li>Conditional branches based on data conditions</li>
<li>Iterative processing loops for multiple samples</li>
<li>More complex but deterministic flow</li>
<li>Complete coverage of all processing requirements</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Transition Timing Control</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Single-cycle state</span>
READ_INIT: <span class="hljs-keyword">begin</span>
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (read_delay) <span class="hljs-keyword">begin</span>
        prev_price &lt;= price_out;
        read_delay &lt;= <span class="hljs-number">0</span>;
        state &lt;= COMPARE;  <span class="hljs-comment">// Immediate transition</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Data-dependent iteration</span>
COMPARE: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (sample_cnt &lt; <span class="hljs-number">19</span> &amp;&amp; !fifo_empty) <span class="hljs-keyword">begin</span>
        fifo_rd_en &lt;= <span class="hljs-number">1</span>;
        read_delay &lt;= <span class="hljs-number">1</span>;
        state &lt;= READ_WAIT;  <span class="hljs-comment">// Continue processing</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        state &lt;= DONE;  <span class="hljs-comment">// Exit when complete</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Explicit control of transition timing</li>
<li>Conditional progression based on data processing state</li>
<li>Clear exit conditions from iterative processes</li>
<li>Synchronization with data availability</li>
<li>Deterministic cycle count for operations</li>
</ul>
</li>
<li>
<p><strong>Default State Handling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">case</span> (state)
    <span class="hljs-comment">// State-specific logic</span>
    
    <span class="hljs-keyword">default</span>: state &lt;= IDLE;  <span class="hljs-comment">// Safe default transition</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Explicit handling of undefined or invalid states</li>
<li>Return to known state for recovery</li>
<li>Protection against unexpected conditions</li>
<li>Fault tolerance in state machine operation</li>
<li>Simplified verification of error recovery</li>
</ul>
</li>
<li>
<p><strong>Transition Gap Prevention</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// RSI FSM with default assignments</span>
done &lt;= <span class="hljs-number">0</span>;                 <span class="hljs-comment">// Default inactive</span>
fifo_wr_en &lt;= <span class="hljs-number">0</span>;           <span class="hljs-comment">// Default inactive</span>
fifo_rd_en &lt;= <span class="hljs-number">0</span>;           <span class="hljs-comment">// Default inactive</span>

<span class="hljs-keyword">case</span> (state)
    <span class="hljs-comment">// State-specific logic with selective overrides</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Default signal assignments before state-specific logic</li>
<li>Ensures complete signal definition in all states</li>
<li>Prevents inadvertent signal retention</li>
<li>Clean transitions between states</li>
<li>Predictable signal behavior during state changes</li>
</ul>
</li>
<li>
<p><strong>Transition Verification Approach</strong>:</p>
<ul>
<li>
<p><strong>Exhaustive Coverage</strong>:</p>
<ul>
<li>All possible state transitions defined</li>
<li>Each state has clear exit conditions</li>
<li>Complete state reachability</li>
</ul>
</li>
<li>
<p><strong>Deterministic Behavior</strong>:</p>
<ul>
<li>Repeatable execution sequences</li>
<li>Predictable response to inputs</li>
<li>Consistent operational flow</li>
</ul>
</li>
<li>
<p><strong>Cycle-Accurate Definition</strong>:</p>
<ul>
<li>Known number of cycles for each operation</li>
<li>Precise timing relationships</li>
<li>Synchronized transitions</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>These state transition management techniques create a robust control framework for the technical analysis system, ensuring proper sequencing of operations with deterministic behavior. The design emphasizes clarity, predictability, and reliability, with transition mechanisms tailored to the specific requirements of each FSM within the system.</p>
<h4 id="reset-strategy">Reset Strategy</h4>
<p>The technical analysis system implements a comprehensive reset strategy to ensure reliable initialization, consistent startup behavior, and robust operation. This strategy addresses both system-level and module-specific reset requirements.</p>
<p>Key aspects of the reset strategy include:</p>
<ol>
<li>
<p><strong>Asynchronous Reset Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
        state &lt;= IDLE;
        sum &lt;= <span class="hljs-number">0</span>;
        moving_avg &lt;= <span class="hljs-number">0</span>;
        done &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Normal operation</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Active-high reset signal (<code>rst</code>)</li>
<li>Asynchronous assertion (triggered immediately, regardless of clock)</li>
<li>Synchronous release (de-assertion synchronized to clock)</li>
<li>Immediate response to system reset</li>
<li>Predictable initialization behavior</li>
</ul>
</li>
<li>
<p><strong>Reset Distribution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Top-level reset distribution</span>
price_memory mem14 (
    <span class="hljs-variable">.rst</span>(rst),  <span class="hljs-comment">// Same reset signal to all modules</span>
    <span class="hljs-comment">// Other connections</span>
);

moving_average_fsm ma14 (
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-comment">// Other connections</span>
);

rsi_inc rsi14 (
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Common reset signal for all modules</li>
<li>Consistent reset timing across system</li>
<li>Simplified reset control</li>
<li>Synchronized initialization</li>
<li>Clean system-wide startup</li>
</ul>
</li>
<li>
<p><strong>Module-Specific Reset Actions</strong>:</p>
<ul>
<li>
<p><strong>Price Memory Reset</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    write_ptr &lt;= <span class="hljs-number">0</span>;        <span class="hljs-comment">// Reset pointers</span>
    read_ptr &lt;= <span class="hljs-number">0</span>;
    item_count &lt;= <span class="hljs-number">0</span>;       <span class="hljs-comment">// Clear counter</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Initialize memory management pointers</li>
<li>Clear item counter</li>
<li>Establish empty buffer condition</li>
<li>Memory contents implicitly undefined</li>
<li>Prepare for data acquisition</li>
</ul>
</li>
<li>
<p><strong>Moving Average FSM Reset</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    sum &lt;= <span class="hljs-number">0</span>;             <span class="hljs-comment">// Clear accumulators</span>
    moving_avg &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Reset outputs</span>
    done &lt;= <span class="hljs-number">0</span>;            <span class="hljs-comment">// Clear control signals</span>
    st &lt;= <span class="hljs-number">0</span>;              <span class="hljs-comment">// Return to idle state</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Clear calculation accumulators</li>
<li>Reset output registers</li>
<li>Deactivate control signals</li>
<li>Initialize to idle state</li>
<li>Prepare for new calculation sequence</li>
</ul>
</li>
<li>
<p><strong>RSI FSM Reset</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    state &lt;= IDLE;        <span class="hljs-comment">// Reset state machine</span>
    fifo_wr_en &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Clear control signals</span>
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    done &lt;= <span class="hljs-number">0</span>;
    rsi &lt;= <span class="hljs-number">0</span>;             <span class="hljs-comment">// Reset output</span>
    sample_cnt &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Clear counters</span>
    gain_sum &lt;= <span class="hljs-number">0</span>;        <span class="hljs-comment">// Reset accumulators</span>
    loss_sum &lt;= <span class="hljs-number">0</span>;
    prev_price &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Clear price registers</span>
    read_delay &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Reset flags</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Comprehensive register initialization</li>
<li>All counters and accumulators cleared</li>
<li>Control signals deactivated</li>
<li>Flags reset to inactive</li>
<li>Complete preparation for new calculation</li>
</ul>
</li>
<li>
<p><strong>Trading Decision Reset</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    buy  &lt;= <span class="hljs-number">0</span>;            <span class="hljs-comment">// Clear output signals</span>
    sell &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Deactivate trading signals</li>
<li>Simple reset for combinational logic</li>
<li>Safe initial state for system integration</li>
<li>Clean startup behavior</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Reset Signal Characteristics</strong>:</p>
<ul>
<li><strong>Active High</strong>: Asserted by driving to logical '1'</li>
<li><strong>Globally Distributed</strong>: Same signal to all modules</li>
<li><strong>Externally Generated</strong>: Provided from system level</li>
<li><strong>Asynchronous Assertion</strong>: Immediate effect regardless of clock</li>
<li><strong>Sufficient Duration</strong>: Multiple clock cycles for stable initialization</li>
</ul>
</li>
<li>
<p><strong>Reset Sequence Timing</strong>:</p>
<pre class="hljs"><code><div>rst \________________/
clk _/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_
                 |
                 V
            Reset captured
                 |
                 V
            All registers cleared
                 |
                 V
            System in known state
</div></code></pre>
<ul>
<li>Reset asserted for multiple clock cycles</li>
<li>All modules reset simultaneously</li>
<li>Synchronous operation begins after reset release</li>
<li>Clean transition to normal operation</li>
<li>Predictable startup behavior</li>
</ul>
</li>
<li>
<p><strong>Power-On Reset Considerations</strong>:</p>
<ul>
<li>External reset circuitry typically required</li>
<li>Reset signal held active during power stabilization</li>
<li>Release only after clock is stable</li>
<li>Sufficient duration to initialize all registers</li>
<li>Consistent with FPGA platform requirements</li>
</ul>
</li>
<li>
<p><strong>Reset Verification Approach</strong>:</p>
<ul>
<li>Reset applied at various operational phases</li>
<li>Verification of register initialization values</li>
<li>Confirmation of state machine reset to idle</li>
<li>Validation of signal deactivation</li>
<li>Testing of transition to normal operation</li>
</ul>
</li>
</ol>
<p>The reset strategy ensures that the technical analysis system starts from a known, stable state and can recover from error conditions. The approach emphasizes comprehensive initialization, consistent behavior across modules, and reliable operation after reset, creating a robust foundation for system operation.</p>
<h4 id="flag-and-control-signal-design">Flag and Control Signal Design</h4>
<p>The technical analysis system implements a comprehensive flag and control signal design strategy to manage system operation, coordinate between modules, and indicate status conditions. These signals create a robust communication framework that ensures proper system behavior.</p>
<p>Key aspects of the flag and control signal design include:</p>
<ol>
<li>
<p><strong>Signal Categorization</strong>:</p>
<ul>
<li><strong>Trigger Signals</strong>: Initiate operations or state transitions</li>
<li><strong>Status Flags</strong>: Indicate current system state or conditions</li>
<li><strong>Handshaking Signals</strong>: Coordinate between modules</li>
<li><strong>Control Outputs</strong>: Direct external system behavior</li>
<li><strong>Internal Flags</strong>: Manage module-specific operation</li>
</ul>
</li>
<li>
<p><strong>Primary Control Signals</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// External inputs</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_price;       <span class="hljs-comment">// New price available</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start;           <span class="hljs-comment">// Start calculation</span>

<span class="hljs-comment">// Internal triggers</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);  <span class="hljs-comment">// Calculation trigger</span>

<span class="hljs-comment">// Module-specific control</span>
<span class="hljs-keyword">reg</span> fifo_wr_en = <span class="hljs-number">0</span>;         <span class="hljs-comment">// FIFO write enable</span>
<span class="hljs-keyword">reg</span> fifo_rd_en = <span class="hljs-number">0</span>;         <span class="hljs-comment">// FIFO read enable</span>

<span class="hljs-comment">// System outputs</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy;             <span class="hljs-comment">// Buy signal</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell;            <span class="hljs-comment">// Sell signal</span>
</div></code></pre>
<ul>
<li>Clear purpose for each signal</li>
<li>Consistent naming convention</li>
<li>Appropriate signal direction</li>
<li>Explicit type (reg/wire)</li>
<li>Documented functionality</li>
</ul>
</li>
<li>
<p><strong>Status Flag Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Memory status flags</span>
<span class="hljs-keyword">assign</span> full = (item_count == DEPTH);   <span class="hljs-comment">// FIFO full flag</span>
<span class="hljs-keyword">assign</span> count = item_count;             <span class="hljs-comment">// FIFO count</span>

<span class="hljs-comment">// Calculation status</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done;             <span class="hljs-comment">// Calculation complete</span>

<span class="hljs-comment">// Internal status tracking</span>
<span class="hljs-keyword">reg</span> read_delay = <span class="hljs-number">0</span>;          <span class="hljs-comment">// FIFO read synchronization</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] sample_cnt = <span class="hljs-number">0</span>;    <span class="hljs-comment">// Sample counter</span>
</div></code></pre>
<ul>
<li>Direct mapping to system conditions</li>
<li>Clear relationship to operational state</li>
<li>Boolean logic for binary conditions</li>
<li>Counters for quantitative status</li>
<li>Explicit flag for critical conditions</li>
</ul>
</li>
<li>
<p><strong>Signal Timing Characteristics</strong>:</p>
<ul>
<li>
<p><strong>Level-Sensitive Control</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Signal active while condition true</span>
<span class="hljs-keyword">assign</span> memory_full = (mem_cnt == <span class="hljs-number">14</span>);
</div></code></pre>
<ul>
<li>Signal level directly reflects condition</li>
<li>Remains active while condition persists</li>
<li>Simple combinational implementation</li>
<li>Direct relationship to system state</li>
<li>Continuous status indication</li>
</ul>
</li>
<li>
<p><strong>Pulse-Based Signaling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// One-cycle pulse signal</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">case</span> (state)
        DONE: <span class="hljs-keyword">begin</span>
            done &lt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// Activate for one cycle</span>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>
            done &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">// Inactive in all other states</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endcase</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Signal active for exactly one clock cycle</li>
<li>Clean transitions for edge detection</li>
<li>Clear timing relationship to triggering event</li>
<li>Simplified downstream detection logic</li>
<li>Prevents multi-cycle activation issues</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Control Signal Generation Patterns</strong>:</p>
<ul>
<li>
<p><strong>State-Based Generation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Signal depends on current state</span>
fifo_rd_en &lt;= (state == COMPARE &amp;&amp; sample_cnt &lt; <span class="hljs-number">19</span> &amp;&amp; !fifo_empty);
</div></code></pre>
<ul>
<li>Direct relationship to state machine</li>
<li>Conditional activation based on state</li>
<li>Synchronized to clock edge</li>
<li>Clear timing relative to operations</li>
<li>Deterministic activation pattern</li>
</ul>
</li>
<li>
<p><strong>Condition-Based Generation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Signal active when condition met</span>
buy &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
</div></code></pre>
<ul>
<li>Direct mapping from conditions</li>
<li>Combinational logic with registered output</li>
<li>Immediate response to input changes</li>
<li>Clear relationship to system conditions</li>
<li>Simple implementation and verification</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Signal Coordination Techniques</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// RSI FSM internal coordination</span>
<span class="hljs-keyword">if</span> (read_delay) <span class="hljs-keyword">begin</span>
    curr_price &lt;= price_out;
    <span class="hljs-comment">// Process data...</span>
    read_delay &lt;= <span class="hljs-number">0</span>;
    state &lt;= COMPARE;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Explicit flags for operation sequencing</li>
<li>Clear handshaking between operations</li>
<li>Controlled timing relationships</li>
<li>Synchronization of data access</li>
<li>Deterministic operational flow</li>
</ul>
</li>
<li>
<p><strong>Default Signal Assignment</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Initialize to inactive</span>
fifo_wr_en &lt;= <span class="hljs-number">0</span>;
fifo_rd_en &lt;= <span class="hljs-number">0</span>;
done &lt;= <span class="hljs-number">0</span>;

<span class="hljs-comment">// Override in specific states</span>
<span class="hljs-keyword">case</span> (state)
    <span class="hljs-comment">// Selective activation</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Default inactive state for all control signals</li>
<li>Explicit activation in specific conditions</li>
<li>Prevents unintended signal persistence</li>
<li>Clean transition between states</li>
<li>Clear signal behavior in all conditions</li>
</ul>
</li>
<li>
<p><strong>Signal Routing Architecture</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Top-level signal connection</span>
<span class="hljs-keyword">wire</span> memory_full;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count;

price_memory mem14 (
    <span class="hljs-comment">// Connections</span>
    <span class="hljs-variable">.full</span>(memory_full),
    <span class="hljs-variable">.count</span>(count)
);

<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

moving_average_fsm ma14 (
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Direct signal routing where possible</li>
<li>Derived signals for specific conditions</li>
<li>Minimized signal transformation</li>
<li>Clear signal flow through system</li>
<li>Simplified timing analysis</li>
</ul>
</li>
<li>
<p><strong>Signal Specification Summary</strong>:</p>
<table>
<thead>
<tr>
<th>Signal Category</th>
<th>Examples</th>
<th>Implementation</th>
<th>Timing Characteristics</th>
</tr>
</thead>
<tbody>
<tr>
<td>External Inputs</td>
<td>new_price, start</td>
<td>Input ports</td>
<td>Asynchronous, externally timed</td>
</tr>
<tr>
<td>Trigger Signals</td>
<td>compute_enable, fifo_wr_en</td>
<td>Derived or state-based</td>
<td>One-cycle pulses</td>
</tr>
<tr>
<td>Status Flags</td>
<td>full, memory_full</td>
<td>Condition-based assignment</td>
<td>Level-sensitive, condition-based</td>
</tr>
<tr>
<td>Handshaking</td>
<td>done, read_delay</td>
<td>State-based with reset</td>
<td>One-cycle pulses or state flags</td>
</tr>
<tr>
<td>Control Outputs</td>
<td>buy, sell</td>
<td>Registered condition evaluation</td>
<td>Level-sensitive with clean edges</td>
</tr>
<tr>
<td>Counters</td>
<td>item_count, sample_cnt</td>
<td>Incremental with conditions</td>
<td>Value-based status</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>This flag and control signal design creates a robust communication framework within the technical analysis system, ensuring proper coordination between modules, clear operational flow, and reliable system behavior. The approach emphasizes explicit control relationships, deterministic timing, and simplified integration.</p>
<h3 id="system-integration">System Integration</h3>
<h4 id="clock-domain-management">Clock Domain Management</h4>
<p>The technical analysis system implements a single clock domain strategy to simplify timing analysis, ensure deterministic behavior, and eliminate synchronization issues. This approach provides a solid foundation for reliable system operation.</p>
<p>Key aspects of the clock domain management include:</p>
<ol>
<li>
<p><strong>Single Clock Architecture</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Module port declarations</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,  <span class="hljs-comment">// System clock</span>

<span class="hljs-comment">// Clock distribution through hierarchy</span>
price_memory mem14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-comment">// Other connections</span>
);

moving_average_fsm ma14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Common clock signal throughout system</li>
<li>Direct distribution without gating or division</li>
<li>Synchronized operation across all modules</li>
<li>Simplified timing analysis</li>
<li>No clock domain crossing complexity</li>
</ul>
</li>
<li>
<p><strong>Clock Characteristics</strong>:</p>
<ul>
<li><strong>Frequency</strong>: Design validated at 100 MHz (10ns period)</li>
<li><strong>Duty Cycle</strong>: 50% (standard for FPGA designs)</li>
<li><strong>Global Routing</strong>: Utilizes dedicated clock resources</li>
<li><strong>Edge Usage</strong>: Rising edge for all sequential logic</li>
<li><strong>Stability Requirements</strong>: Standard jitter/skew tolerance</li>
</ul>
</li>
<li>
<p><strong>Sequential Element Synchronization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// All registers use same clock edge</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Normal operation</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Universal posedge clk triggering</li>
<li>Consistent clock polarity</li>
<li>Synchronized state transitions</li>
<li>Aligned data capture</li>
<li>Predictable timing relationships</li>
</ul>
</li>
<li>
<p><strong>System Timing Relationships</strong>:</p>
<pre class="hljs"><code><div>clk    _/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_

new_price ___/\___________________________/\___

write_en  ___/\___________________________/\___

mem_full  _________________/

start     _________________/\____________________

done      ___________________________/\___________
</div></code></pre>
<ul>
<li>Synchronized signal relationships</li>
<li>Predictable cycle counts between events</li>
<li>Deterministic operational flow</li>
<li>Clean signal transitions</li>
<li>Explicit timing relationships</li>
</ul>
</li>
<li>
<p><strong>Input Handling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Direct sampling of input signals</span>
<span class="hljs-keyword">if</span> (new_price) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Process new price</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>External inputs sampled on clock edge</li>
<li>No explicit synchronization logic</li>
<li>Assumes inputs stable during sampling</li>
<li>Simplified interface design</li>
<li>Potential metastability risk for truly asynchronous inputs</li>
</ul>
</li>
<li>
<p><strong>Alternative Approaches Considered</strong>:</p>
<ul>
<li>
<p><strong>Multiple Clock Domains</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Not implemented but considered</span>
<span class="hljs-keyword">module</span> dual_clock_system (
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk_fast,  <span class="hljs-comment">// Higher frequency for calculation</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk_slow,  <span class="hljs-comment">// Lower frequency for interface</span>
    <span class="hljs-comment">// Other ports</span>
);

<span class="hljs-comment">// Would require synchronization:</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sync_req;
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk_fast) <span class="hljs-keyword">begin</span>
    sync_req &lt;= {sync_req[<span class="hljs-number">0</span>], req};  <span class="hljs-comment">// 2-stage synchronizer</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Rejected due to:
<ul>
<li>Increased complexity</li>
<li>Synchronization overhead</li>
<li>Potential metastability issues</li>
<li>More complex verification</li>
<li>Limited performance benefit for application</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Gating</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Not implemented but considered</span>
<span class="hljs-keyword">wire</span> gated_clk = clk &amp; enable;  <span class="hljs-comment">// Simple clock gating</span>
</div></code></pre>
<ul>
<li>Rejected due to:
<ul>
<li>Potential glitch issues</li>
<li>Non-standard practice for FPGAs</li>
<li>Clock skew concerns</li>
<li>Verification complexity</li>
<li>Limited power benefit in FPGA</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Considerations for System Integration</strong>:</p>
<ul>
<li>
<p><strong>External Interface Timing</strong>:</p>
<ul>
<li>Input synchronization may be required at system boundary</li>
<li>Double-flop synchronizers for truly asynchronous inputs</li>
<li>Output hold time guarantees for external systems</li>
</ul>
</li>
<li>
<p><strong>Integration with Multi-Clock Systems</strong>:</p>
<ul>
<li>Interface registers for crossing to different domains</li>
<li>Handshaking protocols for safe data transfer</li>
<li>Gray-coded counters for multi-bit transfers</li>
</ul>
</li>
<li>
<p><strong>Future Extension Options</strong>:</p>
<ul>
<li>Framework supports adding clock domain crossing if needed</li>
<li>Modular design allows selective domain assignment</li>
<li>Clear interfaces simplify future synchronization</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Resource Management</strong>:</p>
<ul>
<li><strong>FPGA-Specific Considerations</strong>:
<ul>
<li>Utilization of dedicated clock networks</li>
<li>Appropriate buffering for clock distribution</li>
<li>Minimized clock skew through design practices</li>
<li>Clock region planning for larger implementations</li>
<li>Power optimization through proper resource usage</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The single clock domain approach provides significant advantages for this application:</p>
<ul>
<li>Simplified timing analysis and verification</li>
<li>Elimination of synchronization overhead</li>
<li>Deterministic behavior and cycle counts</li>
<li>Reduced risk of timing-related bugs</li>
<li>Straightforward system integration</li>
</ul>
<p>This approach aligns with the performance requirements of the technical analysis system, where calculation frequency far exceeds market data update rates, making the additional complexity of multiple clock domains unnecessary for this application.</p>
<h4 id="parallel-processing-approach">Parallel Processing Approach</h4>
<p>The technical analysis system implements a parallel processing approach to efficiently calculate multiple technical indicators simultaneously. This approach maximizes throughput, optimizes resource utilization, and creates a scalable architecture for system extension.</p>
<p>Key aspects of the parallel processing approach include:</p>
<ol>
<li>
<p><strong>Concurrent Indicator Calculation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Simultaneous instantiation and operation</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

<span class="hljs-comment">// Moving Average calculation</span>
moving_average_fsm ma14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),
    <span class="hljs-variable">.done</span>(ma_done)
);

<span class="hljs-comment">// RSI calculation (parallel operation)</span>
rsi_inc rsi14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.mem_full</span>(mem_full),
    <span class="hljs-variable">.mem_count</span>(mem_cnt),
    <span class="hljs-variable">.rsi</span>(rsi),
    <span class="hljs-variable">.done</span>(rsi_done)
);
</div></code></pre>
<ul>
<li>Independent calculation modules</li>
<li>Simultaneous operation on same clock cycle</li>
<li>Common trigger signal for synchronization</li>
<li>Parallel data paths for each indicator</li>
<li>Maximum computational throughput</li>
</ul>
</li>
<li>
<p><strong>Shared Data Architecture</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Common price memory shared by indicators</span>
price_memory mem14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.wr_en</span>(new_price),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.full</span>(mem_full),
    <span class="hljs-variable">.count</span>(count)
);
</div></code></pre>
<ul>
<li>Centralized price history storage</li>
<li>Common access to newest and oldest prices</li>
<li>Shared memory resource for efficiency</li>
<li>Consistent data source for all calculations</li>
<li>Elimination of data duplication</li>
</ul>
</li>
<li>
<p><strong>Independent Calculation Paths</strong>:</p>
<ul>
<li>Each indicator module contains:
<ul>
<li>Dedicated state machine for control</li>
<li>Private registers for calculation state</li>
<li>Isolated computational logic</li>
<li>Independent completion signaling</li>
<li>Module-specific optimization</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Parallel Dataflow Architecture</strong>:</p>
<pre class="hljs"><code><div>                       Price Data
                           
                           
                 
                     Price Memory     
                 
                           
                
                                     
                                     
          
        Moving Average       RSI Calculator 
             FSM                            
          
                                     
                                     
                   
              MA                  RSI    
            Result              Result   
                   
                                     
                
                          
                          
                 
                  Trading Decision 
                 
</div></code></pre>
<ul>
<li>Clean separation of calculation paths</li>
<li>Parallel data flow through system</li>
<li>Concurrent operation at each stage</li>
<li>Clear data dependencies</li>
<li>Optimal resource utilization</li>
</ul>
</li>
<li>
<p><strong>Synchronization Points</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Common trigger for indicators</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

<span class="hljs-comment">// Independent completion signals</span>
<span class="hljs-keyword">wire</span> ma_done;  <span class="hljs-comment">// From MA module</span>
<span class="hljs-keyword">wire</span> rsi_done; <span class="hljs-comment">// From RSI module</span>

<span class="hljs-comment">// Trading decision uses completed results</span>
trading_decision dec (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.price_now</span>(price_in),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),  <span class="hljs-comment">// From MA calculation</span>
    <span class="hljs-variable">.rsi</span>(rsi),                <span class="hljs-comment">// From RSI calculation</span>
    <span class="hljs-variable">.buy</span>(buy),
    <span class="hljs-variable">.sell</span>(sell)
);
</div></code></pre>
<ul>
<li>Synchronous initiation of calculations</li>
<li>Independent completion timing</li>
<li>Readiness indicated by done signals</li>
<li>Downstream modules use completed results</li>
<li>Clean coordination without tight coupling</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Efficiency</strong>:</p>
<ul>
<li>
<p><strong>Computational Resources</strong>:</p>
<ul>
<li>Independent arithmetic units for each indicator</li>
<li>Dedicated state machines for control</li>
<li>Selective application of optimization techniques</li>
</ul>
</li>
<li>
<p><strong>Memory Resources</strong>:</p>
<ul>
<li>Shared price history buffer</li>
<li>Dedicated registers for calculation state</li>
<li>Optimized register width for each application</li>
</ul>
</li>
<li>
<p><strong>Control Resources</strong>:</p>
<ul>
<li>Common triggering logic</li>
<li>Separate completion signaling</li>
<li>Independent state management</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Scalability Characteristics</strong>:</p>
<ul>
<li>
<p><strong>Horizontal Scaling</strong>:</p>
<ul>
<li>Additional indicators can be added in parallel</li>
<li>Common price memory architecture</li>
<li>Independent calculation modules</li>
<li>Minimal modification to existing components</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding new indicator (example)</span>
macd_calculator macd_inst (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.macd_line</span>(macd),
    <span class="hljs-variable">.signal_line</span>(signal),
    <span class="hljs-variable">.done</span>(macd_done)
);
</div></code></pre>
</li>
<li>
<p><strong>Vertical Scaling</strong>:</p>
<ul>
<li>Multiple instrument tracking by replicating structure</li>
<li>Array of parallel systems for different symbols</li>
<li>Shared control with independent data paths</li>
<li>Linear resource scaling with instrument count</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Performance Characteristics</strong>:</p>
<ul>
<li>
<p><strong>Latency Impact</strong>:</p>
<ul>
<li>Parallel processing does not reduce latency of individual calculations</li>
<li>Overall system latency determined by longest path (typically RSI)</li>
<li>Consistent cycle count regardless of parallelism</li>
</ul>
</li>
<li>
<p><strong>Throughput Enhancement</strong>:</p>
<ul>
<li>Multiple indicators calculated per clock cycle</li>
<li>Overall system throughput significantly increased</li>
<li>Maximum data processing efficiency</li>
<li>Optimal utilization of clock cycles</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>This parallel processing approach maximizes the computational efficiency of the technical analysis system, enabling simultaneous calculation of multiple indicators without increasing latency. The architecture provides a scalable foundation for extension with additional indicators while maintaining deterministic timing and efficient resource utilization.</p>
<h4 id="synchronous-design-principles">Synchronous Design Principles</h4>
<p>The technical analysis system implements a thoroughly synchronous design approach, following best practices for digital hardware implementation. This approach ensures reliable operation, simplified timing analysis, and robust system behavior.</p>
<p>Key synchronous design principles include:</p>
<ol>
<li>
<p><strong>Clock-Driven Sequential Logic</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// All sequential elements synchronized to clock</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Normal operation</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>All state changes occur on clock edges</li>
<li>Consistent clock edge usage (rising edge)</li>
<li>No asynchronous state updates (except reset)</li>
<li>Predictable timing relationships</li>
<li>Clean synchronization boundaries</li>
</ul>
</li>
<li>
<p><strong>Registered Outputs</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Registered output signals</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        moving_avg &lt;= <span class="hljs-number">0</span>;
        done &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Update logic with registered outputs</span>
        moving_avg &lt;= sum / WINDOW;
        done &lt;= (state == DONE);
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>All outputs driven by registers</li>
<li>Clean output timing</li>
<li>Glitch-free external interfaces</li>
<li>Predictable setup/hold timing</li>
<li>Simplified timing constraints</li>
</ul>
</li>
<li>
<p><strong>Synchronous State Machines</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// State transition on clock edge</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        state &lt;= IDLE;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            <span class="hljs-comment">// Next state logic</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>State changes only on clock edges</li>
<li>Deterministic state sequencing</li>
<li>Clear operational flow</li>
<li>Simplified timing analysis</li>
<li>Reduced risk of timing hazards</li>
</ul>
</li>
<li>
<p><strong>Two-Process State Machine Model</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// State register process</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        state &lt;= IDLE;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        state &lt;= next_state;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Next state &amp; output logic process</span>
<span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Default assignments</span>
    next_state = state;
    
    <span class="hljs-keyword">case</span> (state)
        <span class="hljs-comment">// State-specific logic</span>
    <span class="hljs-keyword">endcase</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Clear separation of state register and combinational logic</li>
<li>Simplified analysis and verification</li>
<li>Consistent design pattern</li>
<li>Standard synthesis optimization</li>
<li>Readable code structure</li>
</ul>
</li>
<li>
<p><strong>Synchronous Memory Access</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Synchronous write, asynchronous read</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
        mem[write_ptr] &lt;= new_price;
        <span class="hljs-comment">// Pointer update logic</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Asynchronous read output</span>
<span class="hljs-keyword">assign</span> oldest_price = mem[read_ptr];
</div></code></pre>
<ul>
<li>Memory writes synchronized to clock</li>
<li>Clean timing for write operations</li>
<li>Pointer updates on clock edge</li>
<li>Consistent memory update timing</li>
<li>Standard FPGA memory access pattern</li>
</ul>
</li>
<li>
<p><strong>Input Sampling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Synchronous sampling of inputs</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (new_price) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Process using sampled input</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>External inputs sampled on clock edge</li>
<li>Stable input values during processing</li>
<li>Consistent timing reference</li>
<li>Simplified input handling</li>
<li>Deterministic behavior for changing inputs</li>
</ul>
</li>
<li>
<p><strong>Single-Cycle Operations vs. Multi-Cycle Operations</strong>:</p>
<ul>
<li>
<p><strong>Single-Cycle</strong> (implemented):</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Complete operation in one cycle</span>
sum &lt;= sum + new_price - oldest_price;
moving_avg &lt;= sum / WINDOW;
</div></code></pre>
<ul>
<li>Simplifies control logic</li>
<li>Reduces state machine complexity</li>
<li>Minimizes latency</li>
<li>Clear timing boundaries</li>
<li>Straightforward verification</li>
</ul>
</li>
<li>
<p><strong>Multi-Cycle</strong> (alternative approach):</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Multi-cycle division operation</span>
<span class="hljs-keyword">case</span> (div_state)
    <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>
        remainder &lt;= sum;
        quotient &lt;= <span class="hljs-number">0</span>;
        count &lt;= <span class="hljs-number">5</span>;  <span class="hljs-comment">// log2(WINDOW) iterations</span>
        div_state &lt;= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">end</span>
    <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Division algorithm steps</span>
        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)
            div_state &lt;= <span class="hljs-number">2</span>;
        <span class="hljs-keyword">else</span>
            count &lt;= count - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">end</span>
    <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
        moving_avg &lt;= quotient;
        div_state &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>More complex control</li>
<li>Potentially more efficient for complex operations</li>
<li>Explicit cycle counting</li>
<li>Extended latency</li>
<li>More involved verification</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Integrity</strong>:</p>
<ul>
<li>Single clock domain for all sequential logic</li>
<li>No gated clocks or derived clocks</li>
<li>Global clock distribution</li>
<li>Consistent clocking scheme</li>
<li>Elimination of domain crossing issues</li>
</ul>
</li>
<li>
<p><strong>Timing Path Management</strong>:</p>
<ul>
<li>Register-to-register paths for critical timing</li>
<li>Balanced logic depth between registers</li>
<li>Critical path optimization</li>
<li>Predictable timing closure</li>
<li>Margin for implementation variations</li>
</ul>
</li>
</ol>
<p>These synchronous design principles create a robust foundation for the technical analysis system, ensuring reliable operation with deterministic timing. The approach follows standard best practices for digital hardware design, resulting in a system that is straightforward to verify, synthesize, and integrate.</p>
<h4 id="interface-definition-standards">Interface Definition Standards</h4>
<p>The technical analysis system implements consistent interface definition standards across all modules, creating clear communication boundaries, simplified integration, and maintainable code. These standards ensure proper interaction between components and establish a foundation for system extension.</p>
<p>Key interface definition standards include:</p>
<ol>
<li>
<p><strong>Port Declaration Organization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,    <span class="hljs-comment">// Parameters first</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Clock and reset signals first</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Control inputs</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start,
    
    <span class="hljs-comment">// Data inputs</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    
    <span class="hljs-comment">// Data outputs</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    
    <span class="hljs-comment">// Control outputs</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
</div></code></pre>
<ul>
<li>Consistent port ordering across modules</li>
<li>Logical grouping by signal function</li>
<li>Clock and reset signals first</li>
<li>Control signals before data signals</li>
<li>Inputs before outputs</li>
<li>Clear width specification for multi-bit signals</li>
</ul>
</li>
<li>
<p><strong>Parameter Definition Standards</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,    <span class="hljs-comment">// Buffer depth</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>        <span class="hljs-comment">// Data width</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<ul>
<li>Parameters precede port declarations</li>
<li>Default values provided for all parameters</li>
<li>Clear naming reflecting parameter purpose</li>
<li>Consistent naming across modules</li>
<li>Descriptive comments for documentation</li>
</ul>
</li>
<li>
<p><strong>Signal Direction Clarity</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Explicit direction for all ports</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,          <span class="hljs-comment">// Input signal, wire type</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum,   <span class="hljs-comment">// Output signal, register type</span>
<span class="hljs-keyword">inout</span> <span class="hljs-keyword">tri</span> data_bus       <span class="hljs-comment">// Bidirectional signal (if used)</span>
</div></code></pre>
<ul>
<li>Explicit direction for all ports (input/output/inout)</li>
<li>Clear type specification (wire/reg)</li>
<li>Width specification for multi-bit signals</li>
<li>Consistency in type usage</li>
<li>Adherence to hardware requirements</li>
</ul>
</li>
<li>
<p><strong>Interface Signal Categories</strong>:</p>
<ul>
<li>
<p><strong>Clock and Reset</strong>:</p>
<ul>
<li><code>clk</code>: System clock (rising edge active)</li>
<li><code>rst</code>: Asynchronous reset (active high)</li>
</ul>
</li>
<li>
<p><strong>Control Signals</strong>:</p>
<ul>
<li><code>start</code>, <code>new_price</code>: Trigger signals (one-cycle pulses)</li>
<li><code>done</code>: Completion indicator (one-cycle pulse)</li>
</ul>
</li>
<li>
<p><strong>Data Signals</strong>:</p>
<ul>
<li><code>price_in</code>, <code>oldest_price</code>: Price data values</li>
<li><code>moving_avg</code>, <code>rsi</code>: Calculation results</li>
</ul>
</li>
<li>
<p><strong>Status Signals</strong>:</p>
<ul>
<li><code>full</code>, <code>memory_full</code>: Condition indicators</li>
<li><code>count</code>, <code>mem_cnt</code>: Quantitative status</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Module Header Documentation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// ==========================================================================</span>
<span class="hljs-comment">// moving_average_fsm.v</span>
<span class="hljs-comment">// 20-period rolling mean (integer division)</span>
<span class="hljs-comment">// ==========================================================================</span>

<span class="hljs-comment">// ==========================================================================</span>
<span class="hljs-comment">// trading_decision.v</span>
<span class="hljs-comment">// Simple rule: BUY when price&gt;MA &amp; RSI&lt;30, SELL when price&lt;MA &amp; RSI&gt;70</span>
<span class="hljs-comment">// ==========================================================================</span>
</div></code></pre>
<ul>
<li>Consistent header format across modules</li>
<li>Clear module identification</li>
<li>Concise functional description</li>
<li>Key parameters or characteristics</li>
<li>Separation from implementation details</li>
</ul>
</li>
<li>
<p><strong>Interface Timing Specification</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Timing implied through implementation</span>

<span class="hljs-comment">// Input sampling on clock edge</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Process triggered by start signal</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Output generation on clock edge</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    done &lt;= (state == DONE);  <span class="hljs-comment">// One-cycle pulse</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Clear timing relationships through code structure</li>
<li>Consistent interpretation across modules</li>
<li>Synchronous interface timing</li>
<li>Edge-triggered control signals</li>
<li>Deterministic input/output behavior</li>
</ul>
</li>
<li>
<p><strong>Signal Naming Conventions</strong>:</p>
<ul>
<li>
<p><strong>Clock and Reset</strong>:</p>
<ul>
<li><code>clk</code>: System clock</li>
<li><code>rst</code>: Reset signal</li>
</ul>
</li>
<li>
<p><strong>Control Signals</strong>:</p>
<ul>
<li><code>start</code>, <code>done</code>: Capitalized verbs or states</li>
<li><code>wr_en</code>, <code>rd_en</code>: Action-based abbreviations</li>
</ul>
</li>
<li>
<p><strong>Data Signals</strong>:</p>
<ul>
<li><code>price_in</code>, <code>oldest_price</code>: Descriptive of content</li>
<li><code>moving_avg</code>, <code>rsi</code>: Result identification</li>
</ul>
</li>
<li>
<p><strong>Internal Signals</strong>:</p>
<ul>
<li><code>state</code>, <code>st</code>: State registers</li>
<li><code>sum</code>, <code>gain_sum</code>: Accumulator identification</li>
</ul>
</li>
<li>
<p><strong>Counter/Pointer Signals</strong>:</p>
<ul>
<li><code>write_ptr</code>, <code>read_ptr</code>: Function-based naming</li>
<li><code>item_count</code>, <code>sample_cnt</code>: Quantity indication</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Module Instantiation Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Named port connection for clarity</span>
moving_average_fsm ma14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),
    <span class="hljs-variable">.done</span>(ma_done)
);

<span class="hljs-comment">// Parameter override when needed</span>
trading_decision #(
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">25</span>),     <span class="hljs-comment">// Override default</span>
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">75</span>)
) decision_module (
    <span class="hljs-comment">// Port connections</span>
);
</div></code></pre>
<ul>
<li>Named port connections for readability</li>
<li>Explicit parameter overrides when needed</li>
<li>Consistent instantiation style</li>
<li>Instance names reflecting function</li>
<li>Clear relationship to module definition</li>
</ul>
</li>
<li>
<p><strong>Interface Consistency Between Modules</strong>:</p>
<ul>
<li>Common signal naming across module boundaries</li>
<li>Consistent bit widths for shared signals</li>
<li>Compatible timing characteristics</li>
<li>Aligned control signal behavior</li>
<li>Standardized reset response</li>
</ul>
</li>
</ol>
<p>These interface definition standards create clear, consistent boundaries between modules in the technical analysis system. The approach enhances code readability, simplifies integration, and establishes a foundation for maintainable and extensible design.</p>
<h4 id="timing-closure-strategies">Timing Closure Strategies</h4>
<p>The technical analysis system implements several timing closure strategies to ensure reliable operation across various implementation scenarios. These strategies address critical timing paths, establish margins for variability, and enable consistent performance on FPGA platforms.</p>
<p>Key timing closure strategies include:</p>
<ol>
<li>
<p><strong>Register-to-Register Paths</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Registered inputs and outputs</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Input sampling</span>
    curr_price &lt;= price_out;
    
    <span class="hljs-comment">// Processing</span>
    <span class="hljs-keyword">if</span> (price_out &gt; prev_price)
        gain_sum &lt;= gain_sum + (price_out - prev_price);
    
    <span class="hljs-comment">// Output registration</span>
    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Sequential elements on both ends of logic paths</li>
<li>Synchronous capture of inputs</li>
<li>Registered outputs for clean timing</li>
<li>Clear timing boundaries</li>
<li>Predictable path delays</li>
</ul>
</li>
<li>
<p><strong>Logic Depth Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Balanced logic depth between registers</span>

<span class="hljs-comment">// Moderate complexity in single cycle:</span>
sum &lt;= sum + new_price - oldest_price;
moving_avg &lt;= sum / WINDOW;

<span class="hljs-comment">// Alternative with pipelining (not implemented):</span>
<span class="hljs-comment">// Cycle 1:</span>
sum_temp &lt;= sum + new_price - oldest_price;
<span class="hljs-comment">// Cycle 2:</span>
sum &lt;= sum_temp;
moving_avg &lt;= sum_temp / WINDOW;
</div></code></pre>
<ul>
<li>Reasonable combinational depth between registers</li>
<li>Balanced complexity for critical operations</li>
<li>Operation partitioning when necessary</li>
<li>Consideration of synthesis optimization</li>
<li>Target technology capabilities factored in</li>
</ul>
</li>
<li>
<p><strong>Critical Path Identification</strong>:</p>
<ul>
<li>
<p><strong>Primary Critical Paths</strong>:</p>
<ol>
<li>Division Operation: <code>moving_avg &lt;= sum / WINDOW;</code></li>
<li>RSI Calculation: <code>rsi &lt;= (100 * gain_sum) / (gain_sum + loss_sum);</code></li>
<li>Comparison Logic: <code>buy &lt;= (price_now &gt; moving_avg[15:0]) &amp;&amp; (rsi &lt; BUY_RSI_THR);</code></li>
</ol>
</li>
<li>
<p><strong>Mitigation Approaches</strong>:</p>
<ul>
<li>Wide registers to prevent overflow issues</li>
<li>Constant divisors for optimization</li>
<li>Simple comparison logic</li>
<li>Minimal arithmetic complexity</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Frequency Selection</strong>:</p>
<ul>
<li>Target frequency: 100 MHz (10ns period)</li>
<li>Provides sufficient margin for critical paths</li>
<li>Accommodates synthesis and implementation variations</li>
<li>Realistic for target FPGA platforms</li>
<li>Exceeds requirements for market data processing</li>
</ul>
</li>
<li>
<p><strong>Synthesis Optimization Directives</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Synthesis attributes (example)</span>
(* use_dsp = <span class="hljs-string">&quot;yes&quot;</span> *) <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum;  <span class="hljs-comment">// Hint for DSP usage</span>

<span class="hljs-comment">// Timing constraints (in constraint file)</span>
<span class="hljs-comment">// create_clock -period 10.000 -name clk [get_ports clk]</span>
<span class="hljs-comment">// set_input_delay -clock clk 2.000 [get_ports {new_price*}]</span>
<span class="hljs-comment">// set_output_delay -clock clk 2.000 [get_ports {moving_avg* rsi* buy sell}]</span>
</div></code></pre>
<ul>
<li>Synthesis attributes for critical components</li>
<li>Explicit timing constraints</li>
<li>Reasonable input/output delays</li>
<li>Clock definition with appropriate period</li>
<li>Path-specific constraints when needed</li>
</ul>
</li>
<li>
<p><strong>Reset Path Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Asynchronous reset with synchronous release</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Normal operation</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Standard asynchronous reset pattern</li>
<li>Clear reset path for all registers</li>
<li>Synchronous release for stability</li>
<li>Reset tree optimization through synthesis</li>
<li>Predictable reset behavior</li>
</ul>
</li>
<li>
<p><strong>Timing Analysis Approach</strong>:</p>
<ul>
<li>
<p><strong>Static Timing Analysis (STA)</strong>:</p>
<ul>
<li>Path-based analysis for worst-case scenarios</li>
<li>Setup time verification for maximum path delay</li>
<li>Hold time verification for minimum path delay</li>
<li>Clock-to-output timing for interface signals</li>
<li>Input-to-clock timing for external interfaces</li>
</ul>
</li>
<li>
<p><strong>Critical Path Analysis</strong>:</p>
<ul>
<li>Identification of longest delay paths</li>
<li>Focused optimization for critical paths</li>
<li>Margin assessment for implementation variables</li>
<li>Technology-specific timing consideration</li>
<li>Corner case analysis</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Considerations</strong>:</p>
<ul>
<li>Single clock domain eliminates crossing issues</li>
<li>Consistent clock distribution network</li>
<li>Minimized clock skew through proper constraints</li>
<li>Global clock usage for optimal distribution</li>
<li>Avoidance of derived or gated clocks</li>
</ul>
</li>
<li>
<p><strong>Implementation Margin Strategy</strong>:</p>
<ul>
<li>Target timing closure at 120-130% of required frequency</li>
<li>Accommodation for implementation variables</li>
<li>Margin for temperature and voltage variation</li>
<li>Allowance for tool and process differences</li>
<li>Robust operation across conditions</li>
</ul>
</li>
<li>
<p><strong>Placement and Routing Considerations</strong>:</p>
<ul>
<li>Logical grouping of related logic</li>
<li>Minimized interconnect delays</li>
<li>Balanced resource utilization</li>
<li>Area constraints for critical components</li>
<li>Floorplanning guidance for complex implementations</li>
</ul>
</li>
</ol>
<p>These timing closure strategies create a robust implementation foundation that enables reliable operation across various FPGA platforms and operating conditions. The approach emphasizes clear timing boundaries, balanced logic complexity, and appropriate margins for variability.</p>
<h4 id="resource-sharing-approaches">Resource Sharing Approaches</h4>
<p>The technical analysis system implements strategic resource sharing approaches to optimize FPGA utilization while maintaining performance and functionality. These approaches balance sharing opportunities with parallel processing requirements to create an efficient implementation.</p>
<p>Key resource sharing approaches include:</p>
<ol>
<li>
<p><strong>Shared Price Memory</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Single price memory module shared by indicators</span>
price_memory mem14 (
    <span class="hljs-comment">// Connections for module access</span>
);

<span class="hljs-comment">// Common signals derived from shared memory</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);
<span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] oldest_price;  <span class="hljs-comment">// From memory to both modules</span>
</div></code></pre>
<ul>
<li>Central price history storage</li>
<li>Eliminates duplicate memory structures</li>
<li>Common access for both indicator calculations</li>
<li>Consistent data view across modules</li>
<li>Efficient memory resource utilization</li>
</ul>
</li>
<li>
<p><strong>Dedicated Calculation Engines</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Independent calculation modules</span>
moving_average_fsm ma14 (
    <span class="hljs-comment">// Connections for MA calculation</span>
);

rsi_inc rsi14 (
    <span class="hljs-comment">// Connections for RSI calculation</span>
);
</div></code></pre>
<ul>
<li>Separate processing modules for different indicators</li>
<li>Independent state machines and control logic</li>
<li>Parallel calculation for maximum throughput</li>
<li>Optimized implementation for each algorithm</li>
<li>Clear functional separation</li>
</ul>
</li>
<li>
<p><strong>Input Path Sharing</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Common input path for all modules</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_in,     <span class="hljs-comment">// Top-level input</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_price,           <span class="hljs-comment">// Top-level strobe</span>

<span class="hljs-comment">// Direct connection to multiple modules</span>
price_memory mem14 (
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.wr_en</span>(new_price),
    <span class="hljs-comment">// Other connections</span>
);

moving_average_fsm ma14 (
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Single input interface at system boundary</li>
<li>Direct distribution to relevant modules</li>
<li>No input buffering or replication</li>
<li>Consistent timing for all components</li>
<li>Simplified input handling</li>
</ul>
</li>
<li>
<p><strong>Control Signal Distribution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Derived control signals distributed to modules</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

<span class="hljs-comment">// Signal drives multiple modules</span>
moving_average_fsm ma14 (
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);

rsi_inc rsi14 (
    <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Common triggering conditions</li>
<li>Centralized condition evaluation</li>
<li>Distributed control to multiple modules</li>
<li>Synchronized operation</li>
<li>Reduced control logic duplication</li>
</ul>
</li>
<li>
<p><strong>Module-Specific Resource Allocation</strong>:</p>
<ul>
<li>
<p><strong>Arithmetic Resources</strong>:</p>
<ul>
<li>Dedicated arithmetic units for each indicator</li>
<li>Independent accumulators and registers</li>
<li>Parallel calculation capability</li>
<li>Optimized implementation for each algorithm</li>
<li>Clear performance isolation</li>
</ul>
</li>
<li>
<p><strong>Memory Resources</strong>:</p>
<ul>
<li>Shared price history buffer</li>
<li>Dedicated calculation state registers</li>
<li>Optimized register width for each application</li>
<li>Efficient FPGA memory utilization</li>
<li>Balance between sharing and parallelism</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Resource Sharing Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Resource Type</th>
<th>Sharing Approach</th>
<th>Rationale</th>
</tr>
</thead>
<tbody>
<tr>
<td>Price Memory</td>
<td>Fully Shared</td>
<td>Common data, single source of truth</td>
</tr>
<tr>
<td>Calculation Logic</td>
<td>Dedicated</td>
<td>Different algorithms, parallel processing</td>
</tr>
<tr>
<td>Input Interface</td>
<td>Shared Distribution</td>
<td>Common external interface, multiple users</td>
</tr>
<tr>
<td>Control Generation</td>
<td>Centralized, Distributed</td>
<td>Common trigger conditions, separate control</td>
</tr>
<tr>
<td>State Machines</td>
<td>Dedicated</td>
<td>Independent operation, different requirements</td>
</tr>
<tr>
<td>Output Generation</td>
<td>Dedicated</td>
<td>Separate results, parallel generation</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Alternative Approaches Considered</strong>:</p>
<ul>
<li>
<p><strong>Shared Arithmetic Units</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Not implemented:</span>
<span class="hljs-keyword">module</span> shared_arithmetic_unit (
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> select,  <span class="hljs-comment">// 0: MA, 1: RSI</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] operand_a,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] operand_b,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> operation,  <span class="hljs-comment">// 0: add, 1: subtract</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] result
);
</div></code></pre>
<ul>
<li>Rejected due to:
<ul>
<li>Increased control complexity</li>
<li>Sequential rather than parallel operation</li>
<li>Performance impact for minimal resource savings</li>
<li>More complex verification</li>
<li>Reduced scalability</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Time-Multiplexed Calculation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Not implemented:</span>
<span class="hljs-keyword">module</span> time_multiplexed_calculator (
    <span class="hljs-comment">// Ports</span>
);
    <span class="hljs-comment">// Sequential processing of indicators</span>
    <span class="hljs-keyword">case</span> (calc_phase)
        <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span> <span class="hljs-comment">// MA calculation</span>
           <span class="hljs-comment">// MA-specific logic</span>
        <span class="hljs-keyword">end</span>
        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span> <span class="hljs-comment">// RSI calculation</span>
           <span class="hljs-comment">// RSI-specific logic</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Rejected due to:
<ul>
<li>Reduced throughput</li>
<li>Increased latency</li>
<li>More complex control logic</li>
<li>Minimal resource savings</li>
<li>Compromised scalability</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>FPGA-Specific Considerations</strong>:</p>
<ul>
<li>
<p><strong>DSP Block Allocation</strong>:</p>
<ul>
<li>Available for critical arithmetic operations</li>
<li>Dedicated to specific calculation paths</li>
<li>Optimized usage for complex operations</li>
<li>Strategic placement for timing closure</li>
<li>Appropriate inferencing through coding style</li>
</ul>
</li>
<li>
<p><strong>Memory Resource Allocation</strong>:</p>
<ul>
<li>Small arrays implemented in distributed RAM</li>
<li>Larger buffers mapped to block RAM</li>
<li>Register usage optimized for width</li>
<li>Appropriate memory structure selection</li>
<li>Balance between performance and capacity</li>
</ul>
</li>
<li>
<p><strong>LUT Utilization Strategy</strong>:</p>
<ul>
<li>Optimized encoding for state machines</li>
<li>Efficient implementation of control logic</li>
<li>Balanced combinational depth</li>
<li>Appropriate sharing of common functions</li>
<li>Strategic partitioning for placement</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>These resource sharing approaches create an efficient implementation that balances parallelism with resource utilization. The strategy prioritizes performance for critical calculations while sharing common infrastructure, resulting in an optimized system design suitable for FPGA implementation.</p>
<h2 id="6-modules-documentation">6. Modules Documentation</h2>
<h3 id="moving-average-system">Moving Average System</h3>
<h4 id="memory-module-details">Memory Module Details</h4>
<p>The Memory module implements a specialized FIFO buffer for storing price history used in the moving average calculation. This module manages the sliding window of price data, providing both storage and access functionality tailored to the requirements of technical analysis indicators.</p>
<p><strong>Module Declaration:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> memory (
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,               <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,               <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] new_price,  <span class="hljs-comment">// Incoming new price</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> write_enable,      <span class="hljs-comment">// Enables writing to memory</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Provides the oldest price for rolling sum</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> memory_full,      <span class="hljs-comment">// Becomes HIGH when FIFO is full</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">319</span>:<span class="hljs-number">0</span>] prices_flat, <span class="hljs-comment">// Flattened 10-price array (debugging)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] fifo_data_count <span class="hljs-comment">// Tracks number of stored prices</span>
);
</div></code></pre>
<p><strong>Internal Structure:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] prices[<span class="hljs-number">9</span>:<span class="hljs-number">0</span>]; <span class="hljs-comment">// FIFO Memory (10 prices)</span>
<span class="hljs-keyword">integer</span> i;
    
<span class="hljs-keyword">assign</span> memory_full = (fifo_data_count &gt;= <span class="hljs-number">10</span>);
</div></code></pre>
<p>The module contains:</p>
<ul>
<li>A 10-element array of 32-bit registers for price storage</li>
<li>An integer counter for loops</li>
<li>A memory_full flag derived from the fill level</li>
<li>A flattened output array for debugging purposes</li>
<li>Counters and pointers for memory management</li>
</ul>
<p><strong>Operational Flow:</strong></p>
<ol>
<li><strong>Reset Operation:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
        prices[i] &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span>
    fifo_data_count &lt;= <span class="hljs-number">0</span>;
    oldest_price &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Clears all price registers to zero</li>
<li>Resets the FIFO counter to zero</li>
<li>Initializes the oldest price output to zero</li>
<li>Creates a known starting state</li>
</ul>
<ol start="2">
<li><strong>Write Operation:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (write_enable) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// FIFO Shift: Remove oldest price, add new price</span>
    oldest_price &lt;= prices[<span class="hljs-number">0</span>];  
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
        prices[i] &lt;= prices[i + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">end</span>
    prices[<span class="hljs-number">9</span>] &lt;= new_price;

    <span class="hljs-comment">// Flattened Array for Debugging</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
        prices_flat[i * <span class="hljs-number">32</span> +: <span class="hljs-number">32</span>] &lt;= prices[i];
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// Update FIFO Count</span>
    <span class="hljs-keyword">if</span> (fifo_data_count &lt; <span class="hljs-number">10</span>)
        fifo_data_count &lt;= fifo_data_count + <span class="hljs-number">1</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Captures the oldest price (at index 0)</li>
<li>Shifts all prices one position toward index 0</li>
<li>Stores the new price at the highest index (9)</li>
<li>Updates the flattened debug array</li>
<li>Increments the counter if not full</li>
</ul>
<p><strong>Implementation Details:</strong></p>
<ol>
<li><strong>FIFO Mechanism:</strong></li>
</ol>
<ul>
<li>Implements a shift register approach rather than a circular buffer</li>
<li>All elements shift on each write operation</li>
<li>Oldest element is always at index 0</li>
<li>Newest element is always at index 9</li>
<li>Fill level tracked by explicit counter</li>
</ul>
<ol start="2">
<li><strong>Memory Full Detection:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">assign</span> memory_full = (fifo_data_count &gt;= <span class="hljs-number">10</span>);
</div></code></pre>
<ul>
<li>Becomes true when 10 or more prices are stored</li>
<li>Indicates sufficient data for moving average calculation</li>
<li>Used as a trigger for downstream processing</li>
<li>Remains true during steady-state operation</li>
<li>Provides synchronization point for system</li>
</ul>
<ol start="3">
<li><strong>Debug Interface:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">319</span>:<span class="hljs-number">0</span>] prices_flat; <span class="hljs-comment">// Flattened 10-price array</span>
</div></code></pre>
<ul>
<li>Concatenates all 10 price registers into a single vector</li>
<li>Facilitates debugging and visualization</li>
<li>Provides complete visibility into price history</li>
<li>Updated synchronously with price array</li>
<li>32 bits  10 elements = 320 bits total width</li>
</ul>
<ol start="4">
<li><strong>Capacity Management:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (fifo_data_count &lt; <span class="hljs-number">10</span>)
    fifo_data_count &lt;= fifo_data_count + <span class="hljs-number">1</span>;
</div></code></pre>
<ul>
<li>Counter tracks valid entries in the FIFO</li>
<li>Stops incrementing when capacity is reached</li>
<li>Provides accurate fill level information</li>
<li>Used to derive full status flag</li>
<li>Initialized to zero on reset</li>
</ul>
<ol start="5">
<li><strong>Interface Timing:</strong></li>
</ol>
<ul>
<li>Write operations occur on positive clock edge when write_enable is high</li>
<li>oldest_price updates one cycle after write_enable assertion</li>
<li>memory_full signal is combinationally derived from counter</li>
<li>Write latency is one clock cycle from enable to completion</li>
<li>Read access is continuous (asynchronous read port)</li>
</ul>
<p><strong>Operational Characteristics:</strong></p>
<ol>
<li><strong>Filling Phase:</strong></li>
</ol>
<ul>
<li>FIFO initially empty after reset</li>
<li>Each write increments the counter</li>
<li>memory_full remains false until 10 prices stored</li>
<li>Partial data available but insufficient for calculation</li>
<li>Sequential filling of array from lowest to highest index</li>
</ul>
<ol start="2">
<li><strong>Steady State:</strong></li>
</ol>
<ul>
<li>FIFO contains 10 valid prices</li>
<li>Counter remains at 10</li>
<li>memory_full remains true</li>
<li>Each write shifts out oldest price</li>
<li>Maintains constant window size</li>
</ul>
<p><strong>Usage Considerations:</strong></p>
<ol>
<li><strong>Performance:</strong></li>
</ol>
<ul>
<li>Can accept one new price per clock cycle</li>
<li>Shift operation completes in a single cycle</li>
<li>No stall cycles or backpressure</li>
<li>Deterministic timing for all operations</li>
<li>Suitable for high-throughput applications</li>
</ul>
<ol start="2">
<li><strong>Resource Utilization:</strong></li>
</ol>
<ul>
<li>10  32-bit registers for price storage (320 bits)</li>
<li>4-bit counter for fill level</li>
<li>32-bit register for oldest_price output</li>
<li>320-bit register for prices_flat (debug)</li>
<li>Additional control logic for shifting and counting</li>
</ul>
<ol start="3">
<li><strong>Integration Requirements:</strong></li>
</ol>
<ul>
<li>write_enable should be asserted for exactly one cycle per price</li>
<li>new_price must be stable during write_enable assertion</li>
<li>External reset should be held for multiple cycles</li>
<li>No protection against write to full buffer (by design)</li>
<li>External logic should monitor memory_full for calculation triggering</li>
</ul>
<p>The Memory module provides the foundation for the moving average calculation, maintaining the sliding window of price data with simple, efficient operations tailored to the specific requirements of technical analysis indicators.</p>
<h4 id="moving-average-fsm-implementation">Moving Average FSM Implementation</h4>
<p>The Moving Average FSM module implements the control logic and arithmetic operations for calculating a 20-period simple moving average. This module employs a finite state machine approach with optimized calculation methods to efficiently compute the moving average as new price data arrives.</p>
<p><strong>Module Declaration:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,    <span class="hljs-comment">// Window size for moving average</span>
    <span class="hljs-keyword">parameter</span> DW     = <span class="hljs-number">16</span>     <span class="hljs-comment">// Data width for prices</span>
)(
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>           clk,        <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>           rst,        <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>           start,      <span class="hljs-comment">// Start calculation signal</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]  new_price,  <span class="hljs-comment">// New price input</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]  oldest_price, <span class="hljs-comment">// Oldest price from FIFO</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]    moving_avg, <span class="hljs-comment">// Calculated moving average</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>            done        <span class="hljs-comment">// Calculation complete signal</span>
);
</div></code></pre>
<p><strong>Internal Structure:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 64-bit sum for overflow prevention</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]  st = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 2-bit state register for FSM</span>
</div></code></pre>
<p>The module contains:</p>
<ul>
<li>A 64-bit sum register for price accumulation</li>
<li>A 2-bit state register for the finite state machine</li>
<li>Parameterized width and window size</li>
<li>Output registers for results and status</li>
</ul>
<p><strong>Finite State Machine:</strong></p>
<p>The FSM consists of three states that control the calculation sequence:</p>
<ol>
<li>
<p><strong>State 0: IDLE</strong></p>
<ul>
<li>Default state after reset</li>
<li>Waits for the start signal</li>
<li>No operations performed in this state</li>
<li>Transitions to CALCULATE when start is asserted</li>
</ul>
</li>
<li>
<p><strong>State 1: CALCULATE</strong></p>
<ul>
<li>Updates the running sum</li>
<li>Calculates the moving average</li>
<li>Sets the done flag</li>
<li>Transitions to DONE state</li>
</ul>
</li>
<li>
<p><strong>State 2: DONE</strong></p>
<ul>
<li>Maintains calculation results</li>
<li>Clears the done flag</li>
<li>Returns to IDLE state</li>
<li>Prepares for next calculation cycle</li>
</ul>
</li>
</ol>
<p>The FSM implementation:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        sum &lt;= <span class="hljs-number">0</span>; moving_avg &lt;= <span class="hljs-number">0</span>; done &lt;= <span class="hljs-number">0</span>; st &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (st)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
                sum &lt;= sum + new_price - oldest_price;
                moving_avg &lt;= sum / WINDOW;
                done &lt;= <span class="hljs-number">1</span>;
                st &lt;= <span class="hljs-number">2</span>;
            <span class="hljs-keyword">end</span>
            <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">0</span>;
                st &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>Calculation Algorithm:</strong></p>
<p>The module implements an efficient sliding window algorithm for moving average calculation:</p>
<pre class="hljs"><code><div>sum &lt;= sum + new_price - oldest_price;
moving_avg &lt;= sum / WINDOW;
</div></code></pre>
<p>Key algorithmic features:</p>
<ul>
<li>Maintains a running sum rather than recalculating from scratch</li>
<li>Adds new price and subtracts oldest price to update sum</li>
<li>Divides by window size to calculate the average</li>
<li>Achieves O(1) complexity regardless of window size</li>
<li>Provides significant performance advantage for larger windows</li>
</ul>
<p><strong>Implementation Details:</strong></p>
<ol>
<li>
<p><strong>Sum Register Sizing:</strong></p>
<ul>
<li>64-bit width provides substantial overflow protection</li>
<li>For 16-bit prices and 20-period window:
<ul>
<li>Maximum possible sum: 20  (2^16 - 1)  1.3 million</li>
<li>64-bit register capacity: 2^64  18.4 quintillion</li>
</ul>
</li>
<li>Prevents overflow in all practical scenarios</li>
<li>Simplifies implementation by eliminating overflow handling</li>
<li>Provides margin for future extensions</li>
</ul>
</li>
<li>
<p><strong>Division Implementation:</strong></p>
<ul>
<li>Integer division by the window size parameter</li>
<li>Result stored in 32-bit output register</li>
<li>Truncates fractional results (rounds toward zero)</li>
<li>Sufficient precision for trading applications</li>
<li>Potential optimization for power-of-2 window sizes</li>
</ul>
</li>
<li>
<p><strong>State Transition Timing:</strong></p>
<ul>
<li>Transitions occur on positive clock edge</li>
<li>Single-cycle state progression</li>
<li>Complete calculation cycle requires 3 clock cycles:
<ul>
<li>Cycle 1: IDLE  CALCULATE</li>
<li>Cycle 2: CALCULATE  DONE</li>
<li>Cycle 3: DONE  IDLE</li>
</ul>
</li>
<li>Predictable latency for all operations</li>
<li>Clean timing boundaries between calculations</li>
</ul>
</li>
<li>
<p><strong>Interface Signaling:</strong></p>
<ul>
<li>start signal triggers calculation</li>
<li>done signal pulses for one cycle when calculation completes</li>
<li>All inputs sampled on state transition to CALCULATE</li>
<li>Outputs updated in the CALCULATE state</li>
<li>Clear handshaking protocol for system integration</li>
</ul>
</li>
<li>
<p><strong>Reset Behavior:</strong></p>
<ul>
<li>Asynchronous reset for immediate initialization</li>
<li>Clears sum to prevent incorrect calculations</li>
<li>Resets moving_avg output to zero</li>
<li>Clears done flag to prevent false signals</li>
<li>Returns to IDLE state for clean startup</li>
</ul>
</li>
</ol>
<p><strong>Operational Characteristics:</strong></p>
<ol>
<li>
<p><strong>Initialization Phase:</strong></p>
<ul>
<li>Initial sum value is zero</li>
<li>First N calculations may produce incorrect results</li>
<li>Typically used only after buffer is full</li>
<li>External logic should manage initial filling</li>
<li>Start signal typically derived from buffer full condition</li>
</ul>
</li>
<li>
<p><strong>Steady State Operation:</strong></p>
<ul>
<li>Continuous updating as new prices arrive</li>
<li>Consistent timing for all calculations</li>
<li>Predictable result generation</li>
<li>One-cycle pulse for done signal</li>
<li>Clean transition back to IDLE for next cycle</li>
</ul>
</li>
</ol>
<p><strong>Implementation Optimization:</strong></p>
<ol>
<li>
<p><strong>Performance Optimization:</strong></p>
<ul>
<li>Single-cycle calculation for maximum throughput</li>
<li>O(1) algorithm complexity regardless of window size</li>
<li>Minimal state machine overhead</li>
<li>Direct calculation without intermediate steps</li>
<li>Maximum throughput of one calculation per 3 clock cycles</li>
</ul>
</li>
<li>
<p><strong>Resource Optimization:</strong></p>
<ul>
<li>Minimal register usage for state machine</li>
<li>Efficient sliding window algorithm</li>
<li>Appropriate register sizing for required precision</li>
<li>Simple control logic with clear states</li>
<li>Division optimization through synthesis</li>
</ul>
</li>
<li>
<p><strong>Potential Enhancements:</strong></p>
<ul>
<li>Fixed-point implementation for decimal precision</li>
<li>Optimized division for power-of-2 window sizes</li>
<li>Pipelined calculation for complex operations</li>
<li>Parameterized arithmetic precision</li>
<li>Additional status flags for system coordination</li>
</ul>
</li>
</ol>
<p><strong>Usage Considerations:</strong></p>
<ol>
<li>
<p><strong>Integration Requirements:</strong></p>
<ul>
<li>start signal should be asserted for one cycle to begin calculation</li>
<li>new_price and oldest_price must be valid when start is asserted</li>
<li>External logic should monitor done signal for result validity</li>
<li>Typically triggered when memory buffer is full</li>
<li>Results valid when done signal is asserted</li>
</ul>
</li>
<li>
<p><strong>Timing Relationships:</strong></p>
<ul>
<li>Calculation latency: 2 clock cycles from start to done</li>
<li>Result validity: moving_avg stable when done is asserted</li>
<li>Minimum calculation interval: 3 clock cycles</li>
<li>start signal should not be asserted during active calculation</li>
<li>Reset should be held for multiple clock cycles</li>
</ul>
</li>
<li>
<p><strong>Parameter Configuration:</strong></p>
<ul>
<li>WINDOW parameter sets divisor for average calculation</li>
<li>Typical values: 10, 20, 50, 200 (common in technical analysis)</li>
<li>DW parameter sets input data width</li>
<li>Must match price data representation in system</li>
<li>Default configuration suitable for most applications</li>
</ul>
</li>
</ol>
<p>The Moving Average FSM module provides an efficient, parameterized implementation of the simple moving average calculation, with a clean interface for system integration and optimized performance for hardware deployment.</p>
<p><strong>1. IDLE State (3'b000)</strong>:</p>
<ul>
<li>Initial state after reset and default state between calculations</li>
<li>Waits for the <code>start</code> signal to begin a new calculation cycle</li>
<li>Initializes counters and accumulators when transitioning to FILL_FIFO</li>
<li>Handles reset and startup conditions</li>
<li>Transition: IDLE  FILL_FIFO when <code>start</code> is asserted</li>
</ul>
<pre class="hljs"><code><div>IDLE: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
        gain_sum &lt;= <span class="hljs-number">0</span>;
        loss_sum &lt;= <span class="hljs-number">0</span>;
        sample_cnt &lt;= <span class="hljs-number">0</span>;
        done &lt;= <span class="hljs-number">0</span>;
        state &lt;= FILL_FIFO;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>2. FILL_FIFO State (3'b001)</strong>:</p>
<ul>
<li>Manages loading price data into the FIFO buffer</li>
<li>Continues until the FIFO is full (contains sufficient price history)</li>
<li>Controls write operations to the price FIFO</li>
<li>Initiates the first read operation when the FIFO becomes full</li>
<li>Transition: FILL_FIFO  READ_INIT when FIFO becomes full</li>
</ul>
<pre class="hljs"><code><div>FILL_FIFO: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (new_price &amp;&amp; !fifo_full)
        fifo_wr_en &lt;= <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (fifo_full) <span class="hljs-keyword">begin</span>
        fifo_rd_en &lt;= <span class="hljs-number">1</span>;
        read_delay &lt;= <span class="hljs-number">1</span>;
        state &lt;= READ_INIT;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>3. READ_INIT State (3'b010)</strong>:</p>
<ul>
<li>Initializes the first price value for comparison</li>
<li>Handles the one-cycle delay in FIFO read operations</li>
<li>Captures the first price value from the FIFO</li>
<li>Prepares for the price comparison sequence</li>
<li>Transition: READ_INIT  COMPARE when first price is captured</li>
</ul>
<pre class="hljs"><code><div>READ_INIT: <span class="hljs-keyword">begin</span>
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (read_delay) <span class="hljs-keyword">begin</span>
        prev_price &lt;= price_out;
        read_delay &lt;= <span class="hljs-number">0</span>;
        state &lt;= COMPARE;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>4. COMPARE State (3'b100)</strong>:</p>
<ul>
<li>Determines whether to continue processing price data</li>
<li>Checks if all required samples have been processed</li>
<li>Initiates read operations for subsequent price values</li>
<li>Controls the flow of the comparison sequence</li>
<li>Transitions:
<ul>
<li>COMPARE  READ_WAIT if more samples need processing</li>
<li>COMPARE  DONE if all samples have been processed</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>COMPARE: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (sample_cnt &lt; <span class="hljs-number">19</span> &amp;&amp; !fifo_empty) <span class="hljs-keyword">begin</span>
        fifo_rd_en &lt;= <span class="hljs-number">1</span>;
        read_delay &lt;= <span class="hljs-number">1</span>;
        state &lt;= READ_WAIT;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        state &lt;= DONE;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>5. READ_WAIT State (3'b011)</strong>:</p>
<ul>
<li>Handles the core RSI calculation by comparing consecutive prices</li>
<li>Manages the one-cycle delay for FIFO read operations</li>
<li>Determines price changes and accumulates gains/losses</li>
<li>Updates counters and manages state variables</li>
<li>Transition: READ_WAIT  COMPARE after processing each price</li>
</ul>
<pre class="hljs"><code><div>READ_WAIT: <span class="hljs-keyword">begin</span>
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (read_delay) <span class="hljs-keyword">begin</span>
        curr_price &lt;= price_out;

        <span class="hljs-keyword">if</span> (price_out &gt; prev_price)
            gain_sum &lt;= gain_sum + (price_out - prev_price);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_out &lt; prev_price)
            loss_sum &lt;= loss_sum + (prev_price - price_out);

        prev_price &lt;= price_out;
        sample_cnt &lt;= sample_cnt + <span class="hljs-number">1</span>;
        read_delay &lt;= <span class="hljs-number">0</span>;
        state &lt;= COMPARE;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>6. DONE State (3'b101)</strong>:</p>
<ul>
<li>Calculates the final RSI value using the accumulated gains and losses</li>
<li>Handles the division operation with protection against division by zero</li>
<li>Sets the output RSI value in the 0-100 range</li>
<li>Signals calculation completion</li>
<li>Transition: DONE  IDLE to prepare for the next calculation cycle</li>
</ul>
<pre class="hljs"><code><div>DONE: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> ((gain_sum + loss_sum) &gt; <span class="hljs-number">0</span>)
        rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
    <span class="hljs-keyword">else</span>
        rsi &lt;= <span class="hljs-number">0</span>;

    done &lt;= <span class="hljs-number">1</span>;
    state &lt;= IDLE;
<span class="hljs-keyword">end</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-section">## 6. Modules Documentation</span>

This section details the core modules used in the integrated <span class="hljs-code">`Combined_analysis`</span> system.

<span class="hljs-section">### Moving Average System</span>

This component refers specifically to the <span class="hljs-code">`moving_average_fsm.v`</span> module within the <span class="hljs-code">`Combined_analysis`</span> directory, which calculates the Simple Moving Average (SMA).

<span class="hljs-section">#### Memory Module Details</span>

The Moving Average calculation relies on the shared <span class="hljs-code">`price_memory.v`</span> module. Key aspects of this interaction:
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Inputs Used**</span>: <span class="hljs-code">`new_price`</span>, <span class="hljs-code">`oldest_price`</span>.
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Control**</span>: Triggered by the <span class="hljs-code">`start`</span> signal, typically derived when the shared <span class="hljs-code">`price_memory`</span> is full (<span class="hljs-code">`mem_full`</span> or <span class="hljs-code">`mem_cnt == WINDOW`</span>).
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Data Window**</span>: Implicitly defined by the <span class="hljs-code">`oldest_price`</span> provided by the shared memory.

<span class="hljs-section">#### Moving Average FSM Implementation</span>

The <span class="hljs-code">`moving_average_fsm.v`</span> module calculates a rolling mean using an efficient sliding window approach controlled by a Finite State Machine (FSM).

<span class="hljs-strong">**Module Declaration Snippet:**</span>
<span class="hljs-code">```verilog
module moving_average_fsm #(
    parameter WINDOW = 20,    // Window size for moving average
    parameter DW     = 16     // Data width for prices
)(
    input  wire           clk,
    input  wire           rst,
    input  wire           start,      // Start calculation signal
    input  wire [DW-1:0]  new_price,  // New price input
    input  wire [DW-1:0]  oldest_price, // Oldest price from FIFO
    output reg  [31:0]    moving_avg, // Calculated moving average
    output reg            done        // Calculation complete signal
);```</span>

<span class="hljs-strong">**Functionality:**</span>
<span class="hljs-bullet">-</span> Uses a 3-state FSM (Idle, Calculate, Done) to manage the calculation process.
<span class="hljs-bullet">-</span> Maintains a 64-bit running sum (<span class="hljs-code">`sum`</span>) to prevent overflow.
<span class="hljs-bullet">-</span> Updates the sum efficiently using the sliding window algorithm: <span class="hljs-code">`sum &lt;= sum + new_price - oldest_price;`</span>
<span class="hljs-bullet">-</span> Calculates the average using integer division: <span class="hljs-code">`moving_avg &lt;= sum / WINDOW;`</span>
<span class="hljs-bullet">-</span> Signals completion with a one-cycle <span class="hljs-code">`done`</span> pulse.

<span class="hljs-section">#### Port Descriptions and Timing</span>

| Port           | Direction | Width | Description                                      | Timing                                       |
| -------------- | --------- | ----- | ------------------------------------------------ | -------------------------------------------- |
| <span class="hljs-code">`clk`</span>          | Input     | 1     | System clock                                     | Rising edge active                         |
| <span class="hljs-code">`rst`</span>          | Input     | 1     | Asynchronous reset (active high)                 | Resets state immediately                   |
| <span class="hljs-code">`start`</span>        | Input     | 1     | Trigger to start calculation                     | Sampled on posedge clk in IDLE state       |
| <span class="hljs-code">`new_price`</span>    | Input     | DW    | Current price value                              | Sampled on posedge clk when start is high  |
| <span class="hljs-code">`oldest_price`</span> | Input     | DW    | Oldest price value to remove from window         | Sampled on posedge clk when start is high  |
| <span class="hljs-code">`moving_avg`</span>   | Output    | 32    | Calculated moving average                        | Updated in CALCULATE state, valid when done |
| <span class="hljs-code">`done`</span>         | Output    | 1     | Calculation completion indicator                 | Pulses high for one clock cycle             |

<span class="hljs-section">#### Internal Register Architecture</span>

<span class="hljs-bullet">-</span> <span class="hljs-code">`sum [63:0]`</span>: Stores the running sum of prices within the window. 64-bit width prevents overflow.
<span class="hljs-bullet">-</span> <span class="hljs-code">`st [1:0]`</span>: 2-bit register holding the current state of the FSM (0: Idle, 1: Calculate, 2: Done).

<span class="hljs-section">#### State Machine Design</span>

<span class="hljs-bullet">-</span> <span class="hljs-strong">**State 0 (IDLE)**</span>: Waits for <span class="hljs-code">`start`</span> signal. Transitions to State 1 upon <span class="hljs-code">`start`</span>.
<span class="hljs-bullet">-</span> <span class="hljs-strong">**State 1 (CALCULATE)**</span>: Updates <span class="hljs-code">`sum`</span>, calculates <span class="hljs-code">`moving_avg`</span>, sets <span class="hljs-code">`done`</span> to 1. Transitions to State 2.
<span class="hljs-bullet">-</span> <span class="hljs-strong">**State 2 (DONE)**</span>: Clears <span class="hljs-code">`done`</span> to 0. Transitions to State 0.

<span class="hljs-section">#### Signal Timing Relationships</span>

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Latency**</span>: 2 clock cycles from <span class="hljs-code">`start`</span> assertion to <span class="hljs-code">`done`</span> assertion.
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Minimum Interval**</span>: The module can accept a new <span class="hljs-code">`start`</span> signal every 3 clock cycles.
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Result Validity**</span>: <span class="hljs-code">`moving_avg`</span> output is valid during the clock cycle when <span class="hljs-code">`done`</span> is high.

<span class="hljs-section">#### Module Constraints</span>

<span class="hljs-bullet">-</span> <span class="hljs-code">`WINDOW`</span> parameter must be positive.
<span class="hljs-bullet">-</span> <span class="hljs-code">`DW`</span> parameter must be sufficient for price representation.
<span class="hljs-bullet">-</span> <span class="hljs-code">`start`</span> should be pulsed for one clock cycle.
<span class="hljs-bullet">-</span> <span class="hljs-code">`new_price`</span> and <span class="hljs-code">`oldest_price`</span> must be valid when <span class="hljs-code">`start`</span> is asserted.

<span class="hljs-section">#### Integration Guidelines</span>

<span class="hljs-bullet">-</span> Connect <span class="hljs-code">`start`</span> to logic indicating sufficient data is available (e.g., <span class="hljs-code">`mem_full`</span> from <span class="hljs-code">`price_memory`</span>).
<span class="hljs-bullet">-</span> Ensure <span class="hljs-code">`new_price`</span> and <span class="hljs-code">`oldest_price`</span> are sourced correctly relative to the calculation window.
<span class="hljs-bullet">-</span> Monitor the <span class="hljs-code">`done`</span> signal to capture the valid <span class="hljs-code">`moving_avg`</span> result.

<span class="hljs-section">### RSI Calculator</span>

This component refers to the <span class="hljs-code">`rsi_inc.v`</span> module within the <span class="hljs-code">`Combined_analysis`</span> directory, which calculates the Relative Strength Index (RSI) incrementally.

<span class="hljs-section">#### Price FIFO Module Details</span>

The RSI calculation relies on the shared <span class="hljs-code">`price_memory.v`</span> module.
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Inputs Used**</span>: <span class="hljs-code">`new_price`</span>.
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Control**</span>: Triggered by <span class="hljs-code">`new_price_strobe`</span> (typically derived from <span class="hljs-code">`mem_cnt == WINDOW`</span> or similar).
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Data Window**</span>: Requires tracking the previous price (<span class="hljs-code">`prev_price`</span> register) and accumulating gains/losses over the specified <span class="hljs-code">`WINDOW`</span> period. <span class="hljs-emphasis">*Note: The `rsi_inc.v` implementation appears to be an incremental update rather than a full window recalculation based on FIFO contents, differing from the separate `rsi_verilog_project` FSM.*</span>

<span class="hljs-section">#### RSI FSM Module Implementation</span>

The <span class="hljs-code">`rsi_inc.v`</span> module calculates RSI based on incremental price changes. <span class="hljs-emphasis">*Note: This module doesn&#x27;t implement the complex 6-state FSM found in `rsi_verilog_project/rsi_fsm.v`, but uses a simpler logic structure.*</span>

<span class="hljs-strong">**Module Declaration Snippet:**</span>
<span class="hljs-code">```verilog
module rsi_inc #(
    parameter WINDOW = 14,   // RSI period
    parameter DW = 16        // Price width
)(
    input wire             clk,
    input wire             rst,
    input wire             new_price_strobe, // Trigger for new calculation
    input wire [DW-1:0]    new_price,        // New price data
    input wire [DW-1:0]    oldest_price,     // (Potentially used for smoothing)
    input wire             mem_full,         // Flag indicating sufficient data
    input wire [4:0]       mem_count,        // Price count in memory
    output reg  [7:0]      rsi,              // RSI value
    output reg             done              // Done signal
);
</span></div></code></pre>
<p><strong>Functionality:</strong></p>
<ul>
<li>Accumulates <code>gain_sum</code> and <code>loss_sum</code> based on <code>new_price</code> vs <code>prev_price</code>.</li>
<li>Uses a <code>first_sample</code> flag for initialization.</li>
<li>Calculates RSI = 100 * gain_sum / (gain_sum + loss_sum) when triggered and sufficient data exists (<code>mem_count &gt;= WINDOW</code>).</li>
<li>Protects against division by zero.</li>
<li>Signals completion with <code>done</code>. <em>Note: The provided <code>rsi_inc.v</code> seems simplified and might not implement full windowed gain/loss averaging correctly. It appears to accumulate indefinitely unless external logic resets it or it implements a sliding window for the sums.</em></li>
</ul>
<h4 id="state-machine-deep-dive">State Machine Deep Dive</h4>
<p>The <code>rsi_inc.v</code> module does not contain an explicit multi-state FSM like the one in <code>rsi_verilog_project</code>. Its operation is primarily controlled by the <code>new_price_strobe</code>, <code>mem_count</code>, and <code>first_sample</code> flag, representing implicit states:</p>
<ol>
<li><strong>Reset State</strong>: Registers cleared.</li>
<li><strong>Waiting State</strong>: Waiting for <code>new_price_strobe</code> and <code>mem_count &gt;= WINDOW</code>.</li>
<li><strong>First Sample State</strong>: Initializes <code>prev_price</code>.</li>
<li><strong>Calculating State</strong>: Updates <code>gain_sum</code>/<code>loss_sum</code>, calculates <code>rsi</code>, asserts <code>done</code>.</li>
</ol>
<h4 id="calculation-logic-details">Calculation Logic Details</h4>
<ul>
<li><strong>Gain/Loss Accumulation</strong>:<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (new_price &gt; prev_price)
    gain_sum &lt;= gain_sum + (new_price - prev_price);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new_price &lt; prev_price)
    loss_sum &lt;= loss_sum + (prev_price - new_price);
</div></code></pre>
</li>
<li><strong>Final RSI Calculation</strong>:<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (total != <span class="hljs-number">0</span>) <span class="hljs-comment">// total = gain_sum + loss_sum</span>
    rsi &lt;= (<span class="hljs-number">100</span> * gain) / total;
<span class="hljs-keyword">else</span>
    rsi &lt;= <span class="hljs-number">0</span>; <span class="hljs-comment">// Avoid division by zero</span>
</div></code></pre>
<em>Self-Correction:</em> The module likely needs refinement to correctly implement the <em>average</em> gain/loss over the window, possibly using smoothing or requiring access to more historical data than just <code>prev_price</code>. Assuming the current code intends simple sum-based RSI for now.</li>
</ul>
<h4 id="timing-requirements">Timing Requirements</h4>
<ul>
<li><code>new_price_strobe</code> should be asserted for one clock cycle when a valid <code>new_price</code> arrives and <code>mem_count &gt;= WINDOW</code>.</li>
<li><strong>Latency</strong>: Approximately 1-2 clock cycles from <code>new_price_strobe</code> assertion to <code>done</code> assertion.</li>
</ul>
<h4 id="resource-utilization-analysis">Resource Utilization Analysis</h4>
<ul>
<li><strong>Registers</strong>: <code>gain_sum</code> (32b), <code>loss_sum</code> (32b), <code>prev_price</code> (DW), <code>rsi</code> (8b), <code>done</code> (1b), <code>first_sample</code> (1b). Total ~74 bits + control logic FFs.</li>
<li><strong>Combinational Logic</strong>: Comparators, Adders/Subtractors, Multiplier (100 * gain), Divider. Division is the most resource-intensive part.</li>
</ul>
<h4 id="interface-specifications-rsiincv-specific">Interface Specifications (rsi_inc.v specific)</h4>
<table>
<thead>
<tr>
<th>Port</th>
<th>Direction</th>
<th>Width</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>clk</code></td>
<td>Input</td>
<td>1</td>
<td>System clock</td>
</tr>
<tr>
<td><code>rst</code></td>
<td>Input</td>
<td>1</td>
<td>Asynchronous reset</td>
</tr>
<tr>
<td><code>new_price_strobe</code></td>
<td>Input</td>
<td>1</td>
<td>Trigger new RSI calculation</td>
</tr>
<tr>
<td><code>new_price</code></td>
<td>Input</td>
<td>DW</td>
<td>Current price value</td>
</tr>
<tr>
<td><code>oldest_price</code></td>
<td>Input</td>
<td>DW</td>
<td>Oldest price (usage unclear in code)</td>
</tr>
<tr>
<td><code>mem_full</code></td>
<td>Input</td>
<td>1</td>
<td>Memory full status (usage unclear)</td>
</tr>
<tr>
<td><code>mem_count</code></td>
<td>Input</td>
<td>5</td>
<td>Number of prices in memory</td>
</tr>
<tr>
<td><code>rsi</code></td>
<td>Output</td>
<td>8</td>
<td>Calculated RSI value (0-100)</td>
</tr>
<tr>
<td><code>done</code></td>
<td>Output</td>
<td>1</td>
<td>Calculation completion flag</td>
</tr>
</tbody>
</table>
<h4 id="integration-considerations">Integration Considerations</h4>
<ul>
<li>Trigger <code>new_price_strobe</code> based on <code>new_price</code> and <code>mem_cnt &gt;= WINDOW</code>.</li>
<li>Ensure <code>prev_price</code> is correctly maintained between calculations.</li>
<li>The current logic might require periodic resets or adjustments to correctly reflect a sliding window average gain/loss.</li>
</ul>
<h3 id="trading-decision-system">Trading Decision System</h3>
<p>This component refers to the <code>trading_decision.v</code> module.</p>
<h4 id="module-implementation-details">Module Implementation Details</h4>
<p><strong>Module Declaration Snippet:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
)(
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_now,    <span class="hljs-comment">// Assumes DW=16</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         sell
);
</div></code></pre>
<p><strong>Functionality:</strong></p>
<ul>
<li>Implements a simple mean-reversion strategy.</li>
<li>Compares current price (<code>price_now</code>) with the moving average (<code>moving_avg</code>).</li>
<li>Compares RSI with configurable thresholds (<code>BUY_RSI_THR</code>, <code>SELL_RSI_THR</code>).</li>
<li>Generates registered <code>buy</code> and <code>sell</code> signals based on combined conditions.</li>
</ul>
<h4 id="signal-processing-logic">Signal Processing Logic</h4>
<ul>
<li><strong>Buy Condition</strong>: <code>(price_now &gt; moving_avg[15:0]) &amp;&amp; (rsi &lt; BUY_RSI_THR)</code>
<ul>
<li>Price must be above MA (uptrend).</li>
<li>RSI must be below oversold threshold.</li>
</ul>
</li>
<li><strong>Sell Condition</strong>: <code>(price_now &lt; moving_avg[15:0]) &amp;&amp; (rsi &gt; SELL_RSI_THR)</code>
<ul>
<li>Price must be below MA (downtrend).</li>
<li>RSI must be above overbought threshold.</li>
</ul>
</li>
<li><strong>MA Truncation</strong>: <code>moving_avg[15:0]</code> truncates the 32-bit MA result to match the 16-bit price width for comparison.</li>
</ul>
<h4 id="threshold-management">Threshold Management</h4>
<ul>
<li><code>BUY_RSI_THR</code> (default 30) and <code>SELL_RSI_THR</code> (default 70) are 8-bit parameters.</li>
<li>These define the RSI levels considered oversold and overbought.</li>
<li>They can be overridden during instantiation for strategy tuning.</li>
</ul>
<h4 id="signal-generation-implementation">Signal Generation Implementation</h4>
<ul>
<li>Buy/Sell conditions are evaluated combinationally.</li>
<li>The results are captured in the <code>buy</code> and <code>sell</code> registers on the clock edge.</li>
<li>Outputs are stable between clock edges.</li>
</ul>
<h4 id="timing-characteristics">Timing Characteristics</h4>
<ul>
<li><strong>Latency</strong>: 1 clock cycle from input changes (<code>price_now</code>, <code>moving_avg</code>, <code>rsi</code>) to output update (<code>buy</code>, <code>sell</code>).</li>
<li><strong>Operation</strong>: Continuous evaluation on every clock cycle.</li>
</ul>
<h4 id="parameterization-details">Parameterization Details</h4>
<ul>
<li>Thresholds (<code>BUY_RSI_THR</code>, <code>SELL_RSI_THR</code>) can be configured at instantiation.</li>
<li>Price width comparison implicitly assumes <code>price_now</code> is 16 bits due to <code>moving_avg[15:0]</code>.</li>
</ul>
<h4 id="extension-options">Extension Options</h4>
<ul>
<li>Add hysteresis to prevent signal flickering near thresholds.</li>
<li>Incorporate additional indicators (e.g., volume, volatility).</li>
<li>Implement more complex strategies (e.g., MA crossovers, divergence detection).</li>
<li>Add signal strength or confidence level outputs.</li>
</ul>
<h3 id="price-memory-fifo">Price Memory (FIFO)</h3>
<p>This component refers to the <code>price_memory.v</code> module in <code>Combined_analysis</code>.</p>
<h4 id="circular-buffer-implementation-details">Circular Buffer Implementation Details</h4>
<ul>
<li><strong>Storage</strong>: <code>reg [DW-1:0] mem [0:DEPTH-1];</code> - RAM array.</li>
<li><strong>Pointers</strong>: <code>reg [4:0] write_ptr</code>, <code>reg [4:0] read_ptr</code>. Width allows up to DEPTH=32.</li>
<li><strong>Counter</strong>: <code>reg [5:0] item_count</code>. Width allows counts up to DEPTH=32.</li>
<li><strong>Logic</strong>: Implements circular buffer logic using pointer arithmetic (<code>% DEPTH</code>).</li>
</ul>
<h4 id="readwrite-pointer-management">Read/Write Pointer Management</h4>
<ul>
<li><strong>Reset</strong>: Both pointers and count reset to 0.</li>
<li><strong>Write</strong>: <code>write_ptr</code> increments on <code>wr_en</code> (modulo <code>DEPTH</code>).</li>
<li><strong>Read</strong>: <code>read_ptr</code> increments only when <code>wr_en</code> is asserted AND <code>item_count == DEPTH</code>. It always points to the oldest valid element.</li>
<li><strong>Wrapping</strong>: Pointers wrap automatically due to modulo arithmetic.</li>
</ul>
<h4 id="fullempty-flag-generation">Full/Empty Flag Generation</h4>
<ul>
<li><strong>Full</strong>: <code>assign full = (item_count == DEPTH);</code> Combinationally derived from the counter.</li>
<li><strong>Empty</strong>: Implicitly when <code>item_count == 0</code>. No dedicated empty flag output, but <code>count == 0</code> can be used.</li>
</ul>
<h4 id="data-access-timing">Data Access Timing</h4>
<ul>
<li><strong>Write</strong>: Synchronous. Data is written on the positive clock edge when <code>wr_en</code> is high and not <code>full</code>.</li>
<li><strong>Read</strong>: Asynchronous output. <code>oldest_price = mem[read_ptr];</code> outputs the value at the read pointer continuously. The <em>validity</em> of this output depends on <code>item_count &gt; 0</code>. The <em>value</em> changes one cycle after <code>read_ptr</code> updates (which happens on a write when full).</li>
</ul>
<h4 id="reset-behavior">Reset Behavior</h4>
<ul>
<li>On <code>rst</code> assertion, <code>write_ptr</code>, <code>read_ptr</code>, and <code>item_count</code> are cleared to 0. The memory content itself is typically undefined after reset and relies on subsequent writes.</li>
</ul>
<h4 id="parameterization-options">Parameterization Options</h4>
<ul>
<li><code>DEPTH</code>: Defines the number of price points stored (default 14).</li>
<li><code>DW</code>: Defines the bit width of each price point (default 16).</li>
</ul>
<h4 id="resource-efficiency-techniques">Resource Efficiency Techniques</h4>
<ul>
<li><strong>Circular Buffer</strong>: More resource-efficient for larger depths compared to a shift register, as only pointers update, not the entire memory content shifts.</li>
<li><strong>Pointer Width</strong>: Sufficiently wide to handle depths up to 32, allowing parameter flexibility without changing register widths.</li>
<li><strong>Counter Width</strong>: Sufficient for depths up to 32.</li>
</ul>
<h2 id="7-implementation-optimizations">7. Implementation Optimizations</h2>
<p>The system incorporates several optimizations for efficient hardware implementation:</p>
<h3 id="sliding-window-optimization">Sliding Window Optimization</h3>
<ul>
<li><strong>Algorithm Details</strong>: The MA calculation uses <code>sum &lt;= sum + new_price - oldest_price</code> instead of summing all <code>WINDOW</code> elements each time.</li>
<li><strong>Computational Complexity Analysis</strong>: Reduces MA update complexity from O(WINDOW) to O(1).</li>
<li><strong>Hardware Implementation Efficiency</strong>: Requires only one adder, one subtractor, and registers for <code>sum</code>, <code>new_price</code>, <code>oldest_price</code>, significantly reducing LUT/DSP usage compared to a naive parallel sum.</li>
<li><strong>Comparison</strong>: Significantly faster and uses fewer resources than recalculating the sum, especially for large <code>WINDOW</code> sizes.</li>
</ul>
<h3 id="memory-usage-optimization">Memory Usage Optimization</h3>
<ul>
<li><strong>Circular Buffer Efficiency</strong>: <code>price_memory.v</code> uses a circular buffer, avoiding the need to shift data within the memory array, which saves power and potentially routing resources compared to a shift-register FIFO (like the one in <code>Moving_average/memory.v</code>).</li>
<li><strong>Pointer Management Details</strong>: Simple increment and modulo logic for pointers minimizes control overhead.</li>
<li><strong>Shared Memory</strong>: A single <code>price_memory</code> instance provides data for both MA and RSI calculations, avoiding redundant storage.</li>
<li><strong>FPGA-Specific Memory Optimizations</strong>: For larger <code>DEPTH</code>, this structure maps well to FPGA Block RAM (BRAM) resources.</li>
</ul>
<h3 id="register-width-optimization">Register Width Optimization</h3>
<ul>
<li><strong>Precision Requirements Analysis</strong>:
<ul>
<li>MA <code>sum</code>: 64 bits used to prevent overflow (max sum ~ WINDOW * 2^DW).</li>
<li>RSI <code>gain_sum</code>/<code>loss_sum</code>: 32 bits used (max sum ~ WINDOW * 2^DW).</li>
<li>RSI <code>rsi</code>: 8 bits sufficient for 0-100 range.</li>
</ul>
</li>
<li><strong>Overflow Prevention Strategies</strong>: Wider accumulators (<code>sum</code>, <code>gain_sum</code>, <code>loss_sum</code>) are the primary strategy.</li>
<li><strong>Resource Utilization Tradeoffs</strong>: Wider registers use more FF resources but simplify logic by avoiding explicit overflow checks/saturation.</li>
<li><strong>Bit Width Selection Methodology</strong>: Widths selected based on worst-case accumulation estimates plus some margin.</li>
</ul>
<h3 id="parameterized-design-techniques">Parameterized Design Techniques</h3>
<ul>
<li><strong>Parameter Definition Strategy</strong>: Key parameters (<code>WINDOW</code>, <code>DW</code>, <code>DEPTH</code>, thresholds) defined at module level with defaults.</li>
<li><strong>Compile-Time Configurability</strong>: Allows tailoring the design (e.g., MA period, RSI period, price precision, thresholds) during synthesis without code modification.</li>
<li><strong>Design Reuse Approaches</strong>: Modules can be easily reused with different parameter values (e.g., multiple MAs with different periods).</li>
<li><strong>Implementation Flexibility</strong>: Adapts the same RTL to different trading strategies or precision requirements.</li>
<li><strong>Parameter Propagation Methodology</strong>: Parameters overridden at instantiation in the top-level module (<code>trading_system_singlemem.v</code>).</li>
</ul>
<h2 id="8-performance-considerations">8. Performance Considerations</h2>
<h3 id="clock-domain-analysis">Clock Domain Analysis</h3>
<ul>
<li><strong>Single Domain Advantages</strong>: Simplifies design, avoids complex Clock Domain Crossing (CDC) synchronization logic, eliminates metastability risks within the core, makes timing analysis straightforward.</li>
<li><strong>Clock Frequency Selection</strong>: The design targets ~100 MHz, achievable on most modern FPGAs. The critical path is likely the division operation. Higher frequencies might require pipelining or multi-cycle operations.</li>
<li><strong>FPGA Clock Management</strong>: Assumes use of dedicated global clock networks (BUFG on Xilinx) for low skew distribution.</li>
<li><strong>Timing Constraint Approach</strong>: Requires standard constraints: clock period definition, input/output delay specification relative to the clock.</li>
</ul>
<h3 id="calculation-latency-details">Calculation Latency Details</h3>
<ul>
<li><strong>Moving Average Latency Analysis</strong>: 2 cycles from <code>start</code> assertion to <code>done</code> assertion.</li>
<li><strong>RSI Latency Analysis</strong>: ~1-2 cycles from <code>new_price_strobe</code> to <code>done</code> (assuming single-cycle arithmetic).</li>
<li><strong>End-to-End System Latency</strong>: From <code>new_price</code> input assertion to <code>buy</code>/<code>sell</code> output update:
<ol>
<li>Price write to memory: 1 cycle</li>
<li><code>compute_enable</code> generation (combinational): 0 cycles</li>
<li>Indicator calculation (MA/RSI start): 1 cycle</li>
<li>Indicator computation (MA: 2 cycles, RSI: ~1-2 cycles): Max ~2 cycles</li>
<li>Trading decision evaluation: 1 cycle</li>
</ol>
<ul>
<li><strong>Total</strong>: ~ 1 + 1 + 2 + 1 = <strong>5 clock cycles</strong> (approximate, dominated by MA latency).</li>
</ul>
</li>
<li><strong>Critical Path Identification</strong>: Likely within the division logic (<code>sum / WINDOW</code> or RSI division) or potentially the 64-bit sum update path.</li>
<li><strong>Latency Optimization Strategies</strong>: Pipelining calculations (especially division), using faster arithmetic units (DSP blocks), optimizing state machines.</li>
</ul>
<h3 id="throughput-analysis">Throughput Analysis</h3>
<ul>
<li><strong>Maximum Throughput Calculation</strong>: Can accept one <code>new_price</code> input per clock cycle after the initial fill phase. Throughput = Clock Frequency (e.g., 100 million updates/sec @ 100 MHz).</li>
<li><strong>Sustained Performance Evaluation</strong>: Limited only by the clock frequency, assuming inputs arrive fast enough. No internal bottlenecks prevent processing one price per cycle.</li>
<li><strong>Bottleneck Identification</strong>: Not inherently throughput-limited, but latency is determined by the calculation pipeline depth.</li>
<li><strong>Throughput Enhancement Techniques</strong>: Primarily increasing clock frequency (requires timing optimization) or parallelizing across multiple instruments.</li>
</ul>
<h3 id="synchronization-strategy">Synchronization Strategy</h3>
<ul>
<li><strong>Parallel Calculation Management</strong>: MA and RSI calculations are triggered simultaneously by <code>compute_enable</code>. They run independently in parallel.</li>
<li><strong>Trigger Signal Distribution</strong>: <code>compute_enable</code> (derived from <code>mem_cnt</code>) fans out to both indicator modules.</li>
<li><strong>Handshaking Protocol Design</strong>: Simple <code>start</code>/<code>strobe</code> and <code>done</code> signals. <code>done</code> signals indicate result validity. The Trading Decision module implicitly assumes inputs are valid based on system timing.</li>
<li><strong>Pipeline Balancing Approach</strong>: Calculations are roughly balanced (MA: 3 cycles, RSI: ~2 cycles). Trading Decision adds 1 cycle.</li>
</ul>
<h3 id="resource-utilization">Resource Utilization</h3>
<ul>
<li><strong>FPGA Resource Analysis</strong>: (Qualitative estimates for moderate parameters)
<ul>
<li><strong>LUTs</strong>: Dominated by arithmetic (especially division if not using DSPs), comparators, FSM logic. Likely a few hundred to a thousand LUTs.</li>
<li><strong>FFs</strong>: Dominated by memory array (<code>DEPTH*DW</code>), accumulators (64b + 32b + 32b), state registers, pipeline registers. Likely several hundred FFs.</li>
<li><strong>BRAM</strong>: <code>price_memory</code> could map to BRAM for larger <code>DEPTH</code> (&gt; ~32-64 elements, depending on FPGA).</li>
<li><strong>DSPs</strong>: May be inferred by synthesis tools for multiplication (RSI) or optimized division, potentially 1-2 DSP blocks.</li>
</ul>
</li>
<li><strong>Scaling Considerations</strong>: Resources scale linearly with <code>DEPTH</code> (memory) and <code>DW</code> (datapath width). Adding more indicators increases resources additively.</li>
</ul>
<h2 id="9-verification-and-testing">9. Verification and Testing</h2>
<h3 id="moving-average-testbench">Moving Average Testbench</h3>
<ul>
<li><strong>Testbench Architecture</strong>: (<code>Moving_average/trading_system_tb.v</code>) Instantiates <code>memory.v</code> (shift register version) and <code>moving_average_fsm.v</code>.</li>
<li><strong>Test Vector Generation</strong>: Feeds 10 linearly increasing prices (1000, 1005,...).</li>
<li><strong>Assertion Strategy</strong>: None implemented; relies on manual waveform inspection and <code>$display</code>.</li>
<li><strong>Result Verification Methodology</strong>: Displays final state; requires manual calculation for verification.</li>
<li><strong>Coverage Analysis</strong>: Not implemented. Likely low coverage due to limited stimulus.</li>
<li><strong>Corner Case Testing</strong>: Not performed in the provided testbench.</li>
</ul>
<h3 id="rsi-testbench">RSI Testbench</h3>
<ul>
<li><strong>Test Pattern Design</strong>: (<code>rsi_verilog_project/rsi_testbench.v</code>) Generates a specific alternating gain/loss pattern (+3, -2) leading to a known RSI=60.</li>
<li><strong>RSI Calculation Verification</strong>: Compares final <code>rsi</code> output with the expected value (implicit check via <code>$display</code>).</li>
<li><strong>State Machine Testing</strong>: Implicitly tests state transitions through the calculation process. Requires waveform analysis for confirmation.</li>
<li><strong>Comprehensive Test Cases</strong>: Only one main pattern tested.</li>
<li><strong>Edge Case Handling Verification</strong>: Does not explicitly test division by zero or other edge cases.</li>
<li><strong>Result Validation Approach</strong>: Displays the final RSI value; manual verification needed.</li>
</ul>
<h3 id="trading-system-testbench">Trading System Testbench</h3>
<ul>
<li><strong>End-to-End Testing Strategy</strong>: (<code>Combined_analysis/tb_trading_system_singlemem.v</code>) Instantiates the top-level <code>trading_system_singlemem</code>.</li>
<li><strong>Integration Test Methodology</strong>: Feeds prices, waits for FIFO fill (<code>mem_cnt == 14</code>), monitors outputs (<code>moving_avg</code>, <code>rsi</code>, <code>buy</code>, <code>sell</code>).</li>
<li><strong>Signal Validation Techniques</strong>: Uses <code>$monitor</code> to display key signals over time. Requires manual inspection.</li>
<li><strong>System-Level Timing Verification</strong>: Implicitly verifies timing through simulation, but no explicit timing checks or assertions.</li>
<li><strong>Output Analysis and Reporting</strong>: Relies on <code>$display</code> and <code>$monitor</code>. VCD dump enabled for waveform analysis.</li>
<li><strong>Regression Testing Framework</strong>: Not implemented.</li>
</ul>
<h3 id="verification-methodology">Verification Methodology</h3>
<ul>
<li><strong>Unit Testing Approach</strong>: Partially applied with separate testbenches for MA and RSI components, but these test different versions than the integrated ones.</li>
<li><strong>Directed Testing</strong>: Primary method used, with specific input patterns.</li>
<li><strong>Functional Verification</strong>: Focuses on basic calculation correctness for the specific test vectors.</li>
<li><strong>Assertion-Based Verification</strong>: Not used.</li>
<li><strong>Performance Verification</strong>: Not explicitly measured (latency/throughput analysis is manual).</li>
<li><strong>Coverage-Driven Verification</strong>: Not used.
<em>Overall</em>: Verification is basic simulation with manual checking. Significant improvements needed for robust validation (self-checking testbenches, assertions, wider range of test cases, coverage).</li>
</ul>
<h2 id="10-usage-guide">10. Usage Guide</h2>
<h3 id="integration-with-larger-systems">Integration with Larger Systems</h3>
<ol>
<li><strong>Top-Level Instantiation</strong>: Instantiate <code>trading_system_singlemem</code> in your higher-level design.<pre class="hljs"><code><div>trading_system_singlemem #(
    <span class="hljs-variable">.WINDOW</span>(<span class="hljs-number">20</span>),       <span class="hljs-comment">// Optional MA window override</span>
    <span class="hljs-variable">.DEPTH</span>(<span class="hljs-number">14</span>),        <span class="hljs-comment">// Optional FIFO depth override (should match RSI window)</span>
    <span class="hljs-variable">.DW</span>(<span class="hljs-number">16</span>),           <span class="hljs-comment">// Optional Data Width override</span>
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">30</span>),  <span class="hljs-comment">// Optional RSI Buy threshold override</span>
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">70</span>)  <span class="hljs-comment">// Optional RSI Sell threshold override</span>
) trading_core_inst (
    <span class="hljs-variable">.clk</span>(your_clk),
    <span class="hljs-variable">.rst</span>(your_rst),
    <span class="hljs-variable">.price_in</span>(your_price_input),       <span class="hljs-comment">// Connect price data source</span>
    <span class="hljs-variable">.new_price</span>(your_price_valid_strobe), <span class="hljs-comment">// Connect price valid signal</span>
    <span class="hljs-variable">.moving_avg</span>(ma_output),          <span class="hljs-comment">// Capture MA result</span>
    <span class="hljs-variable">.rsi</span>(rsi_output),                <span class="hljs-comment">// Capture RSI result</span>
    <span class="hljs-variable">.buy</span>(buy_signal_output),         <span class="hljs-comment">// Use Buy signal</span>
    <span class="hljs-variable">.sell</span>(sell_signal_output),       <span class="hljs-comment">// Use Sell signal</span>
    <span class="hljs-variable">.mem_full</span>(fifo_is_full),         <span class="hljs-comment">// Optional status monitoring</span>
    <span class="hljs-variable">.mem_cnt</span>(fifo_count),            <span class="hljs-comment">// Optional status monitoring</span>
    <span class="hljs-variable">.oldest_price</span>(fifo_oldest),      <span class="hljs-comment">// Optional status monitoring</span>
    <span class="hljs-variable">.ma_done</span>(ma_calc_done),          <span class="hljs-comment">// Optional status monitoring</span>
    <span class="hljs-variable">.rsi_done</span>(rsi_calc_done)         <span class="hljs-comment">// Optional status monitoring</span>
);
</div></code></pre>
</li>
<li><strong>Signal Connection Guidelines</strong>:
<ul>
<li>Connect <code>clk</code> and <code>rst</code> to your system clock and reset.</li>
<li>Provide price data via <code>price_in</code>.</li>
<li>Pulse <code>new_price</code> high for one clock cycle when <code>price_in</code> is valid.</li>
<li>Use <code>buy</code> and <code>sell</code> outputs to trigger trading actions.</li>
<li>Optionally monitor <code>moving_avg</code>, <code>rsi</code>, and status signals (<code>mem_full</code>, <code>*_done</code>).</li>
</ul>
</li>
<li><strong>Clocking Considerations</strong>: Ensure the driving system's clock meets the timing requirements established during synthesis for the trading system core.</li>
<li><strong>Reset Management</strong>: Assert <code>rst</code> for several clock cycles during system initialization.</li>
<li><strong>Interface Protocol</strong>: Simple valid strobe (<code>new_price</code>). Outputs (<code>moving_avg</code>, <code>rsi</code>) are valid when their respective <code>done</code> signals are high (or based on system latency). <code>buy</code>/<code>sell</code> update one cycle after inputs change.</li>
<li><strong>Data Formatting Requirements</strong>: <code>price_in</code> should match the configured <code>DW</code> (default 16-bit unsigned integer).</li>
</ol>
<h3 id="parameter-configuration">Parameter Configuration</h3>
<ul>
<li><strong>Moving Average Configuration</strong>: Set <code>WINDOW</code> parameter in <code>moving_average_fsm</code> (default 20).</li>
<li><strong>RSI Configuration</strong>: Set <code>WINDOW</code> parameter in <code>rsi_inc</code> (default 14). This also dictates the required <code>DEPTH</code> of <code>price_memory</code> (should be &gt;= RSI WINDOW).</li>
<li><strong>Trading Threshold Configuration</strong>: Set <code>BUY_RSI_THR</code> (default 30) and <code>SELL_RSI_THR</code> (default 70) in <code>trading_decision</code>.</li>
<li><strong>Parameter Selection Guidelines</strong>: Choose MA/RSI periods based on trading strategy and timeframe. Adjust RSI thresholds based on market volatility and desired signal frequency. Ensure <code>DW</code> matches price data precision.</li>
<li><strong>Parameter Impact Analysis</strong>: Larger windows increase memory and potentially latency but smooth indicators. Wider <code>DW</code> increases resource usage. Thresholds directly impact signal generation frequency and entry/exit points.</li>
<li><strong>Configuration Management Approach</strong>: Override parameters during instantiation at the top level.</li>
</ul>
<h3 id="example-applications">Example Applications</h3>
<ul>
<li><strong>Basic Trading System</strong>: Use <code>buy</code>/<code>sell</code> signals directly to trigger market orders.</li>
<li><strong>Multi-Instrument Implementation</strong>: Instantiate multiple <code>trading_system_singlemem</code> cores, one for each instrument feed.</li>
<li><strong>Market Data Integration</strong>: Interface the <code>price_in</code>/<code>new_price</code> inputs with a market data feed handler (e.g., FIX parser).</li>
<li><strong>Backtesting Platform</strong>: Drive the core with historical data in simulation for strategy testing.</li>
<li><strong>Real-Time Trading System</strong>: Deploy onto FPGA hardware connected to live market data and order execution APIs.</li>
<li><strong>Research and Development Platform</strong>: Use as a baseline for developing and testing new indicators or strategies in hardware.</li>
</ul>
<h3 id="implementation-workflow">Implementation Workflow</h3>
<ol>
<li><strong>Development Environment Setup</strong>: Install Verilog simulator (ModelSim, Vivado Sim, Verilator) and FPGA synthesis tools (Vivado, Quartus).</li>
<li><strong>Simulation Flow</strong>: Run the provided testbenches (<code>tb_*.v</code>) to verify functionality. Use VCD output for waveform debugging.</li>
<li><strong>Synthesis Process</strong>: Synthesize <code>trading_system_singlemem.v</code> using FPGA tools, targeting a specific device. Apply timing constraints.</li>
<li><strong>Implementation Strategy</strong>: Run Place &amp; Route tools to map the synthesized netlist onto FPGA resources. Analyze resource utilization and timing reports.</li>
<li><strong>Timing Closure Methodology</strong>: Iterate on constraints, RTL modifications (pipelining), or tool options if timing requirements are not met.</li>
<li><strong>Deployment Guidelines</strong>: Generate bitstream file and program onto the target FPGA device. Integrate with external interfaces (data input, order output).</li>
</ol>
<h2 id="11-extension-possibilities">11. Extension Possibilities</h2>
<h3 id="additional-technical-indicators">Additional Technical Indicators</h3>
<ul>
<li><strong>Exponential Moving Average (EMA)</strong>: Requires different calculation logic (recursive formula) but similar memory requirements.</li>
<li><strong>Bollinger Bands</strong>: Requires SMA plus standard deviation calculation over the same window.</li>
<li><strong>MACD Implementation</strong>: Requires calculating two EMAs (e.g., 12-period, 26-period) and their difference, plus an EMA of the difference (signal line).</li>
<li><strong>Stochastic Oscillator</strong>: Requires tracking high/low prices over a window.</li>
<li><strong>Volume Indicators</strong>: Requires adding volume data input and associated calculations (e.g., On-Balance Volume).</li>
<li><strong>Custom Indicator Framework</strong>: Design a generic interface for indicator modules to plug into the system easily.</li>
</ul>
<h3 id="multiple-timeframes">Multiple Timeframes</h3>
<ul>
<li><strong>Timeframe Management Architecture</strong>: Requires logic to aggregate ticks into bars (e.g., 1-minute, 5-minute).</li>
<li><strong>Multi-Timeframe Data Organization</strong>: Store bars for different timeframes, potentially requiring more complex memory structures.</li>
<li><strong>Downsampling Implementation</strong>: Logic to create longer timeframe bars from shorter ones.</li>
<li><strong>Signal Combination Strategy</strong>: Logic to combine signals from different timeframes (e.g., require confirmation across timeframes).</li>
<li><strong>Resource Sharing Approach</strong>: Potentially share lower-level calculations (e.g., tick processing) across timeframes.</li>
<li><strong>System Scalability Considerations</strong>: Resource usage grows significantly with the number of timeframes.</li>
</ul>
<h3 id="advanced-trading-strategies">Advanced Trading Strategies</h3>
<ul>
<li><strong>Moving Average Crossover Implementation</strong>: Instantiate two MA modules with different periods and add logic to detect crossovers.</li>
<li><strong>Multi-Indicator Strategies</strong>: Extend <code>trading_decision</code> logic to incorporate signals from new indicators.</li>
<li><strong>Volatility-Based Position Sizing</strong>: Add volatility indicator (e.g., ATR) and use its output to adjust trade size signals.</li>
<li><strong>Custom Strategy Framework</strong>: Define a standard interface for strategy modules.</li>
<li><strong>Strategy Parameterization Approach</strong>: Pass strategy parameters (thresholds, periods) to modules.</li>
<li><strong>Strategy Performance Metrics</strong>: Add modules to track simulated P&amp;L, win rate, etc., within the FPGA for rapid backtesting.</li>
</ul>
<h3 id="hardware-optimizations">Hardware Optimizations</h3>
<ul>
<li><strong>Pipelining Techniques</strong>: Add registers within long combinational paths (e.g., division) to increase clock frequency.</li>
<li><strong>Fixed-Point Implementation</strong>: Convert integer arithmetic to fixed-point for better precision, especially for division and EMA.</li>
<li><strong>Custom Division Units</strong>: Implement optimized hardware dividers (using DSPs or LUT-based algorithms) instead of relying on synthesis inference.</li>
<li><strong>Multi-Clock Domain Design</strong>: Use faster clocks for computation, slower clocks for interfaces (requires careful CDC).</li>
<li><strong>Resource Sharing Strategies</strong>: Time-multiplex expensive resources like dividers if parallel computation isn't strictly required for throughput.</li>
<li><strong>Power Optimization Approaches</strong>: Clock gating (use vendor primitives carefully), reducing unnecessary switching activity.</li>
</ul>
<h2 id="12-design-considerations-and-tradeoffs">12. Design Considerations and Tradeoffs</h2>
<h3 id="integer-vs-fixed-point-arithmetic">Integer vs. Fixed-Point Arithmetic</h3>
<ul>
<li><strong>Precision Analysis</strong>: Integer loses all fractional information. Fixed-point allows configurable precision but requires careful scaling. Crucial for EMAs or sensitive thresholds.</li>
<li><strong>Resource Impact Comparison</strong>: Fixed-point requires wider datapaths (registers, adders, multipliers), potentially more complex division/multiplication units, increasing LUT/FF/DSP usage.</li>
<li><strong>Implementation Complexity</strong>: Integer is simpler. Fixed-point requires managing scaling factors, potential overflow/underflow during shifts, and rounding.</li>
<li><strong>Error Propagation Characteristics</strong>: Integer truncation errors can accumulate. Fixed-point rounding errors also accumulate but can be managed with sufficient precision (guard bits).</li>
<li><strong>Recommended Implementation Approaches</strong>: Integer for basic SMA/RSI. Fixed-point strongly recommended for EMA, MACD, or strategies sensitive to small price variations.</li>
<li><strong>Migration Strategy</strong>: Parameterize data widths and fractional bits to allow gradual migration.</li>
</ul>
<h3 id="fifo-implementation-tradeoffs">FIFO Implementation Tradeoffs</h3>
<ul>
<li><strong>Shift Register vs. Circular Buffer</strong>:
<ul>
<li><code>Moving_average/memory.v</code> uses shift register: Simpler logic, potentially higher power due to shifting, scales poorly with depth.</li>
<li><code>Combined_analysis/price_memory.v</code> uses circular buffer: More complex pointer logic, lower power (only pointers move), scales well with depth, maps better to BRAM.</li>
</ul>
</li>
<li><strong>Scaling Characteristics</strong>: Circular buffer scales better for DEPTH &gt; ~16-32.</li>
<li><strong>Memory Resource Utilization</strong>: Both can use distributed RAM (LUTRAM) for small depths or Block RAM for larger depths. Circular buffer maps more naturally to BRAM structure.</li>
<li><strong>Access Pattern Efficiency</strong>: Both provide O(1) access to newest (write) and oldest (read) elements in steady state.</li>
<li><strong>Implementation Complexity Comparison</strong>: Shift register is conceptually simpler. Circular buffer requires careful pointer and count management.</li>
<li><strong>Selection Guidelines</strong>: Use circular buffer (like <code>price_memory.v</code>) for scalability and efficiency, especially if BRAM is available.</li>
</ul>
<h3 id="calculation-timing-tradeoffs">Calculation Timing Tradeoffs</h3>
<ul>
<li><strong>Deterministic vs. Variable Latency</strong>: Current design has deterministic latency (fixed number of cycles). Some complex division algorithms might have variable latency. Deterministic is preferred for HFT.</li>
<li><strong>Resource Implications</strong>: Single-cycle complex operations (like division) use more combinational resources and limit clock speed. Multi-cycle/pipelined operations use more registers but allow higher clock speeds.</li>
<li><strong>Throughput Impact Analysis</strong>: Pipelining increases throughput (higher clock speed) but also increases latency. Multi-cycle non-pipelined operations reduce throughput.</li>
<li><strong>Design Simplicity Considerations</strong>: Single-cycle is simplest to control. Pipelining adds complexity.</li>
<li><strong>Application-Specific Selection Criteria</strong>: HFT prioritizes latency. Market making might prioritize throughput. Choose based on system requirements.</li>
<li><strong>Hybrid Approach Possibilities</strong>: Use single-cycle for simple operations, pipelined/multi-cycle for complex ones (like division).</li>
</ul>
<h3 id="state-machine-complexity-tradeoffs">State Machine Complexity Tradeoffs</h3>
<ul>
<li><strong>Simplicity vs. Functionality</strong>: Simple FSMs (like MA FSM) are easy to design/verify but lack features. Complex FSMs (like the 6-state RSI FSM concept) handle more intricate sequences but are harder to get right.</li>
<li><strong>Error Handling Capabilities</strong>: Simple FSMs often lack explicit error states. Complex FSMs can include states for error detection and recovery.</li>
<li><strong>Edge Case Management</strong>: Complex FSMs can have dedicated states/transitions for edge cases (e.g., FIFO empty/full during processing).</li>
<li><strong>Resource Utilization Impact</strong>: More states require wider state registers and more complex next-state/output logic (more LUTs).</li>
<li><strong>Verification Complexity Considerations</strong>: More states/transitions increase verification effort exponentially. State coverage becomes crucial.</li>
<li><strong>Recommended Design Patterns</strong>: Use minimal states for simple tasks. Employ clear state definitions (parameters/enums). Use default assignments and default case statements for robustness. Separate control/datapath for clarity.</li>
</ul>
<h2 id="13-future-work">13. Future Work</h2>
<h3 id="advanced-implementation-features">Advanced Implementation Features</h3>
<ul>
<li><strong>Full Parameterization Framework</strong>: Allow configuration of all periods, widths, and strategies via parameters.</li>
<li><strong>Alternative Moving Average Types</strong>: Implement EMA, WMA modules.</li>
<li><strong>Advanced Strategy Implementations</strong>: Add MACD crossover, Bollinger Band strategies.</li>
<li><strong>Market Data Interface Integration</strong>: Add modules for parsing common market data protocols (e.g., FIX SBE, ITCH).</li>
<li><strong>Configurable Precision Framework</strong>: Implement fixed-point arithmetic with parameterized fractional bits.</li>
<li><strong>Multiple Indicator Framework</strong>: Design a standard interface for adding/combining indicators easily.</li>
</ul>
<h3 id="performance-enhancements">Performance Enhancements</h3>
<ul>
<li><strong>Pipelined Architecture Design</strong>: Pipeline MA and RSI calculations, especially division.</li>
<li><strong>Clock Domain Crossing Techniques</strong>: Implement safe CDC if integrating components running at different clock speeds.</li>
<li><strong>Resource Sharing Implementation</strong>: Explore time-multiplexing expensive units like dividers if multiple instances are needed and throughput allows.</li>
<li><strong>Fixed-Point Arithmetic Conversion</strong>: Convert integer paths to fixed-point for improved accuracy.</li>
<li><strong>Memory Architecture Optimization</strong>: Investigate using dual-port BRAM for more flexible data access if needed.</li>
<li><strong>Timing Optimization Strategies</strong>: Apply advanced synthesis/implementation options (retiming, physical optimization).</li>
</ul>
<h3 id="system-extensions">System Extensions</h3>
<ul>
<li><strong>Backtesting Infrastructure</strong>: Develop modules to read historical data from memory and feed the core for high-speed backtesting on FPGA.</li>
<li><strong>Position Management Module</strong>: Add logic to track current positions, P&amp;L.</li>
<li><strong>Risk Control Framework</strong>: Implement pre-trade risk checks (order size limits, exposure limits).</li>
<li><strong>Multi-Instrument Support</strong>: Parallelize the core architecture to handle multiple trading symbols concurrently.</li>
<li><strong>Order Execution Integration</strong>: Add modules to format and send orders based on <code>buy</code>/<code>sell</code> signals.</li>
<li><strong>Performance Monitoring System</strong>: Implement internal counters for latency, throughput, signal frequency monitoring.</li>
</ul>
<h3 id="verification-improvements">Verification Improvements</h3>
<ul>
<li><strong>Automated Test Framework</strong>: Create scripts for running regression tests automatically.</li>
<li><strong>Reference Model Development</strong>: Develop bit-accurate software models (e.g., Python) for comparison (self-checking testbenches).</li>
<li><strong>Formal Verification Approach</strong>: Use formal methods to prove properties (e.g., FSM state reachability, absence of deadlocks).</li>
<li><strong>Statistical Performance Analysis</strong>: Run simulations with realistic noisy data to analyze strategy performance.</li>
<li><strong>Coverage-Driven Verification Implementation</strong>: Use functional and code coverage metrics to guide test development and ensure comprehensive verification.</li>
<li><strong>Regression Testing Platform</strong>: Set up a system (e.g., Jenkins) for automated regression testing on code changes.</li>
</ul>
<h2 id="14-appendices">14. Appendices</h2>
<p><em>(Note: Generating the actual content for appendices requires running synthesis tools, detailed simulation analysis, and further documentation effort. Below are descriptions of what each appendix would contain.)</em></p>
<h3 id="appendix-a-signal-interface-specifications">Appendix A: Signal Interface Specifications</h3>
<ul>
<li><strong>Module Interface Tables</strong>: Detailed tables for each Verilog module listing all ports, directions, widths, and descriptions.</li>
<li><strong>Timing Diagrams</strong>: Waveform diagrams illustrating key interface protocols (e.g., <code>new_price</code> strobe, <code>start</code>/<code>done</code> handshakes).</li>
<li><strong>Protocol Specifications</strong>: Formal description of how signals interact (e.g., sequence for triggering calculations).</li>
<li><strong>Signal Constraints</strong>: Any specific setup/hold requirements or constraints on input signals.</li>
<li><strong>Default Values and Reset States</strong>: Value of all outputs and key internal registers immediately after reset.</li>
</ul>
<h3 id="appendix-b-algorithm-details">Appendix B: Algorithm Details</h3>
<ul>
<li><strong>Moving Average Calculation Derivation</strong>: Mathematical steps for the simple moving average and the sliding window optimization.</li>
<li><strong>RSI Formula Mathematical Foundation</strong>: Detailed derivation of the RSI formula, including the gain/loss calculation and averaging methods (simple vs. smoothed).</li>
<li><strong>Trading Strategy Mathematical Analysis</strong>: Equations defining the buy/sell conditions implemented in <code>trading_decision.v</code>.</li>
<li><strong>Optimization Algorithm Derivations</strong>: Mathematical justification for register widths (overflow analysis) or division optimizations.</li>
</ul>
<h3 id="appendix-c-resource-utilization-data">Appendix C: Resource Utilization Data</h3>
<ul>
<li><strong>FPGA Resource Tables</strong>: Tables showing estimated/actual resource usage (LUTs, FFs, BRAM, DSPs) for each module and the top-level system, synthesized for a specific target FPGA device (e.g., Xilinx Artix-7).</li>
<li><strong>Synthesis Results Analysis</strong>: Summary of synthesis reports, including maximum achievable clock frequency (Fmax).</li>
<li><strong>Device-Specific Optimization Notes</strong>: Tips for optimizing the design for specific FPGA families.</li>
<li><strong>Scaling Data</strong>: Estimated resource usage as parameters like <code>DEPTH</code> or <code>DW</code> are varied.</li>
</ul>
<h3 id="appendix-d-performance-benchmarks">Appendix D: Performance Benchmarks</h3>
<ul>
<li><strong>Latency Measurements</strong>: Cycle counts (and nanoseconds at target frequency) for different paths (input-to-MA, input-to-RSI, input-to-signal).</li>
<li><strong>Throughput Benchmarks</strong>: Maximum sustained input rate (equal to clock frequency).</li>
<li><strong>Clock Frequency Analysis</strong>: Fmax results from synthesis for different target devices or optimization levels.</li>
<li><strong>Power Consumption Data</strong>: Estimated or measured power consumption breakdown (static, dynamic) from FPGA tools.</li>
<li><strong>Comparison with Software Implementations</strong>: Theoretical or measured speedup compared to CPU-based implementations of the same algorithms.</li>
</ul>
<h3 id="appendix-e-verification-test-cases">Appendix E: Verification Test Cases</h3>
<ul>
<li><strong>Test Vector Specifications</strong>: Detailed listing of input price sequences used in different test cases (e.g., ramp, sine wave, step change, historical data segment).</li>
<li><strong>Expected Results Documentation</strong>: Corresponding expected outputs (MA, RSI, buy/sell signals) for each test vector, ideally generated from a reference model.</li>
<li><strong>Corner Case Definitions</strong>: Specific tests for conditions like zero price change, division by zero in RSI, FIFO full/empty transitions.</li>
<li><strong>Verification Coverage Analysis</strong>: Reports from coverage tools showing achieved code and functional coverage percentages.</li>
</ul>
<h2 id="15-license">15. License</h2>
<h2 id="license">License</h2>
<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>
<pre class="hljs"><code><div>MIT License

Copyright (c) 2025 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</div></code></pre>
<pre class="hljs"><code><div></div></code></pre>

</body>
</html>
