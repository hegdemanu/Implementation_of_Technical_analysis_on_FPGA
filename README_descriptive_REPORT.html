<!DOCTYPE html>
<html>
<head>
<title>README_descriptive_REPORT.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="fpga-based-technical-analysis-trading-system-comprehensive-documentation">FPGA-Based Technical Analysis Trading System: Comprehensive Documentation</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li>
<p><a href="#introduction">Introduction</a></p>
<ul>
<li><a href="#project-overview">Project Overview</a></li>
<li><a href="#technical-analysis-in-trading">Technical Analysis in Trading</a></li>
<li><a href="#hardware-acceleration-benefits">Hardware Acceleration Benefits</a></li>
<li><a href="#target-applications">Target Applications</a></li>
<li><a href="#fpga-implementation-advantages">FPGA Implementation Advantages</a></li>
<li><a href="#system-capabilities">System Capabilities</a></li>
</ul>
</li>
<li>
<p><a href="#repository-structure">Repository Structure</a></p>
<ul>
<li><a href="#directory-organization">Directory Organization</a></li>
<li><a href="#combined-analysis-components">Combined Analysis Components</a></li>
<li><a href="#moving-average-specific-components">Moving Average Specific Components</a></li>
<li><a href="#rsi-specific-components">RSI Specific Components</a></li>
<li><a href="#file-naming-conventions">File Naming Conventions</a></li>
<li><a href="#documentation-approach">Documentation Approach</a></li>
</ul>
</li>
<li>
<p><a href="#system-architecture">System Architecture</a></p>
<ul>
<li><a href="#high-level-design">High-Level Design</a></li>
<li><a href="#module-interactions">Module Interactions</a></li>
<li><a href="#data-flow-architecture">Data Flow Architecture</a></li>
<li><a href="#clock-domain-strategy">Clock Domain Strategy</a></li>
<li><a href="#control-flow-management">Control Flow Management</a></li>
<li><a href="#interface-specifications">Interface Specifications</a></li>
<li><a href="#system-integration-principles">System Integration Principles</a></li>
</ul>
</li>
<li>
<p><a href="#technical-indicators-implementation">Technical Indicators Implementation</a></p>
<ul>
<li>
<p><a href="#moving-average-implementation">Moving Average Implementation</a></p>
<ul>
<li><a href="#principles-and-theory">Principles and Theory</a></li>
<li><a href="#implementation-algorithm">Implementation Algorithm</a></li>
<li><a href="#optimization-techniques">Optimization Techniques</a></li>
<li><a href="#parameter-configuration">Parameter Configuration</a></li>
<li><a href="#fsm-design-details">FSM Design Details</a></li>
<li><a href="#precision-considerations">Precision Considerations</a></li>
</ul>
</li>
<li>
<p><a href="#rsi-implementation">RSI Implementation</a></p>
<ul>
<li><a href="#rsi-theory-and-calculation">RSI Theory and Calculation</a></li>
<li><a href="#fsm-implementation-approach">FSM Implementation Approach</a></li>
<li><a href="#gainloss-accumulation">Gain/Loss Accumulation</a></li>
<li><a href="#final-calculation-method">Final Calculation Method</a></li>
<li><a href="#edge-case-handling">Edge Case Handling</a></li>
<li><a href="#optimization-details">Optimization Details</a></li>
</ul>
</li>
<li>
<p><a href="#trading-decision-logic">Trading Decision Logic</a></p>
<ul>
<li><a href="#strategy-implementation">Strategy Implementation</a></li>
<li><a href="#signal-generation-criteria">Signal Generation Criteria</a></li>
<li><a href="#threshold-configuration">Threshold Configuration</a></li>
<li><a href="#logic-implementation-details">Logic Implementation Details</a></li>
<li><a href="#signal-timing-considerations">Signal Timing Considerations</a></li>
<li><a href="#extensibility-features">Extensibility Features</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#hardware-design-approach">Hardware Design Approach</a></p>
<ul>
<li>
<p><a href="#memory-management">Memory Management</a></p>
<ul>
<li><a href="#circular-buffer-design">Circular Buffer Design</a></li>
<li><a href="#pointer-management-strategy">Pointer Management Strategy</a></li>
<li><a href="#memory-access-patterns">Memory Access Patterns</a></li>
<li><a href="#fifo-implementation">FIFO Implementation</a></li>
<li><a href="#overflowunderflow-protection">Overflow/Underflow Protection</a></li>
</ul>
</li>
<li>
<p><a href="#computational-efficiency">Computational Efficiency</a></p>
<ul>
<li><a href="#sliding-window-algorithm-details">Sliding Window Algorithm Details</a></li>
<li><a href="#register-sizing-optimization">Register Sizing Optimization</a></li>
<li><a href="#division-implementation-strategies">Division Implementation Strategies</a></li>
<li><a href="#fixed-point-vs-integer-arithmetic">Fixed Point vs Integer Arithmetic</a></li>
<li><a href="#computation-reuse-techniques">Computation Reuse Techniques</a></li>
</ul>
</li>
<li>
<p><a href="#control-logic">Control Logic</a></p>
<ul>
<li><a href="#fsm-implementation-principles">FSM Implementation Principles</a></li>
<li><a href="#state-encoding-techniques">State Encoding Techniques</a></li>
<li><a href="#control-datapath-separation">Control-Datapath Separation</a></li>
<li><a href="#state-transition-management">State Transition Management</a></li>
<li><a href="#reset-strategy">Reset Strategy</a></li>
<li><a href="#flag-and-control-signal-design">Flag and Control Signal Design</a></li>
</ul>
</li>
<li>
<p><a href="#system-integration">System Integration</a></p>
<ul>
<li><a href="#clock-domain-management">Clock Domain Management</a></li>
<li><a href="#parallel-processing-approach">Parallel Processing Approach</a></li>
<li><a href="#synchronous-design-principles">Synchronous Design Principles</a></li>
<li><a href="#interface-definition-standards">Interface Definition Standards</a></li>
<li><a href="#timing-closure-strategies">Timing Closure Strategies</a></li>
<li><a href="#resource-sharing-approaches">Resource Sharing Approaches</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#modules-documentation">Modules Documentation</a></p>
<ul>
<li>
<p><a href="#moving-average-system">Moving Average System</a></p>
<ul>
<li><a href="#memory-module-details">Memory Module Details</a></li>
<li><a href="#moving-average-fsm-implementation">Moving Average FSM Implementation</a></li>
<li><a href="#port-descriptions-and-timing">Port Descriptions and Timing</a></li>
<li><a href="#internal-register-architecture">Internal Register Architecture</a></li>
<li><a href="#state-machine-design">State Machine Design</a></li>
<li><a href="#signal-timing-relationships">Signal Timing Relationships</a></li>
<li><a href="#module-constraints">Module Constraints</a></li>
<li><a href="#integration-guidelines">Integration Guidelines</a></li>
</ul>
</li>
<li>
<p><a href="#rsi-calculator">RSI Calculator</a></p>
<ul>
<li><a href="#price-fifo-module-details">Price FIFO Module Details</a></li>
<li><a href="#rsi-fsm-module-implementation">RSI FSM Module Implementation</a></li>
<li><a href="#state-machine-deep-dive">State Machine Deep Dive</a></li>
<li><a href="#calculation-logic-details">Calculation Logic Details</a></li>
<li><a href="#timing-requirements">Timing Requirements</a></li>
<li><a href="#resource-utilization-analysis">Resource Utilization Analysis</a></li>
<li><a href="#interface-specifications-1">Interface Specifications</a></li>
<li><a href="#integration-considerations">Integration Considerations</a></li>
</ul>
</li>
<li>
<p><a href="#trading-decision-system">Trading Decision System</a></p>
<ul>
<li><a href="#module-implementation-details">Module Implementation Details</a></li>
<li><a href="#signal-processing-logic">Signal Processing Logic</a></li>
<li><a href="#threshold-management">Threshold Management</a></li>
<li><a href="#signal-generation-implementation">Signal Generation Implementation</a></li>
<li><a href="#timing-characteristics">Timing Characteristics</a></li>
<li><a href="#parameterization-details">Parameterization Details</a></li>
<li><a href="#extension-options">Extension Options</a></li>
</ul>
</li>
<li>
<p><a href="#price-memory-fifo">Price Memory (FIFO)</a></p>
<ul>
<li><a href="#circular-buffer-implementation-details">Circular Buffer Implementation Details</a></li>
<li><a href="#readwrite-pointer-management">Read/Write Pointer Management</a></li>
<li><a href="#fullempty-flag-generation">Full/Empty Flag Generation</a></li>
<li><a href="#data-access-timing">Data Access Timing</a></li>
<li><a href="#reset-behavior">Reset Behavior</a></li>
<li><a href="#parameterization-options">Parameterization Options</a></li>
<li><a href="#resource-efficiency-techniques">Resource Efficiency Techniques</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#implementation-optimizations">Implementation Optimizations</a></p>
<ul>
<li>
<p><a href="#sliding-window-optimization">Sliding Window Optimization</a></p>
<ul>
<li><a href="#algorithm-details">Algorithm Details</a></li>
<li><a href="#computational-complexity-analysis">Computational Complexity Analysis</a></li>
<li><a href="#hardware-implementation-efficiency">Hardware Implementation Efficiency</a></li>
<li><a href="#comparison-with-alternative-approaches">Comparison with Alternative Approaches</a></li>
</ul>
</li>
<li>
<p><a href="#memory-usage-optimization">Memory Usage Optimization</a></p>
<ul>
<li><a href="#circular-buffer-efficiency">Circular Buffer Efficiency</a></li>
<li><a href="#pointer-management-details">Pointer Management Details</a></li>
<li><a href="#memory-architecture-considerations">Memory Architecture Considerations</a></li>
<li><a href="#fpga-specific-memory-optimizations">FPGA-Specific Memory Optimizations</a></li>
</ul>
</li>
<li>
<p><a href="#register-width-optimization">Register Width Optimization</a></p>
<ul>
<li><a href="#precision-requirements-analysis">Precision Requirements Analysis</a></li>
<li><a href="#overflow-prevention-strategies">Overflow Prevention Strategies</a></li>
<li><a href="#resource-utilization-tradeoffs">Resource Utilization Tradeoffs</a></li>
<li><a href="#bit-width-selection-methodology">Bit Width Selection Methodology</a></li>
</ul>
</li>
<li>
<p><a href="#parameterized-design-techniques">Parameterized Design Techniques</a></p>
<ul>
<li><a href="#parameter-definition-strategy">Parameter Definition Strategy</a></li>
<li><a href="#compile-time-configurability">Compile-Time Configurability</a></li>
<li><a href="#design-reuse-approaches">Design Reuse Approaches</a></li>
<li><a href="#implementation-flexibility">Implementation Flexibility</a></li>
<li><a href="#parameter-propagation-methodology">Parameter Propagation Methodology</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#performance-considerations">Performance Considerations</a></p>
<ul>
<li>
<p><a href="#clock-domain-analysis">Clock Domain Analysis</a></p>
<ul>
<li><a href="#single-domain-advantages">Single Domain Advantages</a></li>
<li><a href="#clock-frequency-selection">Clock Frequency Selection</a></li>
<li><a href="#fpga-clock-management">FPGA Clock Management</a></li>
<li><a href="#timing-constraint-approach">Timing Constraint Approach</a></li>
</ul>
</li>
<li>
<p><a href="#calculation-latency-details">Calculation Latency Details</a></p>
<ul>
<li><a href="#moving-average-latency-analysis">Moving Average Latency Analysis</a></li>
<li><a href="#rsi-latency-analysis">RSI Latency Analysis</a></li>
<li><a href="#end-to-end-system-latency">End-to-End System Latency</a></li>
<li><a href="#critical-path-identification">Critical Path Identification</a></li>
<li><a href="#latency-optimization-strategies">Latency Optimization Strategies</a></li>
</ul>
</li>
<li>
<p><a href="#throughput-analysis">Throughput Analysis</a></p>
<ul>
<li><a href="#maximum-throughput-calculation">Maximum Throughput Calculation</a></li>
<li><a href="#sustained-performance-evaluation">Sustained Performance Evaluation</a></li>
<li><a href="#bottleneck-identification">Bottleneck Identification</a></li>
<li><a href="#throughput-enhancement-techniques">Throughput Enhancement Techniques</a></li>
</ul>
</li>
<li>
<p><a href="#synchronization-strategy">Synchronization Strategy</a></p>
<ul>
<li><a href="#parallel-calculation-management">Parallel Calculation Management</a></li>
<li><a href="#trigger-signal-distribution">Trigger Signal Distribution</a></li>
<li><a href="#handshaking-protocol-design">Handshaking Protocol Design</a></li>
<li><a href="#pipeline-balancing-approach">Pipeline Balancing Approach</a></li>
</ul>
</li>
<li>
<p><a href="#resource-utilization">Resource Utilization</a></p>
<ul>
<li><a href="#fpga-resource-analysis">FPGA Resource Analysis</a></li>
<li><a href="#logic-element-requirements">Logic Element Requirements</a></li>
<li><a href="#memory-utilization">Memory Utilization</a></li>
<li><a href="#dsp-block-usage">DSP Block Usage</a></li>
<li><a href="#scaling-considerations">Scaling Considerations</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#verification-and-testing">Verification and Testing</a></p>
<ul>
<li>
<p><a href="#moving-average-testbench">Moving Average Testbench</a></p>
<ul>
<li><a href="#testbench-architecture">Testbench Architecture</a></li>
<li><a href="#test-vector-generation">Test Vector Generation</a></li>
<li><a href="#assertion-strategy">Assertion Strategy</a></li>
<li><a href="#result-verification-methodology">Result Verification Methodology</a></li>
<li><a href="#coverage-analysis">Coverage Analysis</a></li>
<li><a href="#corner-case-testing">Corner Case Testing</a></li>
</ul>
</li>
<li>
<p><a href="#rsi-testbench">RSI Testbench</a></p>
<ul>
<li><a href="#test-pattern-design">Test Pattern Design</a></li>
<li><a href="#rsi-calculation-verification">RSI Calculation Verification</a></li>
<li><a href="#state-machine-testing">State Machine Testing</a></li>
<li><a href="#comprehensive-test-cases">Comprehensive Test Cases</a></li>
<li><a href="#edge-case-handling-verification">Edge Case Handling Verification</a></li>
<li><a href="#result-validation-approach">Result Validation Approach</a></li>
</ul>
</li>
<li>
<p><a href="#trading-system-testbench">Trading System Testbench</a></p>
<ul>
<li><a href="#end-to-end-testing-strategy">End-to-End Testing Strategy</a></li>
<li><a href="#integration-test-methodology">Integration Test Methodology</a></li>
<li><a href="#signal-validation-techniques">Signal Validation Techniques</a></li>
<li><a href="#system-level-timing-verification">System-Level Timing Verification</a></li>
<li><a href="#output-analysis-and-reporting">Output Analysis and Reporting</a></li>
<li><a href="#regression-testing-framework">Regression Testing Framework</a></li>
</ul>
</li>
<li>
<p><a href="#verification-methodology">Verification Methodology</a></p>
<ul>
<li><a href="#unit-testing-approach">Unit Testing Approach</a></li>
<li><a href="#directed-testing">Directed Testing</a></li>
<li><a href="#functional-verification">Functional Verification</a></li>
<li><a href="#assertion-based-verification">Assertion-Based Verification</a></li>
<li><a href="#performance-verification">Performance Verification</a></li>
<li><a href="#coverage-driven-verification">Coverage-Driven Verification</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#usage-guide">Usage Guide</a></p>
<ul>
<li>
<p><a href="#integration-with-larger-systems">Integration with Larger Systems</a></p>
<ul>
<li><a href="#top-level-instantiation">Top-Level Instantiation</a></li>
<li><a href="#signal-connection-guidelines">Signal Connection Guidelines</a></li>
<li><a href="#clocking-considerations">Clocking Considerations</a></li>
<li><a href="#reset-management">Reset Management</a></li>
<li><a href="#interface-protocol">Interface Protocol</a></li>
<li><a href="#data-formatting-requirements">Data Formatting Requirements</a></li>
</ul>
</li>
<li>
<p><a href="#parameter-configuration-1">Parameter Configuration</a></p>
<ul>
<li><a href="#moving-average-configuration">Moving Average Configuration</a></li>
<li><a href="#rsi-configuration">RSI Configuration</a></li>
<li><a href="#trading-threshold-configuration">Trading Threshold Configuration</a></li>
<li><a href="#parameter-selection-guidelines">Parameter Selection Guidelines</a></li>
<li><a href="#parameter-impact-analysis">Parameter Impact Analysis</a></li>
<li><a href="#configuration-management-approach">Configuration Management Approach</a></li>
</ul>
</li>
<li>
<p><a href="#example-applications">Example Applications</a></p>
<ul>
<li><a href="#basic-trading-system">Basic Trading System</a></li>
<li><a href="#multi-instrument-implementation">Multi-Instrument Implementation</a></li>
<li><a href="#market-data-integration">Market Data Integration</a></li>
<li><a href="#backtesting-platform">Backtesting Platform</a></li>
<li><a href="#real-time-trading-system">Real-Time Trading System</a></li>
<li><a href="#research-and-development-platform">Research and Development Platform</a></li>
</ul>
</li>
<li>
<p><a href="#implementation-workflow">Implementation Workflow</a></p>
<ul>
<li><a href="#development-environment-setup">Development Environment Setup</a></li>
<li><a href="#simulation-flow">Simulation Flow</a></li>
<li><a href="#synthesis-process">Synthesis Process</a></li>
<li><a href="#implementation-strategy">Implementation Strategy</a></li>
<li><a href="#timing-closure-methodology">Timing Closure Methodology</a></li>
<li><a href="#deployment-guidelines">Deployment Guidelines</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#extension-possibilities">Extension Possibilities</a></p>
<ul>
<li>
<p><a href="#additional-technical-indicators">Additional Technical Indicators</a></p>
<ul>
<li><a href="#exponential-moving-average">Exponential Moving Average</a></li>
<li><a href="#bollinger-bands">Bollinger Bands</a></li>
<li><a href="#macd-implementation">MACD Implementation</a></li>
<li><a href="#stochastic-oscillator">Stochastic Oscillator</a></li>
<li><a href="#volume-indicators">Volume Indicators</a></li>
<li><a href="#custom-indicator-framework">Custom Indicator Framework</a></li>
</ul>
</li>
<li>
<p><a href="#multiple-timeframes">Multiple Timeframes</a></p>
<ul>
<li><a href="#timeframe-management-architecture">Timeframe Management Architecture</a></li>
<li><a href="#multi-timeframe-data-organization">Multi-Timeframe Data Organization</a></li>
<li><a href="#downsampling-implementation">Downsampling Implementation</a></li>
<li><a href="#signal-combination-strategy">Signal Combination Strategy</a></li>
<li><a href="#resource-sharing-approach">Resource Sharing Approach</a></li>
<li><a href="#system-scalability-considerations">System Scalability Considerations</a></li>
</ul>
</li>
<li>
<p><a href="#advanced-trading-strategies">Advanced Trading Strategies</a></p>
<ul>
<li><a href="#moving-average-crossover-implementation">Moving Average Crossover Implementation</a></li>
<li><a href="#multi-indicator-strategies">Multi-Indicator Strategies</a></li>
<li><a href="#volatility-based-position-sizing">Volatility-Based Position Sizing</a></li>
<li><a href="#custom-strategy-framework">Custom Strategy Framework</a></li>
<li><a href="#strategy-parameterization-approach">Strategy Parameterization Approach</a></li>
<li><a href="#strategy-performance-metrics">Strategy Performance Metrics</a></li>
</ul>
</li>
<li>
<p><a href="#hardware-optimizations">Hardware Optimizations</a></p>
<ul>
<li><a href="#pipelining-techniques">Pipelining Techniques</a></li>
<li><a href="#fixed-point-implementation">Fixed-Point Implementation</a></li>
<li><a href="#custom-division-units">Custom Division Units</a></li>
<li><a href="#multi-clock-domain-design">Multi-Clock Domain Design</a></li>
<li><a href="#resource-sharing-strategies">Resource Sharing Strategies</a></li>
<li><a href="#power-optimization-approaches">Power Optimization Approaches</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#design-considerations-and-tradeoffs">Design Considerations and Tradeoffs</a></p>
<ul>
<li>
<p><a href="#integer-vs-fixed-point-arithmetic-1">Integer vs. Fixed-Point Arithmetic</a></p>
<ul>
<li><a href="#precision-analysis">Precision Analysis</a></li>
<li><a href="#resource-impact-comparison">Resource Impact Comparison</a></li>
<li><a href="#implementation-complexity">Implementation Complexity</a></li>
<li><a href="#error-propagation-characteristics">Error Propagation Characteristics</a></li>
<li><a href="#recommended-implementation-approaches">Recommended Implementation Approaches</a></li>
<li><a href="#migration-strategy">Migration Strategy</a></li>
</ul>
</li>
<li>
<p><a href="#fifo-implementation-tradeoffs">FIFO Implementation Tradeoffs</a></p>
<ul>
<li><a href="#shift-register-vs-circular-buffer">Shift Register vs. Circular Buffer</a></li>
<li><a href="#scaling-characteristics">Scaling Characteristics</a></li>
<li><a href="#memory-resource-utilization">Memory Resource Utilization</a></li>
<li><a href="#access-pattern-efficiency">Access Pattern Efficiency</a></li>
<li><a href="#implementation-complexity-comparison">Implementation Complexity Comparison</a></li>
<li><a href="#selection-guidelines">Selection Guidelines</a></li>
</ul>
</li>
<li>
<p><a href="#calculation-timing-tradeoffs">Calculation Timing Tradeoffs</a></p>
<ul>
<li><a href="#deterministic-vs-variable-latency">Deterministic vs. Variable Latency</a></li>
<li><a href="#resource-implications">Resource Implications</a></li>
<li><a href="#throughput-impact-analysis">Throughput Impact Analysis</a></li>
<li><a href="#design-simplicity-considerations">Design Simplicity Considerations</a></li>
<li><a href="#application-specific-selection-criteria">Application-Specific Selection Criteria</a></li>
<li><a href="#hybrid-approach-possibilities">Hybrid Approach Possibilities</a></li>
</ul>
</li>
<li>
<p><a href="#state-machine-complexity-tradeoffs">State Machine Complexity Tradeoffs</a></p>
<ul>
<li><a href="#simplicity-vs-functionality">Simplicity vs. Functionality</a></li>
<li><a href="#error-handling-capabilities">Error Handling Capabilities</a></li>
<li><a href="#edge-case-management">Edge Case Management</a></li>
<li><a href="#resource-utilization-impact">Resource Utilization Impact</a></li>
<li><a href="#verification-complexity-considerations">Verification Complexity Considerations</a></li>
<li><a href="#recommended-design-patterns">Recommended Design Patterns</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#future-work">Future Work</a></p>
<ul>
<li>
<p><a href="#advanced-implementation-features">Advanced Implementation Features</a></p>
<ul>
<li><a href="#full-parameterization-framework">Full Parameterization Framework</a></li>
<li><a href="#alternative-moving-average-types">Alternative Moving Average Types</a></li>
<li><a href="#advanced-strategy-implementations">Advanced Strategy Implementations</a></li>
<li><a href="#market-data-interface-integration">Market Data Interface Integration</a></li>
<li><a href="#configurable-precision-framework">Configurable Precision Framework</a></li>
<li><a href="#multiple-indicator-framework">Multiple Indicator Framework</a></li>
</ul>
</li>
<li>
<p><a href="#performance-enhancements">Performance Enhancements</a></p>
<ul>
<li><a href="#pipelined-architecture-design">Pipelined Architecture Design</a></li>
<li><a href="#clock-domain-crossing-techniques">Clock Domain Crossing Techniques</a></li>
<li><a href="#resource-sharing-implementation">Resource Sharing Implementation</a></li>
<li><a href="#fixed-point-arithmetic-conversion">Fixed-Point Arithmetic Conversion</a></li>
<li><a href="#memory-architecture-optimization">Memory Architecture Optimization</a></li>
<li><a href="#timing-optimization-strategies">Timing Optimization Strategies</a></li>
</ul>
</li>
<li>
<p><a href="#system-extensions">System Extensions</a></p>
<ul>
<li><a href="#backtesting-infrastructure">Backtesting Infrastructure</a></li>
<li><a href="#position-management-module">Position Management Module</a></li>
<li><a href="#risk-control-framework">Risk Control Framework</a></li>
<li><a href="#multi-instrument-support">Multi-Instrument Support</a></li>
<li><a href="#order-execution-integration">Order Execution Integration</a></li>
<li><a href="#performance-monitoring-system">Performance Monitoring System</a></li>
</ul>
</li>
<li>
<p><a href="#verification-improvements">Verification Improvements</a></p>
<ul>
<li><a href="#automated-test-framework">Automated Test Framework</a></li>
<li><a href="#reference-model-development">Reference Model Development</a></li>
<li><a href="#formal-verification-approach">Formal Verification Approach</a></li>
<li><a href="#statistical-performance-analysis">Statistical Performance Analysis</a></li>
<li><a href="#coverage-driven-verification-implementation">Coverage-Driven Verification Implementation</a></li>
<li><a href="#regression-testing-platform">Regression Testing Platform</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#appendices">Appendices</a></p>
<ul>
<li>
<p><a href="#appendix-a-signal-interface-specifications">Appendix A: Signal Interface Specifications</a></p>
<ul>
<li><a href="#module-interface-tables">Module Interface Tables</a></li>
<li><a href="#timing-diagrams">Timing Diagrams</a></li>
<li><a href="#protocol-specifications">Protocol Specifications</a></li>
<li><a href="#signal-constraints">Signal Constraints</a></li>
<li><a href="#default-values-and-reset-states">Default Values and Reset States</a></li>
</ul>
</li>
<li>
<p><a href="#appendix-b-algorithm-details">Appendix B: Algorithm Details</a></p>
<ul>
<li><a href="#moving-average-calculation-derivation">Moving Average Calculation Derivation</a></li>
<li><a href="#rsi-formula-mathematical-foundation">RSI Formula Mathematical Foundation</a></li>
<li><a href="#trading-strategy-mathematical-analysis">Trading Strategy Mathematical Analysis</a></li>
<li><a href="#optimization-algorithm-derivations">Optimization Algorithm Derivations</a></li>
</ul>
</li>
<li>
<p><a href="#appendix-c-resource-utilization-data">Appendix C: Resource Utilization Data</a></p>
<ul>
<li><a href="#fpga-resource-tables">FPGA Resource Tables</a></li>
<li><a href="#synthesis-results-analysis">Synthesis Results Analysis</a></li>
<li><a href="#device-specific-optimization-notes">Device-Specific Optimization Notes</a></li>
<li><a href="#scaling-data">Scaling Data</a></li>
</ul>
</li>
<li>
<p><a href="#appendix-d-performance-benchmarks">Appendix D: Performance Benchmarks</a></p>
<ul>
<li><a href="#latency-measurements">Latency Measurements</a></li>
<li><a href="#throughput-benchmarks">Throughput Benchmarks</a></li>
<li><a href="#clock-frequency-analysis">Clock Frequency Analysis</a></li>
<li><a href="#power-consumption-data">Power Consumption Data</a></li>
<li><a href="#comparison-with-software-implementations">Comparison with Software Implementations</a></li>
</ul>
</li>
<li>
<p><a href="#appendix-e-verification-test-cases">Appendix E: Verification Test Cases</a></p>
<ul>
<li><a href="#test-vector-specifications">Test Vector Specifications</a></li>
<li><a href="#expected-results-documentation">Expected Results Documentation</a></li>
<li><a href="#corner-case-definitions">Corner Case Definitions</a></li>
<li><a href="#verification-coverage-analysis">Verification Coverage Analysis</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#license">License</a></p>
</li>
</ol>
<hr>
<h2 id="1-introduction">1. Introduction</h2>
<h3 id="project-overview">Project Overview</h3>
<p>This comprehensive project implements a hardware-accelerated technical analysis system for financial trading applications using FPGA technology. The design focuses on efficient computation of widely-used technical indicators, including Simple Moving Average (SMA) and Relative Strength Index (RSI), combined with configurable trading decision logic to generate buy and sell signals.</p>
<p>The implementation leverages hardware-specific optimization techniques, applying digital design principles to achieve deterministic, low-latency processing essential for high-frequency trading applications. The design follows a modular architecture with clean separation between components, enabling flexible customization and extension for diverse trading strategies and market environments.</p>
<p>Key objectives of this project include:</p>
<ol>
<li>Demonstrating efficient hardware implementation of common technical indicators</li>
<li>Providing a platform for algorithmic trading strategy development</li>
<li>Showcasing digital design principles applied to financial analysis</li>
<li>Delivering a framework that balances performance with resource utilization</li>
<li>Creating a foundation for extension with additional indicators and strategies</li>
<li>Establishing verification methodologies appropriate for financial applications</li>
</ol>
<p>The system targets FPGA platforms where deterministic processing of market data streams is required, providing significant performance advantages over software implementations while maintaining flexibility through parameterized design.</p>
<h3 id="technical-analysis-in-trading">Technical Analysis in Trading</h3>
<p>Technical analysis in financial markets involves studying price movements and patterns to forecast future price behavior. Unlike fundamental analysis, which examines economic factors and company metrics, technical analysis focuses exclusively on market data, primarily price and volume information. The approach is based on the premise that price action encompasses all relevant market information and that price movements are not completely random but form identifiable patterns over time.</p>
<p>Key principles of technical analysis include:</p>
<ol>
<li><strong>Price Discounts Everything</strong>: All relevant information (economic, political, psychological) is already reflected in price movements.</li>
<li><strong>Price Moves in Trends</strong>: Once established, trends are more likely to continue than reverse.</li>
<li><strong>History Tends to Repeat</strong>: Market patterns and behaviors recur in predictable ways.</li>
</ol>
<p>Technical indicators are mathematical calculations based on price, volume, or open interest that aim to forecast future price movements. These indicators serve several purposes:</p>
<ul>
<li><strong>Trend Identification</strong>: Determining whether the market is in an uptrend, downtrend, or moving sideways</li>
<li><strong>Momentum Measurement</strong>: Assessing the strength or weakness of a trend</li>
<li><strong>Support/Resistance Level Identification</strong>: Finding price levels where trends may reverse</li>
<li><strong>Volatility Analysis</strong>: Measuring market stability or instability</li>
<li><strong>Overbought/Oversold Conditions</strong>: Identifying potential reversal points</li>
</ul>
<p>This project implements two foundational technical indicators:</p>
<ol>
<li>
<p><strong>Simple Moving Average (SMA)</strong>: The arithmetic mean of a set of prices over a specific period, providing a smoothed price curve that helps identify trends by filtering out short-term fluctuations.</p>
</li>
<li>
<p><strong>Relative Strength Index (RSI)</strong>: A momentum oscillator that measures the speed and change of price movements, ranging from 0 to 100 and helping identify potential overbought (values above 70) or oversold (values below 30) conditions.</p>
</li>
</ol>
<p>These indicators, when combined with appropriate trading logic, form the basis for many algorithmic trading strategies, from simple trend-following systems to complex multi-factor approaches.</p>
<h3 id="hardware-acceleration-benefits">Hardware Acceleration Benefits</h3>
<p>Hardware acceleration provides significant advantages for technical analysis and trading applications, delivering performance characteristics that are difficult or impossible to achieve with software implementations alone. Key benefits include:</p>
<ol>
<li>
<p><strong>Deterministic Latency</strong>: Hardware implementations provide consistent, predictable processing times, eliminating the variability inherent in software execution. This determinism is critical for trading systems where timing precision can significantly impact profitability.</p>
</li>
<li>
<p><strong>Ultra-Low Latency</strong>: FPGAs can process market data with nanosecond to microsecond latency, compared to millisecond-scale processing in typical software systems. This order-of-magnitude improvement enables:</p>
<ul>
<li>Faster reaction to market movements</li>
<li>More precise order timing</li>
<li>Ability to capitalize on short-lived market inefficiencies</li>
<li>Reduced slippage in execution</li>
</ul>
</li>
<li>
<p><strong>High Throughput</strong>: Hardware implementations can process millions of market updates per second, enabling:</p>
<ul>
<li>Simultaneous analysis of multiple instruments</li>
<li>Processing of full market depth data</li>
<li>Real-time analysis across multiple timeframes</li>
<li>Combined analysis of interrelated markets</li>
</ul>
</li>
<li>
<p><strong>Parallel Processing</strong>: FPGAs enable true parallel computation of multiple indicators and strategies without the context-switching overhead present in software:</p>
<ul>
<li>Independent calculation paths operate simultaneously</li>
<li>Scalable architecture for multiple instruments</li>
<li>Efficient implementation of multi-factor strategies</li>
<li>Overlapped computation and communication</li>
</ul>
</li>
<li>
<p><strong>Power Efficiency</strong>: Hardware acceleration typically provides better performance-per-watt compared to general-purpose processors:</p>
<ul>
<li>Reduced energy costs for high-frequency systems</li>
<li>Lower thermal management requirements</li>
<li>More efficient co-location in data centers</li>
<li>Smaller physical footprint for equivalent processing</li>
</ul>
</li>
<li>
<p><strong>Dedicated Resources</strong>: Unlike software running on shared systems, FPGA implementations provide dedicated resources with no contention:</p>
<ul>
<li>Elimination of operating system jitter</li>
<li>No resource competition with other applications</li>
<li>Consistent performance under varying market conditions</li>
<li>Immunity to system-level interruptions</li>
</ul>
</li>
<li>
<p><strong>Security Advantages</strong>: Hardware implementations offer inherent security benefits:</p>
<ul>
<li>Proprietary strategies can be more effectively protected</li>
<li>Reduced attack surface compared to software systems</li>
<li>Physical isolation from general-purpose processing</li>
<li>Proprietary algorithm encapsulation</li>
</ul>
</li>
</ol>
<p>These advantages make hardware acceleration particularly valuable in competitive trading environments where speed, determinism, and efficiency provide strategic advantages.</p>
<h3 id="target-applications">Target Applications</h3>
<p>This FPGA-based technical analysis system is designed for several specific application domains where the combination of performance, determinism, and flexibility provides significant advantages:</p>
<ol>
<li>
<p><strong>High-Frequency Trading (HFT)</strong>:</p>
<ul>
<li>Sub-microsecond reaction to market events</li>
<li>Implementation of statistical arbitrage strategies</li>
<li>Market making with minimal spread exposure</li>
<li>Execution of large orders with minimal market impact</li>
<li>Co-location optimization with exchange matching engines</li>
</ul>
</li>
<li>
<p><strong>Low-Latency Trading Systems</strong>:</p>
<ul>
<li>Trend identification and momentum strategies</li>
<li>Technical breakout detection and position entry</li>
<li>News-based algorithmic trading</li>
<li>Cross-market arbitrage opportunities</li>
<li>Implementation of proprietary timing algorithms</li>
</ul>
</li>
<li>
<p><strong>Multi-Instrument Trading Platforms</strong>:</p>
<ul>
<li>Simultaneous analysis of correlated instruments</li>
<li>Portfolio-level risk management</li>
<li>Basket trading and index arbitrage</li>
<li>Sector rotation strategies</li>
<li>Multi-asset class trading systems</li>
</ul>
</li>
<li>
<p><strong>Market Data Processing Systems</strong>:</p>
<ul>
<li>Real-time filtering and normalization</li>
<li>Feed handling and protocol conversion</li>
<li>Time-series construction and management</li>
<li>Multi-feed synchronization</li>
<li>Custom aggregate level creation</li>
</ul>
</li>
<li>
<p><strong>Backtesting and Simulation Environments</strong>:</p>
<ul>
<li>Accelerated historical data analysis</li>
<li>High-speed strategy optimization</li>
<li>Parameter sensitivity testing</li>
<li>Monte Carlo simulation</li>
<li>Walk-forward analysis</li>
</ul>
</li>
<li>
<p><strong>Risk Management Systems</strong>:</p>
<ul>
<li>Real-time position monitoring</li>
<li>Pre-trade risk checks</li>
<li>Limit management</li>
<li>Exposure calculation</li>
<li>Portfolio stress testing</li>
</ul>
</li>
<li>
<p><strong>Research and Development Platforms</strong>:</p>
<ul>
<li>Algorithm prototyping and validation</li>
<li>Comparative indicator analysis</li>
<li>Strategy refinement and optimization</li>
<li>Novel indicator development</li>
<li>Market microstructure research</li>
</ul>
</li>
</ol>
<p>The modular design approach enables adaptation to these diverse application areas through parameter configuration, module selection, and integration with other system components, all while maintaining the core benefits of hardware acceleration.</p>
<h3 id="fpga-implementation-advantages">FPGA Implementation Advantages</h3>
<p>Field-Programmable Gate Arrays (FPGAs) offer unique advantages as an implementation platform for technical analysis and trading systems, combining hardware performance with software-like flexibility:</p>
<ol>
<li>
<p><strong>Reconfigurability</strong>:</p>
<ul>
<li>Adaptation to changing market conditions and strategies</li>
<li>Field updates without hardware replacement</li>
<li>Iterative optimization and refinement</li>
<li>Platform for A/B testing different implementations</li>
<li>Support for evolving financial protocols and standards</li>
</ul>
</li>
<li>
<p><strong>Customized Datapaths</strong>:</p>
<ul>
<li>Tailored processing pipelines for specific indicators</li>
<li>Optimized arithmetic units for financial calculations</li>
<li>Specialized memory architectures for time-series data</li>
<li>Custom interfaces to market data sources</li>
<li>Precise control over processing granularity</li>
</ul>
</li>
<li>
<p><strong>Massively Parallel Architecture</strong>:</p>
<ul>
<li>Simultaneous computation of multiple indicators</li>
<li>Parallel processing of different instruments</li>
<li>Concurrent timeframe analysis</li>
<li>Pipeline parallelism for high throughput</li>
<li>Scalable design with resource proportionality</li>
</ul>
</li>
<li>
<p><strong>Deterministic Timing Control</strong>:</p>
<ul>
<li>Precise clock domain management</li>
<li>Predictable processing latency</li>
<li>Controlled pipeline stages</li>
<li>Exact synchronization with market events</li>
<li>Deterministic resource allocation</li>
</ul>
</li>
<li>
<p><strong>Hardware-Software Co-Design</strong>:</p>
<ul>
<li>Partition functionality between FPGA and CPU</li>
<li>Offload computation-intensive tasks to hardware</li>
<li>Reserve complex decision logic for software</li>
<li>Balance flexibility and performance</li>
<li>Leverage appropriate technology for each function</li>
</ul>
</li>
<li>
<p><strong>Exchange Connectivity Optimization</strong>:</p>
<ul>
<li>Direct implementation of exchange protocols</li>
<li>Hardware-accelerated feed handlers</li>
<li>Optimized TCP/IP or UDP stacks</li>
<li>Custom physical layer interfaces</li>
<li>Low-latency order entry systems</li>
</ul>
</li>
<li>
<p><strong>Development Methodology</strong>:</p>
<ul>
<li>Hardware description languages for precise control</li>
<li>High-level synthesis for complex algorithms</li>
<li>Simulation-based verification</li>
<li>Hardware-in-the-loop testing</li>
<li>Incremental implementation and deployment</li>
</ul>
</li>
<li>
<p><strong>Deployment Flexibility</strong>:</p>
<ul>
<li>Co-location with exchange systems</li>
<li>Integration with existing trading infrastructure</li>
<li>Standalone appliance deployment</li>
<li>Network appliance implementation</li>
<li>Cloud FPGA (F1/Alveo) implementation options</li>
</ul>
</li>
</ol>
<p>These advantages position FPGAs as an ideal platform for implementing technical analysis systems that require both high performance and adaptability to changing market conditions and strategies.</p>
<h3 id="system-capabilities">System Capabilities</h3>
<p>The FPGA-based technical analysis trading system offers a comprehensive set of capabilities designed to support advanced algorithmic trading strategies with exceptional performance characteristics:</p>
<ol>
<li>
<p><strong>Technical Indicator Calculation</strong>:</p>
<ul>
<li>20-period Simple Moving Average (configurable window size)</li>
<li>14-period Relative Strength Index (configurable period)</li>
<li>Extensible framework for additional indicators</li>
<li>Parallel calculation of multiple indicators</li>
<li>Parameterized implementation for customization</li>
</ul>
</li>
<li>
<p><strong>Signal Generation</strong>:</p>
<ul>
<li>Configurable buy/sell threshold settings</li>
<li>Momentum-based mean reversion strategy</li>
<li>Combined indicator approach (price, MA, RSI)</li>
<li>Clean signal timing with minimal latency</li>
<li>Protection against signal oscillation</li>
</ul>
</li>
<li>
<p><strong>Data Management</strong>:</p>
<ul>
<li>Efficient circular buffer implementation</li>
<li>Configurable history depth for each indicator</li>
<li>Sliding window optimization for O(1) calculations</li>
<li>Overflow and underflow protection</li>
<li>Synchronized data access between modules</li>
</ul>
</li>
<li>
<p><strong>Performance Characteristics</strong>:</p>
<ul>
<li>Single-cycle response to new price data</li>
<li>2-4 cycle latency for indicator calculation</li>
<li>Support for 100+ MHz clock frequencies</li>
<li>Throughput of millions of updates per second</li>
<li>Deterministic timing regardless of market conditions</li>
</ul>
</li>
<li>
<p><strong>Resource Efficiency</strong>:</p>
<ul>
<li>Optimized register usage for precision requirements</li>
<li>Minimal memory footprint for price history</li>
<li>Efficient arithmetic implementation</li>
<li>Scalable design for different FPGA sizes</li>
<li>Balance between performance and resource utilization</li>
</ul>
</li>
<li>
<p><strong>Operational Flexibility</strong>:</p>
<ul>
<li>Asynchronous reset for system initialization</li>
<li>Clear completion signaling for downstream processing</li>
<li>Status flags for system monitoring</li>
<li>Configurable parameters for different markets</li>
<li>Support for integration with larger systems</li>
</ul>
</li>
<li>
<p><strong>Verification Framework</strong>:</p>
<ul>
<li>Comprehensive testbenches for all components</li>
<li>Reference data for validation</li>
<li>Result checking mechanisms</li>
<li>Waveform generation for analysis</li>
<li>Documentation of testing methodology</li>
</ul>
</li>
</ol>
<p>These capabilities provide a solid foundation for implementing sophisticated trading strategies with the performance characteristics required for competitive market environments.</p>
<h2 id="2-repository-structure">2. Repository Structure</h2>
<h3 id="directory-organization">Directory Organization</h3>
<p>The repository is organized into a hierarchical structure that separates different aspects of the technical analysis system, enabling focused development and testing of individual components while maintaining a clear path to system integration:</p>
<pre class="hljs"><code><div>Implementation_of_Technical_analysis_on_FPGA/

 Combined_analysis/         # Integrated trading system implementation
    implementation.md      # Detailed implementation documentation
    moving_average_fsm.v   # Moving average FSM implementation
    price_memory.v         # Price memory (FIFO) implementation
    readme.md              # System documentation
    rsi_inc.v              # RSI implementation
    tb_trading_system_singlemem.v  # Testbench for trading system
    trading_decision.v     # Trading decision logic
    trading_system_singlemem.v     # Top-level system integration

 Moving_average/            # Moving average specific implementation
    Implementation Analysis.md      # In-depth analysis
    implementation_Summary.md       # Summary of implementation
    memory.v                        # Memory module for MA
    moving_average_fsm.v            # MA state machine
    readme.md                       # Documentation
    trading_system_tb.v             # MA system testbench

 rsi_verilog_project/                # RSI specific implementation
    implementation_summary.md       # RSI implementation summary
    price_fifo.v                    # Price FIFO for RSI
    readme.md                       # RSI documentation
    rsi_fsm.v                       # RSI state machine
    rsi_testbench.v                 # RSI testbench

 LICENSE                    # MIT License
 README.md                  # Repository overview
</div></code></pre>
<p>This organization follows a modular development approach where:</p>
<ol>
<li>Each technical indicator has its own directory for focused development</li>
<li>The combined analysis directory integrates all components into a complete system</li>
<li>Documentation is distributed alongside the corresponding implementation files</li>
<li>Testbenches are provided for both individual components and integrated systems</li>
<li>License and high-level documentation are maintained at the repository root</li>
</ol>
<p>This structure supports both top-down and bottom-up development approaches, allowing developers to:</p>
<ul>
<li>Focus on individual components in isolation</li>
<li>Understand the complete system through integrated documentation</li>
<li>Follow clear paths for both implementation and testing</li>
<li>Identify dependencies between components</li>
<li>Trace requirements from system specification to implementation</li>
</ul>
<p>The separation of concerns between different directories also enables parallel development by different team members with minimal conflict risk.</p>
<h3 id="combined-analysis-components">Combined Analysis Components</h3>
<p>The <code>Combined_analysis/</code> directory contains the integrated trading system implementation, bringing together all components into a cohesive whole. This directory represents the culmination of the development process, where individual technical indicators and supporting modules are combined into a functional trading system.</p>
<p>Key components in this directory include:</p>
<ol>
<li>
<p><strong>implementation.md</strong>:</p>
<ul>
<li>Comprehensive documentation of the integrated system</li>
<li>Detailed explanation of system architecture</li>
<li>Component interaction specifications</li>
<li>Implementation optimizations</li>
<li>Performance considerations</li>
<li>Usage guidance</li>
</ul>
</li>
<li>
<p><strong>price_memory.v</strong>:</p>
<ul>
<li>Circular FIFO buffer implementation for price history</li>
<li>Configurable depth and width parameters</li>
<li>Full/empty status signaling</li>
<li>Pointer management for efficient memory utilization</li>
<li>Integration with both MA and RSI calculations</li>
</ul>
</li>
<li>
<p><strong>moving_average_fsm.v</strong>:</p>
<ul>
<li>Finite State Machine for moving average calculation</li>
<li>Sliding window algorithm implementation</li>
<li>Extended precision to prevent overflow</li>
<li>Synchronization with price memory</li>
<li>Completion signaling</li>
</ul>
</li>
<li>
<p><strong>rsi_inc.v</strong>:</p>
<ul>
<li>Incremental RSI calculation implementation</li>
<li>Gain/loss tracking and accumulation</li>
<li>RSI formula calculation with protection against division by zero</li>
<li>State management for sequential processing</li>
<li>Integration with price memory</li>
</ul>
</li>
<li>
<p><strong>trading_decision.v</strong>:</p>
<ul>
<li>Trading strategy implementation</li>
<li>Configurable threshold parameters</li>
<li>Signal generation based on indicator conditions</li>
<li>Synchronized output signaling</li>
<li>Clean reset behavior</li>
</ul>
</li>
<li>
<p><strong>trading_system_singlemem.v</strong>:</p>
<ul>
<li>Top-level integration module</li>
<li>Component instantiation and connection</li>
<li>Signal routing between modules</li>
<li>System-level control logic</li>
<li>Interface definition for external systems</li>
</ul>
</li>
<li>
<p><strong>tb_trading_system_singlemem.v</strong>:</p>
<ul>
<li>Comprehensive system testbench</li>
<li>Test vector generation</li>
<li>Result validation</li>
<li>Signal monitoring and reporting</li>
<li>End-to-end functionality verification</li>
</ul>
</li>
</ol>
<p>This directory provides a complete implementation that can be directly synthesized for FPGA deployment, with thorough documentation to support understanding, modification, and integration into larger trading platforms.</p>
<h3 id="moving-average-specific-components">Moving Average Specific Components</h3>
<p>The <code>Moving_average/</code> directory contains a focused implementation of the Simple Moving Average (SMA) indicator, including both the core calculation module and supporting components for testing and documentation:</p>
<ol>
<li>
<p><strong>Implementation Analysis.md</strong>:</p>
<ul>
<li>In-depth technical analysis of the moving average implementation</li>
<li>Detailed explanation of design decisions</li>
<li>Algorithmic complexity analysis</li>
<li>Performance characteristics</li>
<li>Resource utilization evaluation</li>
<li>Optimization techniques</li>
<li>Implementation challenges and solutions</li>
</ul>
</li>
<li>
<p><strong>implementation_Summary.md</strong>:</p>
<ul>
<li>Concise overview of the moving average system</li>
<li>Key features and capabilities</li>
<li>Design approach summary</li>
<li>Interface specifications</li>
<li>Usage guidelines</li>
<li>Performance metrics</li>
</ul>
</li>
<li>
<p><strong>memory.v</strong>:</p>
<ul>
<li>Price history storage implementation for moving average calculation</li>
<li>FIFO buffer design for sequential price access</li>
<li>Management of read/write operations</li>
<li>Status signaling (full, empty, count)</li>
<li>Efficient memory utilization</li>
</ul>
</li>
<li>
<p><strong>moving_average_fsm.v</strong>:</p>
<ul>
<li>Finite State Machine for controlling the calculation process</li>
<li>Sliding window algorithm implementation</li>
<li>Sum maintenance and average calculation</li>
<li>Synchronization with memory module</li>
<li>Completion signaling</li>
</ul>
</li>
<li>
<p><strong>readme.md</strong>:</p>
<ul>
<li>User-oriented documentation</li>
<li>Implementation overview</li>
<li>Usage instructions</li>
<li>Parameter configuration guide</li>
<li>Integration guidance</li>
<li>Performance expectations</li>
</ul>
</li>
<li>
<p><strong>trading_system_tb.v</strong>:</p>
<ul>
<li>Testbench for validating the moving average implementation</li>
<li>Test vector generation</li>
<li>Clock and reset generation</li>
<li>Result verification</li>
<li>Performance measurement</li>
<li>Waveform generation for analysis</li>
</ul>
</li>
</ol>
<p>This directory provides a self-contained implementation of the moving average calculation that can be used independently or integrated into the combined system. The separation allows for focused development and testing of the moving average functionality, with comprehensive documentation to support understanding and modification.</p>
<p>The implementation in this directory may have slight variations from the version in the combined analysis directory, representing either alternative approaches or refinements that were later incorporated into the integrated system.</p>
<h3 id="rsi-specific-components">RSI Specific Components</h3>
<p>The <code>rsi_verilog_project/</code> directory contains a dedicated implementation of the Relative Strength Index (RSI) indicator, with all necessary components for independent development, testing, and documentation:</p>
<ol>
<li>
<p><strong>implementation_summary.md</strong>:</p>
<ul>
<li>Comprehensive explanation of the RSI implementation</li>
<li>Theoretical foundation of RSI calculation</li>
<li>Design architecture overview</li>
<li>State machine explanation</li>
<li>Algorithm details</li>
<li>Performance characteristics</li>
<li>Usage guidance</li>
</ul>
</li>
<li>
<p><strong>price_fifo.v</strong>:</p>
<ul>
<li>Specialized FIFO implementation for RSI price history</li>
<li>Parameterized depth and width configuration</li>
<li>Read/write pointer management</li>
<li>Status flag generation</li>
<li>Efficient memory utilization</li>
<li>Reset behavior specification</li>
</ul>
</li>
<li>
<p><strong>readme.md</strong>:</p>
<ul>
<li>User-focused documentation</li>
<li>RSI theory and application</li>
<li>Implementation overview</li>
<li>Configuration options</li>
<li>Integration guidelines</li>
<li>Performance expectations</li>
<li>Testing approach</li>
</ul>
</li>
<li>
<p><strong>rsi_fsm.v</strong>:</p>
<ul>
<li>Finite State Machine implementation for RSI calculation</li>
<li>State definitions and transitions</li>
<li>Gain/loss accumulation logic</li>
<li>FIFO integration and control</li>
<li>Final RSI calculation</li>
<li>Edge case handling</li>
<li>Completion signaling</li>
</ul>
</li>
<li>
<p><strong>rsi_testbench.v</strong>:</p>
<ul>
<li>Comprehensive verification environment</li>
<li>Test pattern generation</li>
<li>Clock and reset management</li>
<li>Result validation</li>
<li>State transition verification</li>
<li>Performance measurement</li>
<li>Output reporting</li>
</ul>
</li>
</ol>
<p>The RSI implementation follows a more complex state machine approach compared to the moving average, reflecting the additional steps required for RSI calculation:</p>
<ul>
<li>FIFO filling</li>
<li>Initial price capture</li>
<li>Price comparison for gain/loss determination</li>
<li>Accumulation of gains and losses</li>
<li>Final RSI formula calculation</li>
</ul>
<p>This directory provides a standalone RSI implementation that can be used independently or integrated into the combined trading system, with thorough documentation and verification to ensure correctness and performance.</p>
<h3 id="file-naming-conventions">File Naming Conventions</h3>
<p>The repository follows consistent file naming conventions to aid navigation and understanding:</p>
<ol>
<li>
<p><strong>Verilog Implementation Files</strong>:</p>
<ul>
<li>Named according to the module they implement</li>
<li>Use lowercase with underscores to separate words</li>
<li>End with the <code>.v</code> extension</li>
<li>Examples: <code>price_memory.v</code>, <code>moving_average_fsm.v</code>, <code>rsi_inc.v</code></li>
</ul>
</li>
<li>
<p><strong>Testbench Files</strong>:</p>
<ul>
<li>Prefixed with <code>tb_</code> or include <code>testbench</code> in the name</li>
<li>Describe the component being tested</li>
<li>End with the <code>.v</code> extension</li>
<li>Examples: <code>tb_trading_system_singlemem.v</code>, <code>rsi_testbench.v</code></li>
</ul>
</li>
<li>
<p><strong>Documentation Files</strong>:</p>
<ul>
<li>Use descriptive names indicating content type</li>
<li>Written in Markdown format with the <code>.md</code> extension</li>
<li>Include terms like <code>implementation</code>, <code>analysis</code>, or <code>summary</code> to indicate purpose</li>
<li>Examples: <code>implementation.md</code>, <code>Implementation Analysis.md</code>, <code>readme.md</code></li>
</ul>
</li>
<li>
<p><strong>Top-level Integration Files</strong>:</p>
<ul>
<li>Include <code>system</code> in the name to indicate integration role</li>
<li>May include qualifiers like <code>singlemem</code> to indicate implementation approach</li>
<li>Follow standard Verilog naming conventions</li>
<li>Example: <code>trading_system_singlemem.v</code></li>
</ul>
</li>
<li>
<p><strong>Component-Specific Files</strong>:</p>
<ul>
<li>Named to indicate the technical indicator they implement</li>
<li>Include functional qualifiers like <code>fsm</code> or <code>fifo</code></li>
<li>Follow standard Verilog naming conventions</li>
<li>Examples: <code>moving_average_fsm.v</code>, <code>price_fifo.v</code></li>
</ul>
</li>
</ol>
<p>These naming conventions support:</p>
<ul>
<li>Quick identification of file purpose</li>
<li>Clear indication of module functionality</li>
<li>Distinction between implementation and test files</li>
<li>Consistent structure across directories</li>
<li>Easy location of documentation</li>
<li>Transparent identification of dependencies</li>
</ul>
<p>Maintaining these conventions simplifies repository navigation, code review, and integration activities, while reducing the learning curve for new contributors.</p>
<h3 id="documentation-approach">Documentation Approach</h3>
<p>The repository employs a comprehensive documentation approach that distributes information across multiple levels of detail and focus, ensuring that both high-level understanding and implementation details are adequately captured:</p>
<ol>
<li>
<p><strong>Repository-Level Documentation</strong>:</p>
<ul>
<li><code>README.md</code>: High-level overview of the entire project, explaining purpose, structure, and usage</li>
<li><code>LICENSE</code>: Legal terms governing the use, modification, and distribution of the code</li>
</ul>
</li>
<li>
<p><strong>Directory-Level Documentation</strong>:</p>
<ul>
<li><code>readme.md</code> files in each directory providing context for the contained components</li>
<li>Implementation summaries that explain the approach taken for each major component</li>
<li>Analysis documents that delve into design decisions, optimizations, and tradeoffs</li>
</ul>
</li>
<li>
<p><strong>Implementation Documentation</strong>:</p>
<ul>
<li>Detailed comments within Verilog files explaining functionality</li>
<li>Module-level headers describing purpose, parameters, ports, and behavior</li>
<li>Signal naming that reflects functionality</li>
<li>State definitions with explanatory comments</li>
<li>Algorithm explanations for complex calculations</li>
</ul>
</li>
<li>
<p><strong>Interface Documentation</strong>:</p>
<ul>
<li>Port descriptions including direction, width, and purpose</li>
<li>Timing relationships between signals</li>
<li>Protocol specifications for module interaction</li>
<li>Parameter explanations and configuration guidance</li>
<li>Reset behavior and initialization requirements</li>
</ul>
</li>
<li>
<p><strong>Verification Documentation</strong>:</p>
<ul>
<li>Testbench descriptions explaining verification approach</li>
<li>Test vector generation methodology</li>
<li>Expected results and validation criteria</li>
<li>Coverage analysis (where applicable)</li>
<li>Corner case identification and testing</li>
</ul>
</li>
<li>
<p><strong>Performance Documentation</strong>:</p>
<ul>
<li>Latency and throughput characteristics</li>
<li>Resource utilization measurements</li>
<li>Timing constraint information</li>
<li>Scalability analysis</li>
<li>Optimization guidance</li>
</ul>
</li>
</ol>
<p>The documentation is written to serve multiple audiences:</p>
<ul>
<li>New users seeking to understand the system's capabilities</li>
<li>Developers looking to modify or extend functionality</li>
<li>Integrators needing to incorporate the system into larger designs</li>
<li>Reviewers evaluating implementation quality and correctness</li>
<li>Researchers interested in the algorithmic approaches</li>
</ul>
<p>This multi-layered approach ensures that information is available at the appropriate level of detail for different purposes, from high-level overview to detailed implementation specifics, supporting both understanding and practical application of the technical analysis system.</p>
<h2 id="3-system-architecture">3. System Architecture</h2>
<h3 id="high-level-design">High-Level Design</h3>
<p>The technical analysis trading system follows a structured, modular architecture designed to efficiently process market data and generate trading signals. The high-level design emphasizes clear separation of concerns, deterministic data flow, and efficient resource utilization.</p>
<p>At the core of the architecture are three primary functional blocks:</p>
<ol>
<li>
<p><strong>Data Management (Price Memory)</strong>:</p>
<ul>
<li>Maintains history of price data in a circular buffer</li>
<li>Provides both newest and oldest prices for calculation</li>
<li>Tracks buffer fill level and signals when full</li>
<li>Manages efficient memory utilization through pointer manipulation</li>
<li>Serves as the central data repository for all indicator calculations</li>
</ul>
</li>
<li>
<p><strong>Technical Indicator Calculation</strong>:</p>
<ul>
<li>Moving Average Module: Calculates the simple moving average over a configurable window</li>
<li>RSI Module: Calculates the relative strength index using accumulated gains and losses</li>
<li>Each indicator operates independently on the shared price data</li>
<li>Calculation modules signal completion to synchronize downstream processing</li>
</ul>
</li>
<li>
<p><strong>Trading Decision Logic</strong>:</p>
<ul>
<li>Evaluates indicator values against predefined criteria</li>
<li>Implements configurable trading strategy</li>
<li>Generates clean buy/sell signals based on conditions</li>
<li>Synchronizes with indicator calculation timing</li>
<li>Provides the primary output interface to external systems</li>
</ul>
</li>
</ol>
<p>These components are arranged in a pipeline architecture where:</p>
<ol>
<li>New price data enters the system</li>
<li>Prices are stored in the circular buffer</li>
<li>Technical indicators are calculated when sufficient data is available</li>
<li>Trading decisions are made based on the calculated indicators</li>
<li>Buy/sell signals are generated as system outputs</li>
</ol>
<p>The design prioritizes:</p>
<ul>
<li><strong>Modularity</strong>: Each component has a well-defined responsibility and interface</li>
<li><strong>Configurability</strong>: Parameters allow customization without code changes</li>
<li><strong>Efficiency</strong>: Algorithms minimize computational complexity</li>
<li><strong>Determinism</strong>: Processing follows predictable timing patterns</li>
<li><strong>Scalability</strong>: The architecture can be extended with additional indicators</li>
<li><strong>Maintainability</strong>: Clear separation of concerns simplifies modifications</li>
</ul>
<p>This high-level architecture provides the foundation for detailed implementation, with each component refined to meet specific performance and resource utilization goals.</p>
<h3 id="module-interactions">Module Interactions</h3>
<p>The technical analysis system's components interact through a well-defined set of interfaces and data flows, creating a cohesive system while maintaining separation of concerns. These interactions are carefully designed to ensure proper synchronization, data integrity, and efficient processing.</p>
<p>The primary module interactions include:</p>
<ol>
<li>
<p><strong>Price Input to Price Memory</strong>:</p>
<ul>
<li>New price data (<code>price_in</code>) is provided to the system along with a strobe signal (<code>new_price</code>)</li>
<li>The Price Memory module captures this data when <code>write_enable</code> is asserted</li>
<li>The memory updates its internal state, including pointers and counters</li>
<li>The <code>mem_full</code> signal is generated when sufficient prices are collected</li>
</ul>
</li>
<li>
<p><strong>Price Memory to Moving Average FSM</strong>:</p>
<ul>
<li>The <code>oldest_price</code> output from Price Memory is connected to the MA FSM</li>
<li>The newest price (<code>price_in</code>) is directly provided to the MA FSM</li>
<li>When memory is full (<code>mem_full</code>), the MA calculation is triggered through the <code>start</code> signal</li>
<li>The MA FSM processes these prices to calculate the moving average</li>
<li>Upon completion, the <code>done</code> signal is asserted to indicate valid output</li>
</ul>
</li>
<li>
<p><strong>Price Memory to RSI Calculator</strong>:</p>
<ul>
<li>Similarly, the RSI module receives price data from the Price Memory</li>
<li>The <code>new_price_strobe</code> signal synchronizes data acquisition</li>
<li>The <code>mem_count</code> signal indicates available data depth</li>
<li>The RSI module processes prices to calculate gain/loss and final RSI</li>
<li>The RSI <code>done</code> signal indicates calculation completion</li>
</ul>
</li>
<li>
<p><strong>Indicator Modules to Trading Decision</strong>:</p>
<ul>
<li>The Moving Average output (<code>moving_avg</code>) is provided to the Trading Decision module</li>
<li>The RSI output (<code>rsi</code>) is connected to the Trading Decision logic</li>
<li>The current price (<code>price_now</code>) is also provided for comparison</li>
<li>The Trading Decision module evaluates these inputs against thresholds</li>
<li>Buy/sell signals are generated based on the combined conditions</li>
</ul>
</li>
<li>
<p><strong>System-Level Synchronization</strong>:</p>
<ul>
<li>The <code>mem_full</code> signal serves as the primary trigger for calculations</li>
<li>The <code>compute_enable</code> signal (derived from <code>mem_count</code>) ensures sufficient data</li>
<li>Indicator <code>done</code> signals provide synchronization points</li>
<li>All modules share common clock and reset signals</li>
<li>The clock domain is unified for deterministic timing</li>
</ul>
</li>
</ol>
<p>These interactions are implemented through direct port connections in the top-level module:</p>
<pre class="hljs"><code><div>price_memory mem14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.wr_en</span>(new_price),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.full</span>(mem_full),
    <span class="hljs-variable">.count</span>(count)
);

moving_average_fsm ma14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),
    <span class="hljs-variable">.done</span>(ma_done)
);

rsi_inc rsi14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.mem_full</span>(mem_full),
    <span class="hljs-variable">.mem_count</span>(mem_cnt),
    <span class="hljs-variable">.rsi</span>(rsi),
    <span class="hljs-variable">.done</span>(rsi_done)
);

trading_decision dec (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.price_now</span>(price_in),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),
    <span class="hljs-variable">.rsi</span>(rsi),
    <span class="hljs-variable">.buy</span>(buy),
    <span class="hljs-variable">.sell</span>(sell)
);
</div></code></pre>
<p>The careful design of these interactions ensures that:</p>
<ul>
<li>Data flows predictably through the system</li>
<li>Calculations are triggered at appropriate times</li>
<li>Outputs are only used when valid</li>
<li>Synchronization is maintained without complex handshaking</li>
<li>Resource sharing is optimized where appropriate</li>
<li>System behavior is deterministic and verifiable</li>
</ul>
<p>These well-defined interactions simplify system integration, verification, and future extension with additional components.</p>
<h3 id="data-flow-architecture">Data Flow Architecture</h3>
<p>The technical analysis system implements a streamlined data flow architecture optimized for sequential processing of financial time series data. This architecture ensures efficient data movement, minimizes redundant storage, and supports parallel indicator calculation while maintaining data consistency.</p>
<p>The data flow follows a structured path through the system:</p>
<ol>
<li>
<p><strong>Data Ingestion</strong>:</p>
<ul>
<li>New price data enters through the <code>price_in</code> port</li>
<li>The <code>new_price</code> signal indicates valid data</li>
<li>Prices are accepted at the system clock rate when enabled</li>
<li>No preprocessing or normalization is performed</li>
</ul>
</li>
<li>
<p><strong>Price History Management</strong>:</p>
<ul>
<li>The Price Memory module stores incoming prices</li>
<li>A circular buffer maintains the most recent N prices</li>
<li>Write operations add new prices at the current write pointer</li>
<li>Read operations provide the oldest price from the read pointer</li>
<li>Pointers wrap around to implement circular behavior</li>
<li>Counter tracks the number of valid prices in the buffer</li>
</ul>
</li>
<li>
<p><strong>Data Distribution</strong>:</p>
<ul>
<li>Once sufficient prices are collected, data is distributed to indicator modules</li>
<li>The current price (<code>price_in</code>) is provided directly to calculation modules</li>
<li>The oldest price (<code>oldest_price</code>) is provided from memory</li>
<li>All prices between newest and oldest remain in the circular buffer</li>
<li>This approach minimizes data duplication while maintaining access</li>
</ul>
</li>
<li>
<p><strong>Indicator Calculation</strong>:</p>
<ul>
<li>Moving Average and RSI modules process the distributed data</li>
<li>Each module maintains internal state for calculation continuity</li>
<li>MA maintains a running sum for the sliding window</li>
<li>RSI tracks gain/loss accumulators for momentum calculation</li>
<li>Calculations proceed independently but are triggered synchronously</li>
</ul>
</li>
<li>
<p><strong>Decision Processing</strong>:</p>
<ul>
<li>Indicator outputs flow to the Trading Decision module</li>
<li>Current price is compared with Moving Average</li>
<li>RSI value is evaluated against thresholds</li>
<li>Combined conditions generate trading signals</li>
<li>Signal outputs represent the final data flow products</li>
</ul>
</li>
<li>
<p><strong>Output Generation</strong>:</p>
<ul>
<li>Buy/sell signals are generated as primary outputs</li>
<li>Indicator values are also provided as outputs</li>
<li>Status signals indicate system state</li>
<li>Debug outputs provide visibility into internal operation</li>
</ul>
</li>
</ol>
<p>This data flow is characterized by several key design principles:</p>
<ul>
<li><strong>Single Data Path</strong>: Price data follows a single path through the system</li>
<li><strong>Minimal Data Duplication</strong>: Prices are stored only once in the central buffer</li>
<li><strong>Efficient Access Patterns</strong>: Sliding window approach minimizes memory operations</li>
<li><strong>Parallel Processing</strong>: Indicators calculate simultaneously with shared data</li>
<li><strong>Temporal Consistency</strong>: All calculations use the same time window of prices</li>
<li><strong>Streamlined Movement</strong>: Data flows without unnecessary buffering or staging</li>
</ul>
<p>The data flow architecture is visualized in the following diagram:</p>
<pre class="hljs"><code><div>                  Price Input
                      
                      
                 
                  Price   
                  Memory  
                 
                      
         
                                 
                                 
               
    Moving                   RSI     
    Average                Calculator
               
                                 
                                 
         
                      
                      
               
                  Trading   
                 Decision   
               
                      
                      
              Trading Signals
</div></code></pre>
<p>This architecture achieves an optimal balance between performance and resource utilization, enabling efficient calculation of technical indicators with minimal latency and consistent timing characteristics.</p>
<h3 id="clock-domain-strategy">Clock Domain Strategy</h3>
<p>The technical analysis system implements a single clock domain strategy to simplify timing analysis, minimize synchronization issues, and ensure deterministic behavior. This approach leverages the relatively modest clock frequency requirements of financial data processing while eliminating the complexity and potential metastability issues associated with clock domain crossing.</p>
<p>Key aspects of the clock domain strategy include:</p>
<ol>
<li>
<p><strong>Unified Clock Signal</strong>:</p>
<ul>
<li>All modules operate from a single system clock</li>
<li>The clock is distributed with minimal skew</li>
<li>Typical operating frequencies range from 50-200 MHz</li>
<li>All sequential elements are synchronized to this clock</li>
<li>No clock division or multiplication is implemented</li>
</ul>
</li>
<li>
<p><strong>Synchronous Design Principles</strong>:</p>
<ul>
<li>All state transitions occur on the rising edge of the clock</li>
<li>Combinational logic paths are designed for single-cycle timing closure</li>
<li>Registered outputs ensure clean signal transitions</li>
<li>Input synchronization for external signals (when needed)</li>
<li>Avoidance of gated clocks for reliability</li>
</ul>
</li>
<li>
<p><strong>Reset Management</strong>:</p>
<ul>
<li>Asynchronous reset for system initialization</li>
<li>Reset signal is distributed to all modules</li>
<li>Synchronized de-assertion for stability</li>
<li>Defined reset state for all registers</li>
<li>Consistent reset polarity (active high)</li>
</ul>
</li>
<li>
<p><strong>Timing Closure Approach</strong>:</p>
<ul>
<li>Clear timing paths with minimal combinational depth</li>
<li>Pipelining of complex operations where necessary</li>
<li>Balanced logic distribution</li>
<li>Margin for implementation variations</li>
<li>Conservative setup/hold timing</li>
</ul>
</li>
<li>
<p><strong>Performance Considerations</strong>:</p>
<ul>
<li>Maximum clock frequency determined by critical path delay</li>
<li>Division operations often define the critical path</li>
<li>Target frequencies allow substantial margin</li>
<li>Performance scaling with clock frequency</li>
<li>Known latency in clock cycles regardless of frequency</li>
</ul>
</li>
</ol>
<p>The single clock domain approach offers several advantages for this application:</p>
<ul>
<li><strong>Simplified Design</strong>: No complex synchronization or handshaking required</li>
<li><strong>Deterministic Behavior</strong>: Consistent cycle counts for operations</li>
<li><strong>Reduced Complexity</strong>: Elimination of metastability concerns</li>
<li><strong>Improved Reliability</strong>: Fewer potential timing issues</li>
<li><strong>Easier Verification</strong>: Simpler timing analysis and testing</li>
<li><strong>Straightforward Debugging</strong>: Predictable signal relationships</li>
<li><strong>Enhanced Portability</strong>: Less dependency on specific FPGA clock resources</li>
</ul>
<p>For integration with external systems operating on different clock domains, standard synchronization techniques would be implemented at the system boundaries:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Example input synchronization (if needed)</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sync_price_valid;
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    sync_price_valid &lt;= {sync_price_valid[<span class="hljs-number">0</span>], ext_price_valid};
    <span class="hljs-keyword">if</span> (sync_price_valid == <span class="hljs-number">2&#x27;b01</span>) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Rising edge detected, process new price</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>The single clock domain strategy is appropriate for this application because:</p>
<ul>
<li>Financial data typically arrives at rates much lower than achievable clock frequencies</li>
<li>Processing requirements are well within the capabilities of modern FPGAs at moderate frequencies</li>
<li>System complexity does not justify the overhead of multiple clock domains</li>
<li>Deterministic behavior is prioritized over specialized performance optimization</li>
</ul>
<p>This approach creates a robust foundation for the trading system, ensuring reliable operation with predictable timing characteristics.</p>
<h3 id="control-flow-management">Control Flow Management</h3>
<p>The technical analysis system implements a sophisticated control flow strategy that orchestrates operation sequencing, ensures proper data handling, and maintains synchronization between components. This approach combines state machines, handshaking signals, and status flags to create a deterministic and well-coordinated system behavior.</p>
<p>Key elements of the control flow management include:</p>
<ol>
<li>
<p><strong>Finite State Machines (FSMs)</strong>:</p>
<ul>
<li>Each major calculation module implements an FSM to control its operation</li>
<li>FSMs provide clear operational phases with well-defined transitions</li>
<li>State encoding is optimized for clarity and efficient synthesis</li>
<li>Default state transitions protect against unexpected conditions</li>
<li>Reset logic ensures consistent initialization</li>
</ul>
</li>
<li>
<p><strong>Trigger Signals</strong>:</p>
<ul>
<li>The <code>new_price</code> signal initiates data storage operations</li>
<li>The <code>mem_full</code> flag triggers the start of calculations</li>
<li>The <code>compute_enable</code> signal (derived from <code>mem_cnt == 14</code>) initiates both MA and RSI calculations</li>
<li>Internal state transitions provide sequential triggering</li>
</ul>
</li>
<li>
<p><strong>Completion Signaling</strong>:</p>
<ul>
<li>Each calculation module generates a <code>done</code> signal</li>
<li>These signals pulse for one clock cycle to indicate completion</li>
<li>Downstream modules use these signals for synchronization</li>
<li>The combination of done signals can indicate system-wide completion</li>
<li>Done signals are registered to ensure clean transitions</li>
</ul>
</li>
<li>
<p><strong>Status Flags</strong>:</p>
<ul>
<li>The <code>mem_full</code> flag indicates sufficient data for calculation</li>
<li>The <code>mem_cnt</code> value tracks the current data depth</li>
<li>Individual module states provide status information</li>
<li>Error conditions (if implemented) are signaled through dedicated flags</li>
<li>These flags enable conditional operation based on system state</li>
</ul>
</li>
<li>
<p><strong>Flow Control Patterns</strong>:</p>
<ul>
<li><strong>Sequential Operation</strong>: Each module follows a defined sequence of steps</li>
<li><strong>Parallel Processing</strong>: Multiple indicators calculate simultaneously</li>
<li><strong>Conditional Execution</strong>: Operations proceed based on data availability</li>
<li><strong>Completion Acknowledgment</strong>: Done signals mark operation boundaries</li>
<li><strong>State-Based Gating</strong>: Actions are enabled only in appropriate states</li>
</ul>
</li>
</ol>
<p>The primary control flows in the system include:</p>
<ol>
<li>
<p><strong>Price Data Acquisition Flow</strong>:</p>
<pre class="hljs"><code><div>new_price  write_enable  memory update  memory_full flag  calculation trigger
</div></code></pre>
</li>
<li>
<p><strong>Moving Average Calculation Flow</strong>:</p>
<pre class="hljs"><code><div>start  state transition  sum update  division  done signaling  return to idle
</div></code></pre>
</li>
<li>
<p><strong>RSI Calculation Flow</strong>:</p>
<pre class="hljs"><code><div>new_price_strobe  FIFO fill  price comparison  gain/loss accumulation  RSI calculation  done signaling
</div></code></pre>
</li>
<li>
<p><strong>Trading Decision Flow</strong>:</p>
<pre class="hljs"><code><div>indicator updates  condition evaluation  signal generation
</div></code></pre>
</li>
</ol>
<p>These flows are coordinated through a combination of direct control signals and shared system state, ensuring that:</p>
<ul>
<li>Operations occur in the correct sequence</li>
<li>Data dependencies are respected</li>
<li>Calculations use valid input data</li>
<li>Outputs are only considered valid when explicitly indicated</li>
<li>The system maintains a predictable operational pattern</li>
</ul>
<p>The FSM-based approach provides several advantages:</p>
<ul>
<li>Clear operational phases with defined boundaries</li>
<li>Explicit control over transition conditions</li>
<li>Ability to insert wait states if needed</li>
<li>Easy extension with additional states</li>
<li>Straightforward debugging and verification</li>
</ul>
<p>This control flow management strategy creates a deterministic system behavior that can be readily verified and integrated into larger trading platforms, with predictable timing relationships and well-defined operational states.</p>
<h3 id="interface-specifications">Interface Specifications</h3>
<p>The technical analysis system implements clearly defined interfaces for each module, ensuring proper integration, standardized communication, and maintainable code. These interface specifications define the signals, timing relationships, and protocols for interaction between components and with external systems.</p>
<h4 id="1-top-level-system-interface">1. Top-Level System Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_system_singlemem (
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,            <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,            <span class="hljs-comment">// Asynchronous reset (active high)</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_in,       <span class="hljs-comment">// New price data input</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        new_price,      <span class="hljs-comment">// Signal indicating valid new price</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,     <span class="hljs-comment">// Calculated moving average</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,            <span class="hljs-comment">// Calculated RSI value</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        buy,            <span class="hljs-comment">// Buy signal output</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        sell,           <span class="hljs-comment">// Sell signal output</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        mem_full,       <span class="hljs-comment">// Memory full status flag</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]  mem_cnt,        <span class="hljs-comment">// Memory fill count</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] oldest_price,   <span class="hljs-comment">// Oldest price in memory</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        ma_done,        <span class="hljs-comment">// MA calculation complete</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        rsi_done        <span class="hljs-comment">// RSI calculation complete</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>clk</code>: All operations synchronize to the rising edge</li>
<li><code>rst</code>: Active high, asynchronous assertion, synchronous de-assertion</li>
<li><code>price_in</code>: Sampled when <code>new_price</code> is high</li>
<li><code>new_price</code>: Held high for one clock cycle per new price</li>
<li><code>buy</code>/<code>sell</code>: Mutually exclusive signals, registered outputs</li>
<li>Status signals (<code>mem_full</code>, <code>ma_done</code>, <code>rsi_done</code>): Indicate internal state</li>
</ul>
<h4 id="2-price-memory-interface">2. Price Memory Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,    <span class="hljs-comment">// Depth of the FIFO</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>        <span class="hljs-comment">// Data width</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,                <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,                <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> wr_en,              <span class="hljs-comment">// Write enable</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price, <span class="hljs-comment">// New price input</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Oldest price</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> full,              <span class="hljs-comment">// FIFO full flag</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count        <span class="hljs-comment">// FIFO count</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>wr_en</code>: Asserted for one clock cycle to write data</li>
<li><code>new_price</code>: Valid when <code>wr_en</code> is high</li>
<li><code>oldest_price</code>: Valid continuously once FIFO has data</li>
<li><code>full</code>: Asserted when count reaches DEPTH</li>
<li><code>count</code>: Indicates number of valid entries in FIFO</li>
</ul>
<h4 id="3-moving-average-fsm-interface">3. Moving Average FSM Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,                <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,                <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start,              <span class="hljs-comment">// Start calculation</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price, <span class="hljs-comment">// New price</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Oldest price</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,  <span class="hljs-comment">// Calculated moving average</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done                <span class="hljs-comment">// Calculation complete</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>start</code>: Triggers calculation when asserted for one cycle</li>
<li><code>new_price</code>/<code>oldest_price</code>: Must be valid when <code>start</code> is asserted</li>
<li><code>moving_avg</code>: Updated after calculation, valid when <code>done</code> is high</li>
<li><code>done</code>: Pulses high for one cycle when calculation completes</li>
</ul>
<h4 id="4-rsi-calculator-interface">4. RSI Calculator Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> rsi_inc #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,                 <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,                 <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_price_strobe,    <span class="hljs-comment">// New price available</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,  <span class="hljs-comment">// New price data</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Oldest price data</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> mem_full,            <span class="hljs-comment">// Memory full flag</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] mem_count,     <span class="hljs-comment">// Memory count</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,           <span class="hljs-comment">// RSI output (0-100)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done                 <span class="hljs-comment">// Calculation complete</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>new_price_strobe</code>: Signals new price availability</li>
<li><code>new_price</code>/<code>oldest_price</code>: Valid when <code>new_price_strobe</code> is high</li>
<li><code>mem_full</code>/<code>mem_count</code>: Indicate data availability status</li>
<li><code>rsi</code>: Valid when calculation completes, range 0-100</li>
<li><code>done</code>: Pulses high for one cycle when calculation completes</li>
</ul>
<h4 id="5-trading-decision-interface">5. Trading Decision Interface</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR = <span class="hljs-number">8&#x27;d30</span>,  <span class="hljs-comment">// RSI buy threshold</span>
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>  <span class="hljs-comment">// RSI sell threshold</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,                 <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,                 <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_now,    <span class="hljs-comment">// Current price</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,   <span class="hljs-comment">// Moving average value</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,           <span class="hljs-comment">// RSI value</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,                 <span class="hljs-comment">// Buy signal</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell                 <span class="hljs-comment">// Sell signal</span>
);
</div></code></pre>
<p><strong>Interface Protocol</strong>:</p>
<ul>
<li><code>price_now</code>: Current price value, updated continuously</li>
<li><code>moving_avg</code>/<code>rsi</code>: Indicator values, updated after calculations</li>
<li><code>buy</code>/<code>sell</code>: Registered outputs, mutually exclusive</li>
</ul>
<h4 id="common-interface-characteristics">Common Interface Characteristics</h4>
<p>All module interfaces share these common characteristics:</p>
<ul>
<li><strong>Clock and Reset</strong>: Every module includes clock and reset signals</li>
<li><strong>Parameterization</strong>: Key values are parameterized for flexibility</li>
<li><strong>Registered Outputs</strong>: All outputs are registered for clean timing</li>
<li><strong>Clear Direction</strong>: All signals have explicit direction (input/output)</li>
<li><strong>Width Specification</strong>: All multi-bit signals have explicit width</li>
<li><strong>Status Signals</strong>: Appropriate flags indicate internal state</li>
</ul>
<p>These interface specifications ensure:</p>
<ul>
<li>Clear boundaries between modules</li>
<li>Consistent signal naming and usage</li>
<li>Proper timing relationships</li>
<li>Flexible configuration through parameters</li>
<li>Straightforward integration into larger systems</li>
<li>Ease of verification and testing</li>
</ul>
<p>The standardized interface approach facilitates both independent module development and system integration, creating a robust foundation for the technical analysis system.</p>
<h3 id="system-integration-principles">System Integration Principles</h3>
<p>The technical analysis system implements a set of system integration principles that ensure coherent operation of all components, maintainable architecture, and extensibility for future enhancements. These principles guide the connection and interaction of modules to create a unified system with predictable behavior.</p>
<p>Key system integration principles include:</p>
<ol>
<li>
<p><strong>Hierarchical Integration Structure</strong>:</p>
<ul>
<li>The <code>trading_system_singlemem</code> module serves as the top-level integration point</li>
<li>Individual functional modules are instantiated within this top level</li>
<li>Signals are explicitly connected between modules</li>
<li>Parameters are propagated from top level to components</li>
<li>Interface consistency is maintained across levels</li>
</ul>
</li>
<li>
<p><strong>Signal Naming Conventions</strong>:</p>
<ul>
<li>Consistent naming across module boundaries</li>
<li>Signal names reflect functionality</li>
<li>Prefixes or suffixes indicate signal role</li>
<li>Width included in multi-bit signal names where appropriate</li>
<li>Clear distinction between control, data, and status signals</li>
</ul>
</li>
<li>
<p><strong>Parameter Propagation</strong>:</p>
<ul>
<li>System-level parameters are passed to individual modules</li>
<li>Default parameter values provide sensible behavior if not overridden</li>
<li>Parameter consistency is maintained across related modules</li>
<li>Documentation clarifies parameter relationships</li>
<li>Parameters control behavior without code changes</li>
</ul>
</li>
<li>
<p><strong>Clock and Reset Distribution</strong>:</p>
<ul>
<li>Single clock domain for all modules</li>
<li>Common reset signal with consistent polarity</li>
<li>Synchronous reset release for stability</li>
<li>Defined reset state for all registers</li>
<li>Clean reset paths for all modules</li>
</ul>
</li>
<li>
<p><strong>Control Signal Management</strong>:</p>
<ul>
<li>Clear trigger signals for operations</li>
<li>Explicit completion signaling</li>
<li>Status flags for system state monitoring</li>
<li>Avoidance of complex handshaking where possible</li>
<li>State-based control rather than complex sequencing</li>
</ul>
</li>
<li>
<p><strong>Resource Sharing Strategy</strong>:</p>
<ul>
<li>Common price memory for all indicator calculations</li>
<li>Direct fanout to multiple calculation modules</li>
<li>Independent calculation engines for parallel processing</li>
<li>Shared input and output paths</li>
<li>Minimization of redundant storage</li>
</ul>
</li>
<li>
<p><strong>Interface Consistency</strong>:</p>
<ul>
<li>Standardized port ordering (clock, reset, controls, data, status)</li>
<li>Consistent signal widths for common functions</li>
<li>Standard timing relationships (one-cycle pulses for triggers)</li>
<li>Common protocol for calculation initiation and completion</li>
<li>Clear distinction between inputs and outputs</li>
</ul>
</li>
<li>
<p><strong>Timing Relationship Management</strong>:</p>
<ul>
<li>Defined latency for all operations</li>
<li>Synchronization points at module boundaries</li>
<li>Avoidance of combinational loops</li>
<li>Registered outputs for clean timing</li>
<li>Predictable cycle counts for operations</li>
</ul>
</li>
<li>
<p><strong>Extensibility Approaches</strong>:</p>
<ul>
<li>Modular design for addition of new indicators</li>
<li>Parameterized components for configuration flexibility</li>
<li>Clear interface definitions for future integration</li>
<li>Consistent control structure for new modules</li>
<li>Documentation of integration points</li>
</ul>
</li>
</ol>
<p>The system integration is implemented in the top-level module:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_system_singlemem (
    <span class="hljs-comment">// Port list...</span>
);
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count;

    <span class="hljs-comment">// Price memory instance</span>
    price_memory mem14 (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.wr_en</span>(new_price),
        <span class="hljs-variable">.new_price</span>(price_in),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.full</span>(mem_full),
        <span class="hljs-variable">.count</span>(count)
    );

    <span class="hljs-keyword">assign</span> mem_cnt = count;

    <span class="hljs-comment">// Trigger MA and RSI only after memory is full</span>
    <span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

    <span class="hljs-comment">// Moving Average FSM</span>
    moving_average_fsm ma14 (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.start</span>(compute_enable),
        <span class="hljs-variable">.new_price</span>(price_in),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.moving_avg</span>(moving_avg),
        <span class="hljs-variable">.done</span>(ma_done)
    );

    <span class="hljs-comment">// RSI Incremental FSM</span>
    rsi_inc rsi14 (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
        <span class="hljs-variable">.new_price</span>(price_in),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.mem_full</span>(mem_full),
        <span class="hljs-variable">.mem_count</span>(mem_cnt),
        <span class="hljs-variable">.rsi</span>(rsi),
        <span class="hljs-variable">.done</span>(rsi_done)
    );

    <span class="hljs-comment">// Trading decision logic</span>
    trading_decision dec (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.price_now</span>(price_in),
        <span class="hljs-variable">.moving_avg</span>(moving_avg),
        <span class="hljs-variable">.rsi</span>(rsi),
        <span class="hljs-variable">.buy</span>(buy),
        <span class="hljs-variable">.sell</span>(sell)
    );
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>These integration principles enable:</p>
<ul>
<li>Coherent system behavior</li>
<li>Clear signal flow and control</li>
<li>Maintainable architecture</li>
<li>Testable implementation</li>
<li>Extensible design</li>
<li>Predictable timing</li>
<li>Efficient resource utilization</li>
</ul>
<p>By adhering to these principles, the technical analysis system achieves a robust integration that balances performance, clarity, and flexibility, creating a solid foundation for trading applications.</p>
<h2 id="4-technical-indicators-implementation">4. Technical Indicators Implementation</h2>
<h3 id="moving-average-implementation">Moving Average Implementation</h3>
<h4 id="principles-and-theory">Principles and Theory</h4>
<p>The Simple Moving Average (SMA) is one of the most fundamental and widely used technical indicators in financial analysis. It provides a smoothed price curve by calculating the arithmetic mean of prices over a specific number of periods, helping traders identify trends by filtering out short-term price fluctuations.</p>
<p>The mathematical definition of an n-period Simple Moving Average is:</p>
<p>$$ SMA(n) = \frac{P_1 + P_2 + ... + P_n}{n} $$</p>
<p>Where:</p>
<ul>
<li>$P_1, P_2, ..., P_n$ are the price values over n periods</li>
<li>$n$ is the number of periods (window size)</li>
</ul>
<p>The SMA has several important properties that influence its implementation:</p>
<ol>
<li>
<p><strong>Equal Weighting</strong>: All prices within the window receive equal weight in the calculation, unlike exponential or weighted moving averages that assign higher weights to more recent prices.</p>
</li>
<li>
<p><strong>Lag Characteristic</strong>: The SMA tends to lag behind price movements, with the lag increasing with the window size. This is because historical prices have the same influence as current prices in the calculation.</p>
</li>
<li>
<p><strong>Smoothing Effect</strong>: Larger window sizes produce smoother curves that filter out more short-term fluctuations but increase lag.</p>
</li>
<li>
<p><strong>Trend Indication</strong>: The slope of the SMA line indicates the direction of the trend:</p>
<ul>
<li>Rising SMA suggests an uptrend</li>
<li>Falling SMA suggests a downtrend</li>
<li>Flat SMA suggests a sideways market</li>
</ul>
</li>
<li>
<p><strong>Support/Resistance Function</strong>: SMA can act as dynamic support in uptrends or resistance in downtrends, with commonly used periods (like 20, 50, or 200) often serving as significant levels.</p>
</li>
</ol>
<p>In trading applications, the SMA is typically used for:</p>
<ul>
<li>Trend identification (direction and strength)</li>
<li>Signal generation through price/MA crossovers</li>
<li>Support/resistance level identification</li>
<li>Multiple MA crossover strategies (e.g., golden/death cross)</li>
<li>Component in more complex indicators (e.g., MACD, Bollinger Bands)</li>
</ul>
<p>The implementation challenge for FPGA-based systems is to calculate the SMA efficiently as new prices arrive, minimizing both computational complexity and memory requirements while maintaining accuracy. The sliding window algorithm addresses this challenge by incrementally updating the sum rather than recalculating it for each new price.</p>
<h4 id="implementation-algorithm">Implementation Algorithm</h4>
<p>The moving average implementation uses an efficient sliding window algorithm with O(1) computational complexity per update. This approach maintains a running sum of prices in the window, updating it incrementally as new prices arrive and old prices leave the window, rather than recalculating the entire sum for each new price.</p>
<p>The core algorithm can be described as:</p>
<ol>
<li>Initialize a sum to hold the total of all prices in the window</li>
<li>When a new price arrives:
<ul>
<li>Add the new price to the sum</li>
<li>Subtract the oldest price from the sum</li>
<li>Calculate the average by dividing the sum by the window size</li>
</ul>
</li>
<li>Store the new price in the circular buffer, replacing the oldest price</li>
</ol>
<p>This algorithm is implemented using a Finite State Machine (FSM) with three states:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        sum &lt;= <span class="hljs-number">0</span>; moving_avg &lt;= <span class="hljs-number">0</span>; done &lt;= <span class="hljs-number">0</span>; st &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (st)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
                sum &lt;= sum + new_price - oldest_price;
                moving_avg &lt;= sum / WINDOW;
                done &lt;= <span class="hljs-number">1</span>;
                st &lt;= <span class="hljs-number">2</span>;
            <span class="hljs-keyword">end</span>
            <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">0</span>;
                st &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Computational steps in detail:</p>
<ol>
<li>
<p><strong>State 0 (Idle)</strong>:</p>
<ul>
<li>Wait for the <code>start</code> signal</li>
<li>When <code>start</code> is asserted, transition to State 1</li>
</ul>
</li>
<li>
<p><strong>State 1 (Calculate)</strong>:</p>
<ul>
<li>Update the running sum: <code>sum &lt;= sum + new_price - oldest_price</code></li>
<li>Calculate the moving average: <code>moving_avg &lt;= sum / WINDOW</code></li>
<li>Assert the done flag: <code>done &lt;= 1</code></li>
<li>Transition to State 2</li>
</ul>
</li>
<li>
<p><strong>State 2 (Complete)</strong>:</p>
<ul>
<li>De-assert the done flag: <code>done &lt;= 0</code></li>
<li>Return to the idle state: <code>st &lt;= 0</code></li>
</ul>
</li>
</ol>
<p>This algorithm has several key advantages:</p>
<ol>
<li>
<p><strong>Computational Efficiency</strong>: Only three operations are required per update:</p>
<ul>
<li>One addition (new price to sum)</li>
<li>One subtraction (oldest price from sum)</li>
<li>One division (sum by window size)</li>
</ul>
</li>
<li>
<p><strong>Constant Time Complexity</strong>: The calculation time remains constant regardless of window size, making it O(1) instead of the O(n) complexity of a naive implementation.</p>
</li>
<li>
<p><strong>Memory Efficiency</strong>: Only the running sum needs to be maintained, rather than all individual prices (which are already stored in the price memory).</p>
</li>
<li>
<p><strong>Deterministic Timing</strong>: The calculation completes in a fixed number of clock cycles, providing predictable performance.</p>
</li>
</ol>
<p>The implementation includes careful consideration of numeric precision:</p>
<ul>
<li>The <code>sum</code> register is 64 bits to prevent overflow when accumulating prices</li>
<li>The <code>moving_avg</code> output is 32 bits to accommodate the division result</li>
<li>The division operation is integer division, with potential enhancements for fixed-point implementation</li>
</ul>
<p>This sliding window algorithm enables efficient calculation of the moving average with minimal latency and resource utilization, making it ideal for FPGA implementation in trading systems.</p>
<h4 id="optimization-techniques">Optimization Techniques</h4>
<p>The moving average implementation incorporates several key optimization techniques to enhance performance, minimize resource utilization, and ensure accuracy:</p>
<ol>
<li>
<p><strong>Sliding Window Approach</strong>:</p>
<ul>
<li>The O(1) complexity algorithm is a fundamental optimization</li>
<li>Eliminates the need to recalculate the entire sum for each update</li>
<li>Particularly valuable for larger window sizes</li>
<li>Reduces computational load dramatically</li>
<li>Ensures consistent performance regardless of window size</li>
</ul>
</li>
<li>
<p><strong>Extended Precision for Sum</strong>:</p>
<ul>
<li>64-bit register for the sum provides substantial headroom</li>
<li>Prevents overflow even with large price values and window sizes</li>
<li>Example: With 16-bit prices and a 20-period window:
<ul>
<li>Maximum possible sum: 20 * (2^16 - 1)  1.3 million</li>
<li>64-bit sum register provides ample margin (up to 2^64  18.4 quintillion)</li>
</ul>
</li>
<li>This eliminates the need for complex overflow handling</li>
</ul>
</li>
<li>
<p><strong>Minimal State Machine</strong>:</p>
<ul>
<li>Three-state FSM provides clean control flow with minimal overhead</li>
<li>State encoding optimized for efficiency (2 bits for 3 states)</li>
<li>Linear state progression simplifies logic and timing</li>
<li>Reset state is clearly defined for reliability</li>
<li>Limited state transitions improve predictability</li>
</ul>
</li>
<li>
<p><strong>Register Sizing Optimization</strong>:</p>
<ul>
<li>Each register sized appropriately for its purpose:
<ul>
<li>64-bit sum: Prevents overflow during accumulation</li>
<li>32-bit moving_avg: Accommodates division results</li>
<li>2-bit state register: Minimal size for three states</li>
</ul>
</li>
<li>This balances precision requirements with resource utilization</li>
</ul>
</li>
<li>
<p><strong>Single-Cycle State Transitions</strong>:</p>
<ul>
<li>Each state completes its operations in a single clock cycle</li>
<li>No multi-cycle operations or complex sequencing</li>
<li>Simplifies timing analysis and improves determinism</li>
<li>Enables maximum throughput of one update per cycle</li>
<li>Consistent latency for all calculations</li>
</ul>
</li>
<li>
<p><strong>Efficient Division Implementation</strong>:</p>
<ul>
<li>Integer division by a constant (WINDOW)</li>
<li>Division by powers of 2 can be optimized to shift operations</li>
<li>For arbitrary divisors, synthesis tools can optimize division</li>
<li>Potential for further optimization with fixed-point arithmetic</li>
</ul>
</li>
<li>
<p><strong>Clear Completion Signaling</strong>:</p>
<ul>
<li>The <code>done</code> signal provides clean synchronization</li>
<li>Single-cycle pulse simplifies downstream logic</li>
<li>Consistent protocol for all calculation modules</li>
<li>Eliminates need for complex handshaking</li>
<li>Enables easy integration with other components</li>
</ul>
</li>
<li>
<p><strong>Direct Memory Integration</strong>:</p>
<ul>
<li>Direct connection to price memory for data access</li>
<li>No intermediate buffers or staging registers</li>
<li>Immediate utilization of new and oldest prices</li>
<li>Clean data path from memory to calculation</li>
<li>Minimized latency from data availability to calculation</li>
</ul>
</li>
<li>
<p><strong>Parameter-Based Configuration</strong>:</p>
<ul>
<li>Window size (WINDOW) and data width (DW) are parameterized</li>
<li>Enables compile-time optimization for specific applications</li>
<li>No runtime overhead for configuration</li>
<li>Maintains clean implementation with flexibility</li>
<li>Simplifies adaptation for different markets or strategies</li>
</ul>
</li>
</ol>
<p>These optimization techniques combine to create an efficient, deterministic, and resource-conscious implementation of the moving average calculation, well-suited for FPGA deployment in high-performance trading systems.</p>
<h4 id="parameter-configuration">Parameter Configuration</h4>
<p>The moving average module is designed for flexibility through parameterization, allowing adaptation to different trading strategies, market characteristics, and precision requirements without code changes. This approach enables compile-time optimization while maintaining a clean and consistent implementation.</p>
<p>The module defines two primary parameters:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW     = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<p><strong>Window Size Parameter (WINDOW)</strong>:</p>
<ul>
<li>Default value: 20 periods</li>
<li>Defines the number of price points included in the moving average</li>
<li>Directly affects the smoothing characteristic of the indicator</li>
<li>Influences the lag between price movements and MA response</li>
<li>Typical values in trading applications:
<ul>
<li>5-10: Very short-term trend identification (intraday)</li>
<li>20: Short-term trend identification (days to weeks)</li>
<li>50: Medium-term trend identification (weeks to months)</li>
<li>200: Long-term trend identification (months to years)</li>
</ul>
</li>
</ul>
<p>The window size selection involves a tradeoff between responsiveness and noise filtering:</p>
<ul>
<li>Smaller windows: More responsive to price changes but more susceptible to market noise</li>
<li>Larger windows: Better filtering of noise but increased lag</li>
</ul>
<p><strong>Data Width Parameter (DW)</strong>:</p>
<ul>
<li>Default value: 16 bits</li>
<li>Defines the bit width of price inputs</li>
<li>Affects the range of price values that can be represented</li>
<li>Determines precision for fixed-point implementations</li>
<li>Typical values:
<ul>
<li>16 bits: Standard width for integer prices (0-65,535 range)</li>
<li>24 bits: Extended range for high-value instruments</li>
<li>32 bits: Maximum precision for fixed-point representation</li>
</ul>
</li>
</ul>
<p>The data width selection depends on the instrument characteristics and precision requirements:</p>
<ul>
<li>Typical stock prices: 16 bits sufficient</li>
<li>High-value instruments (e.g., BTC): May require wider representation</li>
<li>Fixed-point implementations: Width determined by integer and fractional requirements</li>
</ul>
<p><strong>Parameter Propagation</strong>:
Parameters are typically configured at the top level and propagated through the hierarchy:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Top-level instantiation with parameter overrides</span>
moving_average_fsm #(
    <span class="hljs-variable">.WINDOW</span>(<span class="hljs-number">50</span>),         <span class="hljs-comment">// 50-period MA for medium-term trend</span>
    <span class="hljs-variable">.DW</span>(<span class="hljs-number">24</span>)              <span class="hljs-comment">// 24-bit price width for extended range</span>
) ma_module (
    <span class="hljs-comment">// Port connections...</span>
);
</div></code></pre>
<p><strong>Impact of Parameter Changes</strong>:</p>
<ol>
<li>
<p><strong>Window Size Impact</strong>:</p>
<ul>
<li>Memory requirements in the price memory module</li>
<li>Division factor in the moving average calculation</li>
<li>Smoothing characteristics of the resulting indicator</li>
<li>Lag characteristics in trend identification</li>
<li>Effectiveness for different market conditions</li>
</ul>
</li>
<li>
<p><strong>Data Width Impact</strong>:</p>
<ul>
<li>Memory requirements for price storage</li>
<li>Sum register width requirements</li>
<li>Division operation precision</li>
<li>Range of representable price values</li>
<li>Resource utilization across the system</li>
</ul>
</li>
</ol>
<p><strong>Configuration Guidelines</strong>:</p>
<ol>
<li>
<p><strong>Market-Based Selection</strong>:</p>
<ul>
<li>Volatile markets: Smaller windows to reduce lag</li>
<li>Stable markets: Larger windows for better filtering</li>
<li>High-value instruments: Wider data width</li>
<li>Decimal price representation: Consider fixed-point implementation</li>
</ul>
</li>
<li>
<p><strong>Strategy-Based Selection</strong>:</p>
<ul>
<li>Trend following: Larger windows (20-50)</li>
<li>Mean reversion: Multiple windows for crossovers</li>
<li>Scalping: Smaller windows (5-10)</li>
<li>Position trading: Larger windows (50-200)</li>
</ul>
</li>
<li>
<p><strong>Resource Consideration</strong>:</p>
<ul>
<li>Larger windows increase memory requirements</li>
<li>Wider data width increases register and logic utilization</li>
<li>Complex division implementations impact DSP usage</li>
<li>Multiple indicator instances multiply resource requirements</li>
</ul>
</li>
</ol>
<p>The parameterized design enables optimization for specific applications while maintaining a consistent implementation, facilitating both customization and maintainability of the moving average module.</p>
<h4 id="fsm-design-details">FSM Design Details</h4>
<p>The Moving Average FSM implements a streamlined state machine design that controls the calculation process with clear states, deterministic transitions, and efficient operation. This approach provides a robust control mechanism that ensures proper sequencing and timing of the moving average calculation.</p>
<p>The FSM is implemented using a 2-bit state register with three distinct states:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] st = <span class="hljs-number">0</span>;  <span class="hljs-comment">// State register initialized to IDLE</span>

<span class="hljs-comment">// State definitions (implicit encoding)</span>
<span class="hljs-comment">// State 0: IDLE - Waiting for start signal</span>
<span class="hljs-comment">// State 1: CALCULATE - Performing calculation</span>
<span class="hljs-comment">// State 2: DONE - Signaling completion</span>
</div></code></pre>
<p><strong>State 0: IDLE</strong></p>
<ul>
<li>The default state after reset</li>
<li>Waits for the <code>start</code> signal to begin calculation</li>
<li>Performs no operations while in this state</li>
<li>Remains in this state until explicitly triggered</li>
<li>Transition: IDLE  CALCULATE when <code>start</code> is asserted</li>
</ul>
<p><strong>State 1: CALCULATE</strong></p>
<ul>
<li>Performs the core moving average calculation</li>
<li>Updates the running sum by adding new price and subtracting oldest price</li>
<li>Calculates the moving average by dividing the sum by the window size</li>
<li>Sets the <code>done</code> flag to indicate calculation completion</li>
<li>Transition: CALCULATE  DONE automatically after one cycle</li>
</ul>
<p><strong>State 2: DONE</strong></p>
<ul>
<li>Maintains the calculated result</li>
<li>Clears the <code>done</code> flag to create a one-cycle pulse</li>
<li>Completes the calculation sequence</li>
<li>Prepares for the next calculation cycle</li>
<li>Transition: DONE  IDLE automatically after one cycle</li>
</ul>
<p>The complete FSM implementation:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        sum &lt;= <span class="hljs-number">0</span>; moving_avg &lt;= <span class="hljs-number">0</span>; done &lt;= <span class="hljs-number">0</span>; st &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (st)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
                sum &lt;= sum + new_price - oldest_price;
                moving_avg &lt;= sum / WINDOW;
                done &lt;= <span class="hljs-number">1</span>;
                st &lt;= <span class="hljs-number">2</span>;
            <span class="hljs-keyword">end</span>
            <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">0</span>;
                st &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>State Transition Diagram</strong>:</p>
<pre class="hljs"><code><div>        start        auto    
      IDLE    CALCULATE  DONE 
     (st=0)                 (st=1)               (st=2)
                             
                                                       
         
                               auto
</div></code></pre>
<p><strong>FSM Design Considerations</strong>:</p>
<ol>
<li>
<p><strong>State Encoding</strong>:</p>
<ul>
<li>Binary encoding (0, 1, 2) for simplicity</li>
<li>2-bit state register accommodates three states</li>
<li>Natural state progression follows binary counting</li>
<li>Minimal logic for next-state determination</li>
<li>Efficient synthesis to hardware</li>
</ul>
</li>
<li>
<p><strong>Reset Behavior</strong>:</p>
<ul>
<li>Asynchronous reset for immediate system initialization</li>
<li>All registers cleared to known states</li>
<li>State reset to IDLE (0)</li>
<li>Sum cleared to prevent incorrect calculations</li>
<li>Done flag cleared to avoid false signals</li>
</ul>
</li>
<li>
<p><strong>Transition Logic</strong>:</p>
<ul>
<li>Minimal conditions for state transitions</li>
<li>Single input (<code>start</code>) triggers calculation</li>
<li>Automatic progression through calculation states</li>
<li>Complete calculation cycle: 3 clock cycles</li>
<li>Clean return to idle state for next operation</li>
</ul>
</li>
<li>
<p><strong>Output Generation</strong>:</p>
<ul>
<li><code>done</code> signal pulsed for exactly one clock cycle</li>
<li><code>moving_avg</code> updated in the CALCULATE state</li>
<li>Registered outputs for clean timing</li>
<li>Output valid when <code>done</code> is asserted</li>
<li>Stable outputs between calculations</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong>:</p>
<ul>
<li>Implicit handling of invalid states</li>
<li>Default transition to IDLE if in unexpected state</li>
<li>Clear initialization on reset</li>
<li>Predictable behavior under all conditions</li>
<li>No complex error recovery needed</li>
</ul>
</li>
<li>
<p><strong>Performance Optimization</strong>:</p>
<ul>
<li>Single-cycle state transitions</li>
<li>Minimal states for required functionality</li>
<li>No wait states or complex sequencing</li>
<li>Direct calculation in a single state</li>
<li>Immediate result generation</li>
</ul>
</li>
</ol>
<p>This streamlined FSM design creates a clean control flow for the moving average calculation, ensuring reliable operation with deterministic timing and minimal resource utilization. The simplicity of the state machine contributes to the overall efficiency and robustness of the moving average implementation.</p>
<h4 id="precision-considerations">Precision Considerations</h4>
<p>The moving average implementation incorporates several precision considerations to ensure accurate calculations while optimizing resource utilization. These considerations address the challenges of representing financial data, preventing overflow, and managing division operations in hardware.</p>
<ol>
<li>
<p><strong>Register Width Selection</strong>:</p>
<ul>
<li>
<p><strong>Sum Register (64-bit)</strong>:</p>
<ul>
<li>Accumulates price values for the moving average calculation</li>
<li>Extended width prevents overflow during accumulation</li>
<li>For n-bit prices and a window of size W:
<ul>
<li>Theoretical maximum sum: W * (2^n - 1)</li>
<li>With 16-bit prices and a 20-period window:
<ul>
<li>Max sum  20 * 65,535  1.3 million</li>
<li>64-bit register provides ample margin (up to 2^64  18.4 quintillion)</li>
</ul>
</li>
</ul>
</li>
<li>Wider than necessary for most applications, but eliminates overflow concerns</li>
</ul>
</li>
<li>
<p><strong>Moving Average Output (32-bit)</strong>:</p>
<ul>
<li>Stores the result of dividing sum by window size</li>
<li>For 16-bit prices, the average cannot exceed the maximum price value (2^16 - 1)</li>
<li>32-bit width provides room for future extension to fixed-point representation</li>
<li>Compatible with standard data bus widths in FPGA architectures</li>
<li>Balances precision with resource utilization</li>
</ul>
</li>
<li>
<p><strong>State Register (2-bit)</strong>:</p>
<ul>
<li>Encodes three states: IDLE (0), CALCULATE (1), and DONE (2)</li>
<li>Minimal width reduces register resource requirements</li>
<li>Provides one additional state value for potential extension</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Division Implementation</strong>:</p>
<ul>
<li>
<p>The moving average calculation requires division by the window size:</p>
<pre class="hljs"><code><div>moving_avg &lt;= sum / WINDOW;
</div></code></pre>
</li>
<li>
<p><strong>Integer Division Characteristics</strong>:</p>
<ul>
<li>Truncates fractional results (rounds toward zero)</li>
<li>Precision loss increases with larger divisors</li>
<li>For price data, this is typically acceptable</li>
<li>Division by a constant is optimized during synthesis</li>
</ul>
</li>
<li>
<p><strong>Optimization for Powers of 2</strong>:</p>
<ul>
<li>When WINDOW is a power of 2 (e.g., 16, 32), division becomes a shift operation:<pre class="hljs"><code><div><span class="hljs-comment">// Optimized implementation for WINDOW = 16</span>
moving_avg &lt;= sum &gt;&gt; <span class="hljs-number">4</span>;  <span class="hljs-comment">// Shift right by 4 bits (divide by 16)</span>
</div></code></pre>
</li>
<li>Significantly more efficient in hardware</li>
<li>Reduces both resource utilization and latency</li>
<li>Many trading applications use power-of-2 window sizes for this reason</li>
</ul>
</li>
<li>
<p><strong>Fixed-Point Considerations</strong>:</p>
<ul>
<li>For applications requiring decimal precision:<pre class="hljs"><code><div><span class="hljs-comment">// Fixed-point division with 8 fractional bits</span>
moving_avg &lt;= (sum &lt;&lt; <span class="hljs-number">8</span>) / WINDOW;  <span class="hljs-comment">// Scale up before division</span>
</div></code></pre>
</li>
<li>Maintains fractional precision through scaling</li>
<li>Requires appropriate interpretation of the result</li>
<li>Increases register width requirements</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Accumulation Error Management</strong>:</p>
<ul>
<li>The sliding window algorithm can accumulate rounding errors over time</li>
<li><strong>Potential Mitigation Strategies</strong>:
<ul>
<li>Periodic recalculation of the complete sum</li>
<li>Extended precision for intermediate calculations</li>
<li>Careful monitoring of error bounds</li>
<li>Fixed-point arithmetic for critical applications</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Overflow Prevention</strong>:</p>
<ul>
<li>The extended sum register prevents overflow in normal operation</li>
<li>For extreme market conditions or very large window sizes:
<ul>
<li>Saturation logic could be added</li>
<li>Overflow detection and handling</li>
<li>Error signaling for diagnostic purposes</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Implementation Tradeoffs</strong>:</p>
<ul>
<li>
<p><strong>Precision vs. Resources</strong>:</p>
<ul>
<li>Wider registers improve precision but increase resource usage</li>
<li>Fixed-point arithmetic enhances precision but adds complexity</li>
<li>Integer division simplifies implementation but limits precision</li>
</ul>
</li>
<li>
<p><strong>Latency vs. Accuracy</strong>:</p>
<ul>
<li>More complex division methods improve accuracy but increase latency</li>
<li>Multi-cycle division can improve resource utilization at the cost of throughput</li>
<li>Approximation methods can reduce latency but introduce error</li>
</ul>
</li>
<li>
<p><strong>Generality vs. Optimization</strong>:</p>
<ul>
<li>Parameterized implementation provides flexibility but may not optimize for specific cases</li>
<li>Hard-coded window sizes allow specific optimizations</li>
<li>Application-specific customization may be warranted for critical systems</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The current implementation balances these considerations with a focus on reliability, deterministic behavior, and sufficient precision for most trading applications, while leaving room for application-specific optimization when needed.</p>
<h3 id="rsi-implementation">RSI Implementation</h3>
<h4 id="rsi-theory-and-calculation">RSI Theory and Calculation</h4>
<p>The Relative Strength Index (RSI) is a momentum oscillator developed by J. Welles Wilder in 1978 that measures the speed and magnitude of price movements. It oscillates between 0 and 100, with readings above 70 typically considered overbought and readings below 30 considered oversold. The RSI is widely used to identify potential reversal points, momentum changes, and divergence between price and momentum.</p>
<p><strong>Mathematical Foundation</strong>:</p>
<p>The RSI is calculated using the ratio of average gains to average losses over a specified period:</p>
<p>$$RSI = 100 - \frac{100}{1 + RS}$$</p>
<p>Where RS (Relative Strength) is:</p>
<p>$$RS = \frac{Average:Gain}{Average:Loss}$$</p>
<p>This can be alternatively expressed as:</p>
<p>$$RSI = 100 \times \frac{Average:Gain}{Average:Gain + Average:Loss}$$</p>
<p>The calculation involves several steps:</p>
<ol>
<li>
<p><strong>Calculate Price Changes</strong>:</p>
<ul>
<li>For each period, determine if there was a gain (positive change) or loss (negative change)</li>
<li>Gain = Current Price - Previous Price (if positive, otherwise 0)</li>
<li>Loss = Previous Price - Current Price (if positive, otherwise 0)</li>
</ul>
</li>
<li>
<p><strong>Calculate Average Gain and Loss</strong>:</p>
<ul>
<li>For the first calculation (when no previous average exists):
<ul>
<li>Average Gain = Sum of Gains over the period / Period length</li>
<li>Average Loss = Sum of Losses over the period / Period length</li>
</ul>
</li>
<li>For subsequent calculations (using Wilder's smoothing method):
<ul>
<li>Average Gain = ((Previous Average Gain  (period-1)) + Current Gain) / period</li>
<li>Average Loss = ((Previous Average Loss  (period-1)) + Current Loss) / period</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Calculate RS and RSI</strong>:</p>
<ul>
<li>RS = Average Gain / Average Loss</li>
<li>RSI = 100 - (100 / (1 + RS)) or RSI = 100  (Average Gain / (Average Gain + Average Loss))</li>
</ul>
</li>
</ol>
<p><strong>Implementation Approaches</strong>:</p>
<p>There are two common methods for calculating RSI:</p>
<ol>
<li>
<p><strong>Simple Method (Used in this implementation)</strong>:</p>
<ul>
<li>Directly sum all gains and losses over the period</li>
<li>Calculate RSI using total gains and losses</li>
<li>Simpler to implement and requires less state</li>
<li>Works well for fixed-length windows</li>
</ul>
</li>
<li>
<p><strong>Wilder's Smoothing Method</strong>:</p>
<ul>
<li>Uses exponential smoothing of gains and losses</li>
<li>Maintains running averages that are updated incrementally</li>
<li>Produces smoother RSI values</li>
<li>Requires maintaining more state variables</li>
</ul>
</li>
</ol>
<p>The implemented RSI calculator uses the Simple Method with a default period of 14, which is the traditional period recommended by Wilder and widely used in technical analysis.</p>
<p><strong>Trading Applications of RSI</strong>:</p>
<ol>
<li>
<p><strong>Overbought/Oversold Conditions</strong>:</p>
<ul>
<li>RSI &gt; 70: Potentially overbought, may signal a selling opportunity</li>
<li>RSI &lt; 30: Potentially oversold, may signal a buying opportunity</li>
</ul>
</li>
<li>
<p><strong>Divergence Analysis</strong>:</p>
<ul>
<li>Bullish Divergence: Price makes a lower low but RSI makes a higher low</li>
<li>Bearish Divergence: Price makes a higher high but RSI makes a lower high</li>
</ul>
</li>
<li>
<p><strong>Centerline Crossovers</strong>:</p>
<ul>
<li>RSI crossing above 50: Potentially indicating increasing bullish momentum</li>
<li>RSI crossing below 50: Potentially indicating increasing bearish momentum</li>
</ul>
</li>
<li>
<p><strong>Failure Swings</strong>:</p>
<ul>
<li>Reversal signals that occur without crossing overbought/oversold thresholds</li>
</ul>
</li>
<li>
<p><strong>Support/Resistance Levels</strong>:</p>
<ul>
<li>RSI often respects support and resistance levels, even when not visible on price charts</li>
</ul>
</li>
</ol>
<p>The RSI implementation in this system focuses on efficiently calculating the indicator value while managing the computational challenges inherent in FPGA implementation, particularly around gain/loss accumulation and division operations.</p>
<h4 id="fsm-implementation-approach">FSM Implementation Approach</h4>
<p>The RSI implementation employs a sophisticated Finite State Machine (FSM) approach to manage the sequential process of calculating the Relative Strength Index. This state-based design provides a clear operational flow, ensures proper data handling, and creates a deterministic calculation process suitable for hardware implementation.</p>
<p>The RSI FSM implements a 6-state machine to control the calculation process:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">3&#x27;b000</span>,
           FILL_FIFO = <span class="hljs-number">3&#x27;b001</span>,
           READ_INIT = <span class="hljs-number">3&#x27;b010</span>,
           READ_WAIT = <span class="hljs-number">3&#x27;b011</span>,
           COMPARE   = <span class="hljs-number">3&#x27;b100</span>,
           DONE      = <span class="hljs-number">3&#x27;b101</span>;
</div></code></pre>
<p>Each state serves a specific purpose in the calculation sequence:</p>
<p>The FSM state transitions follow this pattern:</p>
<pre class="hljs"><code><div>                  
                       
        IDLE 
                               
                          
                                 
                                 
                        
                                
    FILL_FIFO                   
                                
                        
                                 
                                 
                       
                                
    READ_INIT                   
                                
                       
                                 
                                 
                
                              
    COMPARE  DONE 
                           
             
        
        
   
            
   READ_WAIT
               
      
                
         
</div></code></pre>
<p>This diagram shows how the states connect to form a complete calculation cycle, with the READ_WAIT and COMPARE states forming a loop that processes each price pair until all samples have been analyzed.</p>
<p>The 3-bit state encoding provides efficient implementation while accommodating all required states, with a clear distinction between operational phases.</p>
<p>The FSM implementation includes several key design considerations:</p>
<ol>
<li>
<p><strong>State Management</strong>:</p>
<ul>
<li>3-bit state register accommodates six distinct states</li>
<li>Clear state transitions based on well-defined conditions</li>
<li>Default state (IDLE) for initialization and between calculations</li>
<li>Linear progression through primary calculation phases</li>
<li>Cyclic pattern between COMPARE and READ_WAIT for sample processing</li>
</ul>
</li>
<li>
<p><strong>Resource Optimization</strong>:</p>
<ul>
<li>Minimal state register width (3 bits)</li>
<li>Efficient state encoding for synthesis</li>
<li>Single-cycle transitions where possible</li>
<li>Reuse of control signals across states</li>
<li>Balanced distribution of operations</li>
</ul>
</li>
<li>
<p><strong>Timing Management</strong>:</p>
<ul>
<li>One-cycle delay handling for FIFO operations</li>
<li>Explicit synchronization using the <code>read_delay</code> flag</li>
<li>Clear delineation between control and calculation phases</li>
<li>Predictable cycle count for complete calculation</li>
<li>Deterministic operation regardless of input data</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong>:</p>
<ul>
<li>Protection against division by zero in final calculation</li>
<li>Empty FIFO detection to prevent underflow</li>
<li>Counter-based sample tracking to prevent overprocessing</li>
<li>Clear reset behavior for system initialization</li>
<li>Default case for unexpected state values</li>
</ul>
</li>
<li>
<p><strong>Interface Considerations</strong>:</p>
<ul>
<li>Clean <code>done</code> signal generation for downstream synchronization</li>
<li>Clear relationship between input signals and state transitions</li>
<li>Consistent protocol for FIFO read/write operations</li>
<li>Well-defined completion signaling</li>
<li>Observable state for debugging and verification</li>
</ul>
</li>
</ol>
<p>This FSM approach creates a robust, deterministic framework for the RSI calculation process, ensuring reliable operation with predictable timing characteristics and clear operational phases.</p>
<h4 id="gainloss-accumulation">Gain/Loss Accumulation</h4>
<p>The RSI calculation fundamentally depends on accurately tracking price gains and losses over a specified period. The implementation uses an efficient approach to accumulate these values, enabling accurate RSI calculation with minimal computational overhead.</p>
<p>The gain/loss accumulation process occurs primarily in the READ_WAIT state, where consecutive prices are compared to determine price changes:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (price_out &gt; prev_price)
    gain_sum &lt;= gain_sum + (price_out - prev_price);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_out &lt; prev_price)
    loss_sum &lt;= loss_sum + (prev_price - price_out);
</div></code></pre>
<p>This approach implements several key features:</p>
<ol>
<li>
<p><strong>Direct Comparison Logic</strong>:</p>
<ul>
<li>Straightforward comparison between current and previous prices</li>
<li>Binary decision between gain and loss accumulation</li>
<li>No calculation when prices are equal</li>
<li>Absolute value approach for loss calculation</li>
<li>Integer precision for all comparisons</li>
</ul>
</li>
<li>
<p><strong>Accumulator Design</strong>:</p>
<ul>
<li>32-bit registers for both gain_sum and loss_sum</li>
<li>Initialized to zero at the start of each calculation cycle</li>
<li>Sequential accumulation as each price pair is processed</li>
<li>No normalization or averaging during accumulation</li>
<li>Sufficient width to prevent overflow for typical price ranges</li>
</ul>
</li>
<li>
<p><strong>Sequential Processing</strong>:</p>
<ul>
<li>Prices are processed in pairs as they are read from the FIFO</li>
<li>Each price becomes the &quot;previous price&quot; for the next comparison</li>
<li>Consistent ordering ensures correct gain/loss identification</li>
<li>Sample counter tracks progress through the price history</li>
<li>Complete processing of all available samples</li>
</ul>
</li>
<li>
<p><strong>Optimization Considerations</strong>:</p>
<ul>
<li>Only one comparison path is active per cycle (gain or loss)</li>
<li>Integer arithmetic for efficient implementation</li>
<li>Direct accumulation without intermediate storage</li>
<li>Single-cycle update for each price pair</li>
<li>No division operations during accumulation phase</li>
</ul>
</li>
<li>
<p><strong>Example Calculation Sequence</strong>:</p>
<p>For a sequence of prices [100, 98, 101, 99, 102]:</p>
<table>
<thead>
<tr>
<th>Cycle</th>
<th>prev_price</th>
<th>curr_price</th>
<th>Change</th>
<th>Action</th>
<th>gain_sum</th>
<th>loss_sum</th>
</tr>
</thead>
<tbody>
<tr>
<td>Init</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Initialize</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>100</td>
<td>98</td>
<td>-2</td>
<td>Add to loss</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>98</td>
<td>101</td>
<td>+3</td>
<td>Add to gain</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>101</td>
<td>99</td>
<td>-2</td>
<td>Add to loss</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>99</td>
<td>102</td>
<td>+3</td>
<td>Add to gain</td>
<td>6</td>
<td>4</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>This accumulation approach efficiently tracks the total gains and losses over the specified period, providing the necessary inputs for the final RSI calculation while maintaining accuracy and computational efficiency.</p>
<p>The accumulators are designed with sufficient width (32 bits) to handle typical price ranges and window sizes without overflow concerns, similar to the approach used in the moving average calculation but tailored to the specific requirements of RSI calculation.</p>
<h4 id="final-calculation-method">Final Calculation Method</h4>
<p>The RSI calculation culminates in the DONE state, where the accumulated gains and losses are used to compute the final RSI value according to the standard formula. This critical step implements the core mathematical relationship that defines the Relative Strength Index.</p>
<p>The final calculation is implemented as:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> ((gain_sum + loss_sum) &gt; <span class="hljs-number">0</span>)
    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
<span class="hljs-keyword">else</span>
    rsi &lt;= <span class="hljs-number">0</span>;
</div></code></pre>
<p>This implementation incorporates several important considerations:</p>
<ol>
<li>
<p><strong>Mathematical Foundation</strong>:</p>
<ul>
<li>Implements the formula RSI = 100  (Average Gain / (Average Gain + Average Loss))</li>
<li>Uses the accumulated sums directly without additional averaging</li>
<li>Calculation produces values in the standard 0-100 range</li>
<li>Consistent with traditional RSI interpretation (&gt;70 overbought, &lt;30 oversold)</li>
<li>Integer arithmetic provides sufficient precision for trading applications</li>
</ul>
</li>
<li>
<p><strong>Division Implementation</strong>:</p>
<ul>
<li>Integer division operation with 100 scaling factor</li>
<li>Division denominator is the sum of gains and losses</li>
<li>Numerator is the gain_sum scaled by 100</li>
<li>Result range is properly constrained to 0-100</li>
<li>Consistent with the 8-bit output representation</li>
</ul>
</li>
<li>
<p><strong>Special Case Handling</strong>:</p>
<ul>
<li>Explicit check for zero denominator: <code>(gain_sum + loss_sum) &gt; 0</code></li>
<li>Default value of 0 when no price changes have occurred</li>
<li>Protection against division by zero errors</li>
<li>Deterministic behavior for all input conditions</li>
<li>Graceful handling of edge cases</li>
</ul>
</li>
<li>
<p><strong>Numerical Considerations</strong>:</p>
<ul>
<li>Integer division truncates fractional results (rounds toward zero)</li>
<li>Precision is limited to whole-number RSI values (sufficient for most applications)</li>
<li>Pre-scaling by 100 ensures meaningful integer results</li>
<li>8-bit output register accommodates the full 0-100 range</li>
<li>No loss of significant information in the conversion</li>
</ul>
</li>
<li>
<p><strong>Timing Aspects</strong>:</p>
<ul>
<li>Calculation occurs entirely within the DONE state</li>
<li>Single-cycle computation for efficiency</li>
<li>Result is immediately available with the done signal</li>
<li>Clean transition back to IDLE after calculation</li>
<li>Deterministic latency from accumulation completion to result</li>
</ul>
</li>
</ol>
<p>The direct implementation of the RSI formula provides several advantages:</p>
<ul>
<li>Computational efficiency with minimal operations</li>
<li>Clear relationship to the mathematical definition</li>
<li>Predictable output range and behavior</li>
<li>Easily verifiable results</li>
<li>Compatible with standard RSI interpretation</li>
</ul>
<p>This final calculation approach balances accuracy with implementation efficiency, providing reliable RSI values suitable for technical analysis applications while minimizing resource utilization and maintaining deterministic timing characteristics.</p>
<h4 id="edge-case-handling">Edge Case Handling</h4>
<p>The RSI implementation incorporates specific mechanisms to handle edge cases and special conditions that might arise during calculation. These approaches ensure robust operation even under unusual market conditions or data patterns.</p>
<ol>
<li>
<p><strong>Division by Zero Protection</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> ((gain_sum + loss_sum) &gt; <span class="hljs-number">0</span>)
    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
<span class="hljs-keyword">else</span>
    rsi &lt;= <span class="hljs-number">0</span>;
</div></code></pre>
<ul>
<li>Explicit check for zero denominator</li>
<li>Default RSI value of 0 when no price changes have occurred</li>
<li>Prevents potential hardware failure from illegal division</li>
<li>Provides deterministic behavior for all input patterns</li>
<li>Consistent with RSI interpretation (no momentum = 0)</li>
</ul>
</li>
<li>
<p><strong>First Sample Handling</strong>:</p>
<ul>
<li>Special logic in the READ_INIT state isolates the first price</li>
<li>Prevents invalid comparison before two prices are available</li>
<li>Establishes a baseline for subsequent comparisons</li>
<li>Creates consistent starting conditions</li>
<li>Ensures proper sequencing from the beginning</li>
</ul>
</li>
<li>
<p><strong>Equal Prices Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (price_out &gt; prev_price)
    gain_sum &lt;= gain_sum + (price_out - prev_price);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_out &lt; prev_price)
    loss_sum &lt;= loss_sum + (prev_price - price_out);
<span class="hljs-comment">// No action when prices are equal</span>
</div></code></pre>
<ul>
<li>Explicit conditions for both gain and loss cases</li>
<li>No accumulation when consecutive prices are identical</li>
<li>Avoids unnecessary calculations</li>
<li>Correctly handles periods of price stability</li>
<li>Maintains accurate representation of market momentum</li>
</ul>
</li>
<li>
<p><strong>FIFO Empty Detection</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (sample_cnt &lt; <span class="hljs-number">19</span> &amp;&amp; !fifo_empty) <span class="hljs-keyword">begin</span>
    fifo_rd_en &lt;= <span class="hljs-number">1</span>;
    read_delay &lt;= <span class="hljs-number">1</span>;
    state &lt;= READ_WAIT;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Explicit check for FIFO empty condition</li>
<li>Prevents read attempts from an empty buffer</li>
<li>Ensures data validity throughout calculation</li>
<li>Protects against timing issues</li>
<li>Maintains FIFO integrity</li>
</ul>
</li>
<li>
<p><strong>Sample Count Tracking</strong>:</p>
<ul>
<li>Explicit counter for processed samples</li>
<li>Comparison against expected count (19 for 20 samples)</li>
<li>Ensures complete processing of all required data</li>
<li>Prevents premature calculation completion</li>
<li>Maintains consistent window size for calculation</li>
</ul>
</li>
<li>
<p><strong>Reset Behavior</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    state &lt;= IDLE;
    fifo_wr_en &lt;= <span class="hljs-number">0</span>;
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    done &lt;= <span class="hljs-number">0</span>;
    rsi &lt;= <span class="hljs-number">0</span>;
    sample_cnt &lt;= <span class="hljs-number">0</span>;
    gain_sum &lt;= <span class="hljs-number">0</span>;
    loss_sum &lt;= <span class="hljs-number">0</span>;
    prev_price &lt;= <span class="hljs-number">0</span>;
    read_delay &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Complete initialization of all registers</li>
<li>Known starting state for all variables</li>
<li>Clean FIFO control signals</li>
<li>Consistent output values after reset</li>
<li>Predictable behavior during system initialization</li>
</ul>
</li>
<li>
<p><strong>Read Delay Management</strong>:</p>
<ul>
<li>Explicit flag (<code>read_delay</code>) tracks FIFO read timing</li>
<li>Compensates for one-cycle delay in data availability</li>
<li>Ensures proper sequencing of price comparisons</li>
<li>Prevents race conditions in data processing</li>
<li>Maintains data integrity throughout calculation</li>
</ul>
</li>
<li>
<p><strong>Signal Timing Coordination</strong>:</p>
<ul>
<li>One-cycle pulses for control signals</li>
<li>Clear separation between sequential operations</li>
<li>Explicit state transitions for operational phases</li>
<li>Predictable timing relationships</li>
<li>Deterministic cycle count for complete calculation</li>
</ul>
</li>
</ol>
<p>These edge case handling mechanisms collectively ensure that the RSI calculation remains robust and accurate across all market conditions and data patterns, preventing errors that might otherwise arise from special conditions or unusual price sequences.</p>
<h4 id="optimization-details">Optimization Details</h4>
<p>The RSI implementation incorporates several optimization techniques to enhance performance, minimize resource utilization, and ensure efficient operation on FPGA platforms:</p>
<ol>
<li>
<p><strong>Incremental Calculation Approach</strong>:</p>
<ul>
<li>Direct accumulation of gains and losses without recalculation</li>
<li>O(1) complexity per price update</li>
<li>Elimination of redundant calculations</li>
<li>Minimal memory access requirements</li>
<li>Efficient utilization of computational resources</li>
</ul>
</li>
<li>
<p><strong>Register Sizing Optimization</strong>:</p>
<ul>
<li>32-bit accumulators for gain_sum and loss_sum
<ul>
<li>Sufficient width to prevent overflow (typical price changes * period)</li>
<li>Balanced precision and resource utilization</li>
</ul>
</li>
<li>16-bit price registers (prev_price, curr_price)
<ul>
<li>Compatible with standard price representation</li>
<li>Sufficient range for typical financial instruments</li>
</ul>
</li>
<li>3-bit state register
<ul>
<li>Minimal width for six states</li>
<li>Efficient encoding for hardware implementation</li>
</ul>
</li>
<li>8-bit RSI output
<ul>
<li>Precisely matches 0-100 range requirement</li>
<li>No wasted bits or unnecessary precision</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Memory Management</strong>:</p>
<ul>
<li>Price FIFO implements efficient circular buffer</li>
<li>Direct access to price values without redundant storage</li>
<li>Minimal pointer management</li>
<li>Synchronized read/write operations</li>
<li>Clear full/empty indicators for control flow</li>
</ul>
</li>
<li>
<p><strong>Control Flow Optimization</strong>:</p>
<ul>
<li>State-based processing eliminates complex control logic</li>
<li>Deterministic transitions minimize conditional branches</li>
<li>Single-cycle state updates where possible</li>
<li>Clear operational phases with minimal overhead</li>
<li>Predictable cycle count for verification</li>
</ul>
</li>
<li>
<p><strong>Calculation Efficiency</strong>:</p>
<ul>
<li>Direct integer arithmetic for all operations</li>
<li>Division only performed once at calculation completion</li>
<li>No complex mathematical functions</li>
<li>Minimal intermediate storage requirements</li>
<li>Single-path execution for most operations</li>
</ul>
</li>
<li>
<p><strong>Interface Efficiency</strong>:</p>
<ul>
<li>Clean one-cycle pulses for control signals</li>
<li>Minimal handshaking overhead</li>
<li>Direct data paths between modules</li>
<li>Consistent protocol across interfaces</li>
<li>Clear completion signaling</li>
</ul>
</li>
<li>
<p><strong>FSM Structure Optimization</strong>:</p>
<ul>
<li>Balanced state distribution for functionality</li>
<li>Minimal transitions between states</li>
<li>Linear progression through primary calculation phases</li>
<li>Clear separation of initialization, processing, and completion</li>
<li>Default state handling for robustness</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Considerations</strong>:</p>
<ul>
<li>Register reuse where appropriate</li>
<li>Minimal intermediate storage</li>
<li>Efficient arithmetic implementation</li>
<li>Balance between sequential and combinational logic</li>
<li>Predictable synthesis to FPGA resources</li>
</ul>
</li>
<li>
<p><strong>Potential Advanced Optimizations</strong>:</p>
<ul>
<li>Fixed-point arithmetic for improved precision</li>
<li>Pipelined division for higher throughput</li>
<li>Resource sharing between calculation modules</li>
<li>Parameterized implementation for different window sizes</li>
<li>Clock gating for power efficiency in inactive states</li>
</ul>
</li>
</ol>
<p>These optimization techniques collectively create an implementation that balances performance, resource utilization, and calculation accuracy, providing efficient RSI computation suitable for real-time trading applications on FPGA platforms. The design particularly emphasizes deterministic timing and predictable resource requirements, key considerations for hardware implementation.</p>
<h3 id="trading-decision-logic">Trading Decision Logic</h3>
<h4 id="strategy-implementation">Strategy Implementation</h4>
<p>The trading decision module implements a momentum-based mean reversion strategy that combines trend analysis (using price vs. moving average) with momentum indicators (RSI) to generate buy and sell signals. This approach aims to identify potential reversal points in the market where price action is likely to revert to the mean after reaching extreme conditions.</p>
<p>The strategy logic is implemented with a straightforward approach:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
)(
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_now,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         sell
);
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            buy  &lt;= <span class="hljs-number">0</span>;
            sell &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
            sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This implementation defines a specific trading strategy with the following characteristics:</p>
<ol>
<li>
<p><strong>Buy Signal Conditions</strong>:</p>
<ul>
<li>Price is ABOVE the moving average (indicates uptrend)</li>
<li>RSI is BELOW the buy threshold (indicates oversold condition)</li>
<li>Both conditions must be true simultaneously</li>
<li>Default threshold: RSI &lt; 30 (traditional oversold level)</li>
</ul>
</li>
<li>
<p><strong>Sell Signal Conditions</strong>:</p>
<ul>
<li>Price is BELOW the moving average (indicates downtrend)</li>
<li>RSI is ABOVE the sell threshold (indicates overbought condition)</li>
<li>Both conditions must be true simultaneously</li>
<li>Default threshold: RSI &gt; 70 (traditional overbought level)</li>
</ul>
</li>
<li>
<p><strong>Strategy Rationale</strong>:</p>
<ul>
<li><strong>Trend Confirmation</strong>: The price vs. MA comparison confirms the primary trend direction</li>
<li><strong>Momentum Divergence</strong>: The RSI identifies potential reversal points through overbought/oversold conditions</li>
<li><strong>Mean Reversion Principle</strong>: The strategy assumes prices will revert to the mean after reaching extremes</li>
<li><strong>Contrary Trading</strong>: Buying during oversold conditions and selling during overbought conditions</li>
</ul>
</li>
<li>
<p><strong>Strategy Characteristics</strong>:</p>
<ul>
<li><strong>Type</strong>: Counter-trend, mean reversion</li>
<li><strong>Timeframe</strong>: Determined by MA period (default: 20) and RSI period (default: 14)</li>
<li><strong>Risk Profile</strong>: Moderate (requires confirmation from multiple indicators)</li>
<li><strong>Applicability</strong>: Works best in range-bound markets, less effective in strong trends</li>
<li><strong>Signal Frequency</strong>: Depends on market volatility and threshold settings</li>
</ul>
</li>
</ol>
<p>The strategy implementation is intentionally streamlined for efficiency and clarity, with parameterized thresholds allowing for customization to different market conditions and risk preferences without changing the core logic.</p>
<h4 id="signal-generation-criteria">Signal Generation Criteria</h4>
<p>The trading decision module generates buy and sell signals based on specific combinations of technical indicator values. These criteria are carefully designed to identify potential trading opportunities while minimizing false signals.</p>
<p>The signal generation logic is implemented as:</p>
<pre class="hljs"><code><div>buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);
</div></code></pre>
<p>This logic implements several key concepts for technical trading:</p>
<ol>
<li>
<p><strong>Buy Signal Criteria</strong>:</p>
<p>A buy signal is generated when both of these conditions are true:</p>
<ul>
<li><strong>Price &gt; Moving Average</strong>: This indicates an uptrend is in progress</li>
<li><strong>RSI &lt; BUY_RSI_THR (default: 30)</strong>: This indicates an oversold condition</li>
</ul>
<p>This combination identifies situations where:</p>
<ul>
<li>The market is in an overall uptrend (price above MA)</li>
<li>The price has temporarily pulled back (low RSI)</li>
<li>There is a higher probability of upward price movement</li>
<li>The risk/reward ratio is favorable for long positions</li>
</ul>
</li>
<li>
<p><strong>Sell Signal Criteria</strong>:</p>
<p>A sell signal is generated when both of these conditions are true:</p>
<ul>
<li><strong>Price &lt; Moving Average</strong>: This indicates a downtrend is in progress</li>
<li><strong>RSI &gt; SELL_RSI_THR (default: 70)</strong>: This indicates an overbought condition</li>
</ul>
<p>This combination identifies situations where:</p>
<ul>
<li>The market is in an overall downtrend (price below MA)</li>
<li>The price has temporarily rallied (high RSI)</li>
<li>There is a higher probability of downward price movement</li>
<li>The risk/reward ratio is favorable for short positions</li>
</ul>
</li>
<li>
<p><strong>Signal Logic Implementation</strong>:</p>
<ul>
<li><strong>AND Logic</strong>: Both conditions must be true simultaneously</li>
<li><strong>Registered Outputs</strong>: Signals are synchronized to the clock</li>
<li><strong>Mutual Exclusivity</strong>: Buy and sell conditions are mutually exclusive by design</li>
<li><strong>Clean Reset</strong>: Both signals are cleared on system reset</li>
<li><strong>Continuous Evaluation</strong>: Conditions are re-evaluated on every clock cycle</li>
</ul>
</li>
<li>
<p><strong>Threshold Considerations</strong>:</p>
<ul>
<li><strong>Default Values</strong>: Based on traditional technical analysis practices
<ul>
<li>RSI &lt; 30: Standard oversold threshold</li>
<li>RSI &gt; 70: Standard overbought threshold</li>
</ul>
</li>
<li><strong>Parameterization</strong>: Thresholds can be adjusted without code changes</li>
<li><strong>Customization Options</strong>:
<ul>
<li>More aggressive thresholds: 20/80 for fewer but stronger signals</li>
<li>More conservative thresholds: 40/60 for more frequent but weaker signals</li>
<li>Asymmetric thresholds: Different values for buy vs. sell to match market characteristics</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Signal Quality Factors</strong>:</p>
<ul>
<li><strong>Confirmation</strong>: Using multiple indicators reduces false signals</li>
<li><strong>Confluence</strong>: Both trend and momentum must align for signal generation</li>
<li><strong>Timeliness</strong>: Signals occur at potential market turning points</li>
<li><strong>Clarity</strong>: Binary output provides clear action indication</li>
<li><strong>Flexibility</strong>: Parameterized thresholds allow strategy tuning</li>
</ul>
</li>
</ol>
<p>These signal generation criteria implement a specific trading approach that aims to:</p>
<ul>
<li>Enter long positions during uptrends when prices have pulled back</li>
<li>Enter short positions during downtrends when prices have rallied</li>
<li>Avoid trading against the primary trend</li>
<li>Use extreme RSI readings to identify potential reversal points</li>
<li>Wait for confluence between different technical indicators</li>
</ul>
<h4 id="threshold-configuration">Threshold Configuration</h4>
<p>The trading decision module implements a parameterized approach to threshold configuration, allowing customization of the strategy sensitivity without code changes. This design enables adaptation to different market conditions, instruments, and trading preferences through simple parameter adjustments.</p>
<p>The threshold parameters are defined at the module level:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<p>These parameters control the RSI levels at which buy and sell signals are generated, offering several key advantages:</p>
<ol>
<li>
<p><strong>Default Configuration</strong>:</p>
<ul>
<li><strong>BUY_RSI_THR = 30</strong>: The traditional oversold level for RSI</li>
<li><strong>SELL_RSI_THR = 70</strong>: The traditional overbought level for RSI</li>
<li>These values follow standard technical analysis practices</li>
<li>Provide a balanced approach for most market conditions</li>
<li>Offer a starting point for strategy customization</li>
</ul>
</li>
<li>
<p><strong>Parameter Format</strong>:</p>
<ul>
<li>8-bit width (8'd) matching the RSI output range (0-100)</li>
<li>Explicit values for clarity and documentation</li>
<li>Compile-time constants for efficiency</li>
<li>Direct integration with signal generation logic</li>
<li>Clear relationship to standard RSI interpretation</li>
</ul>
</li>
<li>
<p><strong>Customization Options</strong>:</p>
<ul>
<li>
<p><strong>Conservative Settings</strong>:</p>
<ul>
<li>BUY_RSI_THR = 40, SELL_RSI_THR = 60</li>
<li>Generates more frequent signals</li>
<li>Smaller expected price movements</li>
<li>Lower risk per trade</li>
<li>Higher trading frequency</li>
<li>More suitable for range-bound markets</li>
</ul>
</li>
<li>
<p><strong>Aggressive Settings</strong>:</p>
<ul>
<li>BUY_RSI_THR = 20, SELL_RSI_THR = 80</li>
<li>Generates fewer signals</li>
<li>Larger expected price movements</li>
<li>Higher risk per trade</li>
<li>Lower trading frequency</li>
<li>More suitable for volatile markets</li>
</ul>
</li>
<li>
<p><strong>Asymmetric Settings</strong>:</p>
<ul>
<li>Different thresholds for buy and sell signals</li>
<li>Accommodates market asymmetry (e.g., bull vs. bear markets)</li>
<li>Adapts to instrument-specific characteristics</li>
<li>Implements directional bias when appropriate</li>
<li>Supports various market regimes</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Implementation Mechanism</strong>:</p>
<ul>
<li>Parameters override at instantiation time:</li>
</ul>
<pre class="hljs"><code><div>trading_decision #(
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">25</span>),     <span class="hljs-comment">// More aggressive buy threshold</span>
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">75</span>)     <span class="hljs-comment">// More aggressive sell threshold</span>
) decision_module (
    <span class="hljs-comment">// Port connections</span>
);
</div></code></pre>
<ul>
<li>No runtime overhead for configuration</li>
<li>Clear documentation through explicit values</li>
<li>Consistent application throughout the module</li>
<li>Easy modification for different strategies</li>
</ul>
</li>
<li>
<p><strong>Market Adaptation Guidelines</strong>:</p>
<ul>
<li>
<p><strong>Volatile Markets</strong>:</p>
<ul>
<li>More extreme thresholds (20/80)</li>
<li>Reduces false signals during high volatility</li>
<li>Captures larger price movements</li>
</ul>
</li>
<li>
<p><strong>Range-Bound Markets</strong>:</p>
<ul>
<li>Less extreme thresholds (40/60)</li>
<li>Captures more mean-reversion opportunities</li>
<li>Increases trading frequency</li>
</ul>
</li>
<li>
<p><strong>Trending Markets</strong>:</p>
<ul>
<li>Asymmetric thresholds based on trend direction</li>
<li>Bias toward trend continuation</li>
<li>Reduced counter-trend signals</li>
</ul>
</li>
<li>
<p><strong>Specific Instruments</strong>:</p>
<ul>
<li>Custom thresholds based on historical behavior</li>
<li>Adapted to instrument volatility characteristics</li>
<li>Optimized for typical price patterns</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>This parameterized threshold approach provides flexibility while maintaining a clear and efficient implementation, enabling strategy customization without compromising the core decision logic or hardware efficiency.</p>
<h4 id="logic-implementation-details">Logic Implementation Details</h4>
<p>The trading decision module implements a straightforward combinational logic approach with registered outputs to generate trading signals. This design prioritizes simplicity, efficiency, and clear signal generation while maintaining deterministic timing characteristics.</p>
<p>The core logic implementation consists of:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        buy  &lt;= <span class="hljs-number">0</span>;
        sell &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
        sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>This implementation incorporates several important design considerations:</p>
<ol>
<li>
<p><strong>Combinational Logic Structure</strong>:</p>
<ul>
<li>Simple AND operation for each signal condition</li>
<li>Direct comparison between inputs and thresholds</li>
<li>Minimal gate depth for efficiency</li>
<li>Clear relationship between inputs and outputs</li>
<li>Straightforward synthesis to hardware</li>
</ul>
</li>
<li>
<p><strong>Signal Timing Control</strong>:</p>
<ul>
<li>Synchronous evaluation on clock rising edge</li>
<li>Single-cycle latency from input change to output update</li>
<li>Registered outputs for clean signal transitions</li>
<li>Consistent timing regardless of input values</li>
<li>Deterministic behavior for downstream components</li>
</ul>
</li>
<li>
<p><strong>Reset Handling</strong>:</p>
<ul>
<li>Asynchronous reset for immediate signal clearing</li>
<li>Both signals initialized to inactive (0)</li>
<li>Clean startup behavior</li>
<li>Safe default condition</li>
<li>Consistent with system-wide reset strategy</li>
</ul>
</li>
<li>
<p><strong>Bitwidth Management</strong>:</p>
<ul>
<li>Moving average truncation to match price width: <code>moving_avg[15:0]</code></li>
<li>Equal-width comparison between price and MA</li>
<li>Direct comparison between 8-bit RSI and threshold values</li>
<li>Compatibility with signal widths from indicator modules</li>
<li>Efficient implementation without unnecessary extensions</li>
</ul>
</li>
<li>
<p><strong>Signal Characteristics</strong>:</p>
<ul>
<li>Binary outputs (buy/sell active or inactive)</li>
<li>Mutually exclusive signals by design</li>
<li>Persistent until conditions change</li>
<li>Clear encoding of trading actions</li>
<li>Simple interface for downstream systems</li>
</ul>
</li>
<li>
<p><strong>Hardware Implementation Efficiency</strong>:</p>
<ul>
<li>Minimal register usage (two 1-bit registers)</li>
<li>Simple comparators for condition evaluation</li>
<li>Direct input connections without buffering</li>
<li>Clean synchronous design for FPGA implementation</li>
<li>Low resource utilization</li>
</ul>
</li>
<li>
<p><strong>Logic Verification Approach</strong>:</p>
<ul>
<li>Exhaustive testing of all condition combinations</li>
<li>Verification of mutual exclusivity</li>
<li>Reset behavior validation</li>
<li>Timing consistency checking</li>
<li>Edge case coverage</li>
</ul>
</li>
</ol>
<p>The logic implementation follows a deliberate minimalist approach, implementing only the essential functionality while maintaining reliability and clarity. This design choice prioritizes:</p>
<ul>
<li>Deterministic behavior under all conditions</li>
<li>Clear relationship between inputs and outputs</li>
<li>Efficient hardware implementation</li>
<li>Straightforward verification and validation</li>
<li>Maintainable code structure</li>
</ul>
<p>This approach creates a robust trading signal generation mechanism with predictable behavior, clear functionality, and efficient resource utilization.</p>
<h4 id="signal-timing-considerations">Signal Timing Considerations</h4>
<p>The trading decision module incorporates specific timing considerations to ensure that signals are generated with appropriate synchronization, persistence, and clarity. These timing aspects are critical for reliable integration with downstream trading systems and proper market interaction.</p>
<p>Key timing considerations in the signal generation include:</p>
<ol>
<li>
<p><strong>Synchronous Evaluation</strong>:</p>
<ul>
<li>All signal conditions are evaluated on the rising edge of the clock</li>
<li>Input sampling occurs simultaneously for all conditions</li>
<li>Consistent evaluation timing regardless of market conditions</li>
<li>Single-cycle latency from input change to output update</li>
<li>Deterministic behavior for system integration</li>
</ul>
</li>
<li>
<p><strong>Signal Persistence</strong>:</p>
<ul>
<li>Signals remain active as long as the conditions are met</li>
<li>No artificial duration limitation or pulse generation</li>
<li>Signals deactivate immediately when conditions change</li>
<li>Allows downstream systems to determine appropriate action timing</li>
<li>Creates clear entrance and exit points for positions</li>
</ul>
</li>
<li>
<p><strong>Signal Transition Characteristics</strong>:</p>
<ul>
<li>Clean transitions due to registered outputs</li>
<li>No glitches or intermediate states</li>
<li>Single-cycle update for all signal changes</li>
<li>Clear identification of condition changes</li>
<li>Minimal transition latency</li>
</ul>
</li>
<li>
<p><strong>Relationship to Indicator Updates</strong>:</p>
<ul>
<li>Trading signals update on the clock cycle after indicator changes</li>
<li>MA and RSI updates immediately reflect in signal evaluation</li>
<li>Price changes propagate through indicators to signals</li>
<li>Consistent timing relationship throughout the system</li>
<li>Predictable delay from price input to signal generation</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Considerations</strong>:</p>
<ul>
<li>Single clock domain for all evaluation and signal generation</li>
<li>No clock domain crossing issues</li>
<li>Synchronous operation with other system components</li>
<li>Consistent timing across the entire trading system</li>
<li>Simplified timing analysis and verification</li>
</ul>
</li>
<li>
<p><strong>Potential Signal Sequences</strong>:</p>
<p>For a typical price movement crossing the moving average with RSI changes:</p>
<table>
<thead>
<tr>
<th>Cycle</th>
<th>Price vs MA</th>
<th>RSI Condition</th>
<th>Buy Signal</th>
<th>Sell Signal</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Price &lt; MA</td>
<td>RSI = 35</td>
<td>0</td>
<td>0</td>
<td>Neither condition met</td>
</tr>
<tr>
<td>2</td>
<td>Price &lt; MA</td>
<td>RSI = 25</td>
<td>0</td>
<td>0</td>
<td>RSI &lt; 30, but wrong trend</td>
</tr>
<tr>
<td>3</td>
<td>Price &gt; MA</td>
<td>RSI = 25</td>
<td>1</td>
<td>0</td>
<td>Buy conditions met</td>
</tr>
<tr>
<td>4</td>
<td>Price &gt; MA</td>
<td>RSI = 35</td>
<td>0</td>
<td>0</td>
<td>RSI no longer &lt; 30</td>
</tr>
<tr>
<td>5</td>
<td>Price &gt; MA</td>
<td>RSI = 75</td>
<td>0</td>
<td>0</td>
<td>RSI &gt; 70, but wrong trend</td>
</tr>
<tr>
<td>6</td>
<td>Price &lt; MA</td>
<td>RSI = 75</td>
<td>0</td>
<td>1</td>
<td>Sell conditions met</td>
</tr>
<tr>
<td>7</td>
<td>Price &lt; MA</td>
<td>RSI = 65</td>
<td>0</td>
<td>0</td>
<td>RSI no longer &gt; 70</td>
</tr>
</tbody>
</table>
<p>This sequence demonstrates how signals are generated only when both conditions are met and persist only while both conditions remain satisfied.</p>
</li>
<li>
<p><strong>Reset Timing</strong>:</p>
<ul>
<li>Asynchronous reset immediately clears all signals</li>
<li>No delay between reset assertion and signal deactivation</li>
<li>Clean startup state with no active signals</li>
<li>Predictable behavior during system initialization</li>
<li>Safety mechanism for error conditions</li>
</ul>
</li>
<li>
<p><strong>Edge Case Handling</strong>:</p>
<ul>
<li>Threshold equality is handled explicitly ( or )</li>
<li>No timing hysteresis implemented (could be added if needed)</li>
<li>Oscillation prevention relies on threshold separation</li>
<li>Consistent handling of price/MA equality conditions</li>
<li>Deterministic behavior at boundary conditions</li>
</ul>
</li>
</ol>
<p>These timing considerations ensure that the trading signals are generated with appropriate synchronization to system timing, clear activation and deactivation points, and reliable propagation of condition changes, creating a robust foundation for algorithmic trading implementation.</p>
<h4 id="extensibility-features">Extensibility Features</h4>
<p>The trading decision module is designed with extension and customization in mind, providing several features that enable adaptation to different trading strategies, market conditions, and system requirements without major code modifications.</p>
<p>Key extensibility features include:</p>
<ol>
<li>
<p><strong>Parameterized Thresholds</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
<span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
</div></code></pre>
<ul>
<li>Configurable at instantiation time</li>
<li>No code changes required for threshold adjustment</li>
<li>Enable strategy tuning for different market conditions</li>
<li>Support backtesting of multiple threshold combinations</li>
<li>Allow adaptation to instrument-specific characteristics</li>
</ul>
</li>
<li>
<p><strong>Clean Signal Interface</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell
</div></code></pre>
<ul>
<li>Binary outputs for direct integration</li>
<li>Independent signals for flexible downstream handling</li>
<li>Registered outputs for timing predictability</li>
<li>Standard active-high logic for clarity</li>
<li>Minimal interface complexity</li>
</ul>
</li>
<li>
<p><strong>Modular Integration</strong>:</p>
<ul>
<li>Clear input requirements from indicator modules</li>
<li>Simple instantiation in larger systems</li>
<li>Well-defined timing relationships</li>
<li>Standard synchronous design patterns</li>
<li>Minimal dependencies for easy replacement</li>
</ul>
</li>
<li>
<p><strong>Strategy Extension Approaches</strong>:</p>
<ul>
<li>
<p><strong>Additional Indicators</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Extended module with MACD indicator</span>
<span class="hljs-keyword">module</span> trading_decision_ext #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_now,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> macd_positive,  <span class="hljs-comment">// New indicator input</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell
);
    <span class="hljs-comment">// Extended logic incorporating new indicator</span>
    buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR) &amp;&amp; macd_positive;
    sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR) &amp;&amp; !macd_positive;
</div></code></pre>
</li>
<li>
<p><strong>Alternative Strategies</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Trend-following instead of mean-reversion</span>
buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; <span class="hljs-number">50</span>) &amp;&amp; (rsi &lt; <span class="hljs-number">70</span>);
sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; <span class="hljs-number">50</span>) &amp;&amp; (rsi &gt; <span class="hljs-number">30</span>);
</div></code></pre>
</li>
<li>
<p><strong>Multiple Timeframe Support</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Incorporating multiple timeframe confirmation</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg_short,
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg_long,

buy  &lt;= (moving_avg_short &gt; moving_avg_long) &amp;&amp; (rsi &lt; BUY_RSI_THR);
sell &lt;= (moving_avg_short &lt; moving_avg_long) &amp;&amp; (rsi &gt; SELL_RSI_THR);
</div></code></pre>
</li>
<li>
<p><strong>Signal Filtering</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding signal persistence requirements</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] buy_counter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] sell_counter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">wire</span> buy_condition = (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
<span class="hljs-keyword">wire</span> sell_condition = (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);

<span class="hljs-comment">// Only assert signals after conditions met for multiple cycles</span>
buy &lt;= (buy_counter &gt;= <span class="hljs-number">3</span>);
sell &lt;= (sell_counter &gt;= <span class="hljs-number">3</span>);

<span class="hljs-comment">// Update counters</span>
<span class="hljs-keyword">if</span> (buy_condition) buy_counter &lt;= (buy_counter &lt; <span class="hljs-number">15</span>) ? buy_counter + <span class="hljs-number">1</span> : buy_counter;
<span class="hljs-keyword">else</span> buy_counter &lt;= <span class="hljs-number">0</span>;

<span class="hljs-keyword">if</span> (sell_condition) sell_counter &lt;= (sell_counter &lt; <span class="hljs-number">15</span>) ? sell_counter + <span class="hljs-number">1</span> : sell_counter;
<span class="hljs-keyword">else</span> sell_counter &lt;= <span class="hljs-number">0</span>;
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Output Extension Options</strong>:</p>
<ul>
<li>
<p><strong>Signal Strength Indication</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding signal strength output</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] buy_strength,
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] sell_strength,

<span class="hljs-comment">// Calculate signal strength based on condition margin</span>
buy_strength &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) ? (BUY_RSI_THR - rsi) : <span class="hljs-number">8&#x27;d0</span>;
sell_strength &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) ? (rsi - SELL_RSI_THR) : <span class="hljs-number">8&#x27;d0</span>;
</div></code></pre>
</li>
<li>
<p><strong>Position Sizing Signals</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding position size recommendation</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] position_size,  <span class="hljs-comment">// 0-15 scale</span>

<span class="hljs-comment">// Size based on signal strength</span>
position_size &lt;= (buy) ? (BUY_RSI_THR - rsi) / <span class="hljs-number">5</span> :
                (sell) ? (rsi - SELL_RSI_THR) / <span class="hljs-number">5</span> : <span class="hljs-number">4&#x27;d0</span>;
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Integration with Risk Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding risk control inputs</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> trading_allowed,
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> max_positions_reached,

<span class="hljs-comment">// Modified signal generation with risk constraints</span>
buy &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR) &amp;&amp;
       trading_allowed &amp;&amp; !max_positions_reached;
</div></code></pre>
</li>
</ol>
<p>These extensibility features enable the trading decision module to evolve with changing requirements, support multiple trading strategies, and integrate with more complex trading systems while maintaining the core functionality and performance characteristics.</p>
<h2 id="5-hardware-design-approach">5. Hardware Design Approach</h2>
<h3 id="memory-management">Memory Management</h3>
<h4 id="circular-buffer-design">Circular Buffer Design</h4>
<p>The price memory module implements a circular buffer design to efficiently store and manage price history. This approach provides an optimal solution for maintaining a sliding window of price data while minimizing resource utilization and operational complexity.</p>
<p>The circular buffer design is implemented as follows:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,    <span class="hljs-comment">// Depth of the FIFO</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>        <span class="hljs-comment">// Data width</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk, rst, wr_en,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> full,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count
);

    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];  <span class="hljs-comment">// Memory array</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Write pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;         <span class="hljs-comment">// Read pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] item_count = <span class="hljs-number">0</span>;       <span class="hljs-comment">// Item count in FIFO</span>
</div></code></pre>
<p>This circular buffer implementation incorporates several key design elements:</p>
<ol>
<li>
<p><strong>Memory Structure</strong>:</p>
<ul>
<li>Fixed-size array: <code>reg [DW-1:0] mem [0:DEPTH-1];</code></li>
<li>Parameterized depth (default: 14 elements)</li>
<li>Parameterized data width (default: 16 bits)</li>
<li>Sequential memory for efficient FPGA implementation</li>
<li>Linear address space with circular access pattern</li>
</ul>
</li>
<li>
<p><strong>Pointer Management</strong>:</p>
<ul>
<li>Write pointer (<code>write_ptr</code>) indicates the next position to write</li>
<li>Read pointer (<code>read_ptr</code>) indicates the oldest valid data location</li>
<li>5-bit pointer width allows addressing up to 32 elements</li>
<li>Circular behavior through modulo arithmetic: <code>(ptr + 1) % DEPTH</code></li>
<li>Independent pointers enable flexible buffer management</li>
</ul>
</li>
<li>
<p><strong>Capacity Tracking</strong>:</p>
<ul>
<li>Item counter (<code>item_count</code>) tracks the number of valid elements</li>
<li>6-bit width accommodates counts up to 32 (greater than DEPTH)</li>
<li>Full condition: <code>item_count == DEPTH</code></li>
<li>Empty condition (implicit): <code>item_count == 0</code></li>
<li>Count output provides fill level information to other modules</li>
</ul>
</li>
<li>
<p><strong>Operational Modes</strong>:</p>
<ul>
<li>
<p><strong>Filling Phase</strong>:</p>
<ul>
<li>Write pointer advances with each new price</li>
<li>Read pointer remains at initial position</li>
<li>Item count increases until reaching DEPTH</li>
<li>Data accumulates until buffer is full</li>
</ul>
</li>
<li>
<p><strong>Steady State Operation</strong>:</p>
<ul>
<li>Both pointers advance with each new price</li>
<li>Constant distance maintained between pointers</li>
<li>Item count remains equal to DEPTH</li>
<li>Oldest price is overwritten with each new price</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The circular buffer implementation includes logic for both phases:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        write_ptr &lt;= <span class="hljs-number">0</span>;
        read_ptr &lt;= <span class="hljs-number">0</span>;
        item_count &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Filling phase: write new price, increment count</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            item_count &lt;= item_count + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Steady state: overwrite oldest price</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ol start="5">
<li>
<p><strong>Data Access Model</strong>:</p>
<ul>
<li>Write access: Direct indexing with write pointer</li>
<li>Read access: Direct indexing with read pointer</li>
<li>Continuous output: <code>assign oldest_price = mem[read_ptr];</code></li>
<li>Single-cycle access for both read and write operations</li>
<li>Synchronous write, asynchronous read architecture</li>
</ul>
</li>
<li>
<p><strong>Buffer Visualization</strong>:</p>
<p>During the filling phase:</p>
<pre class="hljs"><code><div>Memory:   [ 0 | 1 | 2 | 3 | ... | DEPTH-1 ]
                                 
                             write_ptr
read_ptr  0
item_count increases
</div></code></pre>
<p>During steady state:</p>
<pre class="hljs"><code><div>Memory:   [ 0 | 1 | 2 | ... | DEPTH-1 ]
                           
        read_ptr        write_ptr
item_count = DEPTH
</div></code></pre>
<p>After several updates:</p>
<pre class="hljs"><code><div>Memory:   [ 0 | 1 | 2 | ... | DEPTH-1 ]
                       
                write_ptr read_ptr
item_count = DEPTH
</div></code></pre>
</li>
</ol>
<p>The circular buffer design provides several advantages for the price history application:</p>
<ul>
<li>Efficient memory utilization (fixed size allocation)</li>
<li>Constant-time access to both newest and oldest prices</li>
<li>Automatic overwriting of obsolete data</li>
<li>Simple pointer arithmetic for address calculation</li>
<li>Clear indication of buffer status through count and full flag</li>
</ul>
<h4 id="pointer-management-strategy">Pointer Management Strategy</h4>
<p>The price memory module implements a sophisticated pointer management strategy that maintains proper data sequencing, ensures correct access to both newest and oldest prices, and handles the transition between filling and steady-state operation seamlessly.</p>
<p>The pointer management is implemented through two key registers:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Points to next location to write</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;   <span class="hljs-comment">// Points to oldest valid data</span>
</div></code></pre>
<p>These pointers are manipulated according to specific rules that maintain the circular buffer's integrity:</p>
<ol>
<li>
<p><strong>Initialization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    write_ptr &lt;= <span class="hljs-number">0</span>;
    read_ptr &lt;= <span class="hljs-number">0</span>;
    item_count &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Both pointers reset to zero on system reset</li>
<li>Item count clears to indicate empty buffer</li>
<li>Creates a known starting state for predictable operation</li>
<li>Ensures proper sequencing from system startup</li>
<li>Reestablishes initial conditions after errors</li>
</ul>
</li>
<li>
<p><strong>Write Pointer Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
    mem[write_ptr] &lt;= new_price;
    write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Incremented after each write operation</li>
<li>Wraps around to zero when reaching DEPTH</li>
<li>Modulo operation implements circular behavior</li>
<li>Constantly advances regardless of buffer state</li>
<li>Points to the next location to be written</li>
</ul>
</li>
<li>
<p><strong>Read Pointer Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (wr_en &amp;&amp; item_count == DEPTH) <span class="hljs-keyword">begin</span>
    read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Remains at initial position during filling phase</li>
<li>Starts advancing once buffer is full</li>
<li>Maintains same increment pattern as write pointer</li>
<li>Circular addressing through modulo operation</li>
<li>Always points to the oldest valid data</li>
</ul>
</li>
<li>
<p><strong>Pointer Relationship Invariants</strong>:</p>
<ul>
<li>During filling: <code>write_ptr - read_ptr = item_count</code> (linear addressing)</li>
<li>During steady state: <code>(write_ptr - read_ptr) % DEPTH = 0</code> (full buffer)</li>
<li>Pointers may cross during operation (write_ptr &lt; read_ptr)</li>
<li>Maximum distance between pointers is DEPTH-1</li>
<li>Pointers converge when buffer is empty or full</li>
</ul>
</li>
<li>
<p><strong>Pointer Width Considerations</strong>:</p>
<ul>
<li>5-bit width supports buffer sizes up to 32 elements</li>
<li>Extra bit beyond addressing requirements prevents overflow</li>
<li>Same width for both pointers maintains consistency</li>
<li>Sufficient for parameterized DEPTH up to 32</li>
<li>Efficient implementation on FPGA hardware</li>
</ul>
</li>
<li>
<p><strong>Advanced Pointer Operations</strong>:</p>
<p>The implementation handles several key scenarios:</p>
<ul>
<li>
<p><strong>Buffer Filling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Only increment write pointer, read_ptr stays at 0</span>
    write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
    item_count &lt;= item_count + <span class="hljs-number">1</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
</li>
<li>
<p><strong>Buffer Full (Steady State)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Increment both pointers, maintaining full state</span>
    write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
    read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
</li>
<li>
<p><strong>Pointer Wrapping</strong>:
The modulo operation <code>(ptr + 1) % DEPTH</code> handles wrapping automatically:</p>
<ul>
<li>When <code>ptr == DEPTH-1</code>, the next value becomes 0</li>
<li>Creates seamless circular addressing</li>
<li>Handles arbitrary buffer sizes (parameterized)</li>
<li>Efficient implementation in hardware</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Visualization of Pointer Movement</strong>:</p>
<p>Initial state:</p>
<pre class="hljs"><code><div>Memory: [ 0 | 1 | 2 | 3 | ... | DEPTH-1 ]
          
        read_ptr
        write_ptr
</div></code></pre>
<p>After several writes (filling):</p>
<pre class="hljs"><code><div>Memory: [ A | B | C | D | ... | - ]
                         
       read_ptr      write_ptr
</div></code></pre>
<p>After buffer fills and more writes:</p>
<pre class="hljs"><code><div>Memory: [ I | J | E | F | G | H ]
                         
              read_ptr  write_ptr
</div></code></pre>
<p>After another write (oldest data overwritten):</p>
<pre class="hljs"><code><div>Memory: [ I | J | K | F | G | H ]
                           
                 read_ptr  write_ptr
</div></code></pre>
</li>
</ol>
<p>This pointer management strategy creates a robust circular buffer implementation that efficiently handles both the initial filling phase and continuous operation, providing reliable access to the sliding window of price data required for technical indicator calculations.</p>
<h4 id="memory-access-patterns">Memory Access Patterns</h4>
<p>The price memory module implements specific memory access patterns designed to support efficient calculation of technical indicators. These patterns enable optimal data flow while minimizing access conflicts and ensuring data consistency.</p>
<p>The key memory access patterns include:</p>
<ol>
<li>
<p><strong>Write-Only Access Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
    mem[write_ptr] &lt;= new_price;
    <span class="hljs-comment">// Pointer management...</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Single write port to memory array</li>
<li>Synchronous write operation on clock edge</li>
<li>Controlled by write enable signal</li>
<li>Occurs at location indicated by write pointer</li>
<li>Sequential access pattern following pointer movement</li>
</ul>
</li>
<li>
<p><strong>Read-Only Access Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">assign</span> oldest_price = mem[read_ptr];
</div></code></pre>
<ul>
<li>Continuous read access to oldest price</li>
<li>Asynchronous read operation</li>
<li>No explicit read enable required</li>
<li>Location determined by read pointer</li>
<li>Provides immediate access to oldest data</li>
</ul>
</li>
<li>
<p><strong>Access Timing Relationship</strong>:</p>
<ul>
<li>Writes occur on rising clock edge</li>
<li>Reads available continuously</li>
<li>One-cycle latency between write and read availability</li>
<li>No read-before-write conflicts</li>
<li>Sequential consistency maintained</li>
</ul>
</li>
<li>
<p><strong>Read-After-Write Considerations</strong>:</p>
<ul>
<li>New data available on the clock cycle after writing</li>
<li>Read of just-written data occurs only after pointer update</li>
<li>Circular buffer structure ensures proper aging of data</li>
<li>No explicit forwarding or bypassing required</li>
<li>Natural flow from newest to oldest through buffer aging</li>
</ul>
</li>
<li>
<p><strong>Data Flow Visualization</strong>:</p>
<p>For a buffer of depth 4, the data flow pattern is:</p>
<pre class="hljs"><code><div>Initial state:
mem: [ - | - | - | - ]

After write #1:
mem: [ A | - | - | - ]
     write_ptr  1

After write #2:
mem: [ A | B | - | - ]
     write_ptr  2

After write #3:
mem: [ A | B | C | - ]
     write_ptr  3

After write #4:
mem: [ A | B | C | D ]
     write_ptr  0
     read_ptr  0
     oldest_price = A

After write #5:
mem: [ E | B | C | D ]
     write_ptr  1
     read_ptr  1
     oldest_price = B
</div></code></pre>
<p>This visualization demonstrates how data flows through the buffer, with oldest values continuously replaced by newest values once the buffer is full.</p>
</li>
<li>
<p><strong>Access Pattern for Technical Indicators</strong>:</p>
<ul>
<li>
<p>Moving Average calculation:</p>
<ul>
<li>Access to oldest_price for subtraction from sum</li>
<li>Direct access to new_price for addition to sum</li>
<li>No need to access intermediate values</li>
</ul>
</li>
<li>
<p>RSI calculation:</p>
<ul>
<li>Sequential comparison of consecutive prices</li>
<li>Access to oldest_price for pointer movement</li>
<li>No random access to arbitrary elements</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Access Conflict Avoidance</strong>:</p>
<ul>
<li>No simultaneous read/write to same address
<ul>
<li>Write occurs at write_ptr</li>
<li>Read occurs at read_ptr</li>
<li>Pointers never point to same address during operation</li>
</ul>
</li>
<li>No concurrent modification of same data</li>
<li>Clear separation between read and write operations</li>
<li>Deterministic access pattern for verification</li>
</ul>
</li>
<li>
<p><strong>Memory Interface Optimization</strong>:</p>
<ul>
<li>Single read port (oldest_price) reduces interface complexity</li>
<li>Asynchronous read simplifies timing requirements</li>
<li>Synchronous write aligns with FPGA memory structures</li>
<li>Minimal control signals (only write_enable)</li>
<li>Clean separation between control and data paths</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Considerations</strong>:</p>
<ul>
<li>Implementation maps efficiently to FPGA memory resources</li>
<li>Small buffer sizes can use distributed RAM</li>
<li>Larger sizes can leverage block RAM resources</li>
<li>Single-port memory structure reduces resource requirements</li>
<li>Consistent access pattern improves synthesis results</li>
</ul>
</li>
</ol>
<p>These memory access patterns provide an efficient and deterministic mechanism for maintaining the sliding window of price data required by the technical indicators, ensuring proper data aging, consistent access to both newest and oldest values, and streamlined data flow through the system.</p>
<h4 id="fifo-implementation">FIFO Implementation</h4>
<p>The price memory module implements a First-In-First-Out (FIFO) buffer using a circular buffer approach. This FIFO implementation provides the storage backbone for the technical analysis system, maintaining the historical price data needed for indicator calculations.</p>
<p>The core FIFO functionality is implemented as follows:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,    <span class="hljs-comment">// Depth of the FIFO</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>        <span class="hljs-comment">// Data width</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk, rst, wr_en,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> full,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count
);

    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];  <span class="hljs-comment">// FIFO memory array</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Write pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;         <span class="hljs-comment">// Read pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] item_count = <span class="hljs-number">0</span>;       <span class="hljs-comment">// Item count in FIFO</span>

    <span class="hljs-keyword">assign</span> full = (item_count == DEPTH);   <span class="hljs-comment">// FIFO full flag</span>
    <span class="hljs-keyword">assign</span> count = item_count;             <span class="hljs-comment">// Output current count</span>
    <span class="hljs-keyword">assign</span> oldest_price = mem[read_ptr];   <span class="hljs-comment">// Oldest price is at read pointer</span>
</div></code></pre>
<p>This FIFO design incorporates several important features and considerations:</p>
<ol>
<li>
<p><strong>FIFO Operation Principles</strong>:</p>
<ul>
<li>Sequential data storage: First price in is the first price out</li>
<li>Automatic data aging as buffer fills</li>
<li>Oldest data automatically discarded when full</li>
<li>Fixed depth maintains consistent window size</li>
<li>Continuous operation with new data replacing oldest</li>
</ul>
</li>
<li>
<p><strong>FIFO Control Signals</strong>:</p>
<ul>
<li><code>wr_en</code>: Controls writing of new data to the FIFO</li>
<li><code>full</code>: Indicates FIFO has reached capacity</li>
<li><code>count</code>: Provides current fill level</li>
<li>No explicit read enable (continuous output)</li>
<li>Synchronous write, asynchronous read design</li>
</ul>
</li>
<li>
<p><strong>FIFO Writing Logic</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        write_ptr &lt;= <span class="hljs-number">0</span>;
        read_ptr &lt;= <span class="hljs-number">0</span>;
        item_count &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// If FIFO is not full, write to memory and increment count</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            item_count &lt;= item_count + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// If FIFO is full, overwrite oldest data</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Two distinct operating modes based on fill level</li>
<li>Automatic transition from filling to steady-state</li>
<li>Consistent pointer update logic</li>
<li>Atomic write operation with pointer updates</li>
<li>Clear separation between fill phase and steady-state</li>
</ul>
</li>
<li>
<p><strong>FIFO Reading Method</strong>:</p>
<ul>
<li>Continuous output of oldest value</li>
<li><code>assign oldest_price = mem[read_ptr];</code></li>
<li>No explicit read operation required</li>
<li>Read pointer updates automatically in full state</li>
<li>Asynchronous output for immediate availability</li>
</ul>
</li>
<li>
<p><strong>Special FIFO Characteristics</strong>:</p>
<ul>
<li><strong>Auto-discard</strong>: Automatically overwrites oldest data when full</li>
<li><strong>Fixed Window</strong>: Maintains constant-size sliding window</li>
<li><strong>Dual Mode</strong>: Functions as standard FIFO until full, then as circular buffer</li>
<li><strong>Single Element Reading</strong>: Only exposes oldest element (specialized for MA/RSI)</li>
<li><strong>Status Reporting</strong>: Provides both full flag and count for system coordination</li>
</ul>
</li>
<li>
<p><strong>FIFO State Visualization</strong>:</p>
<p>The FIFO progresses through distinct states during operation:</p>
<ul>
<li>
<p><strong>Empty State</strong>:</p>
<pre class="hljs"><code><div>mem: [ - | - | ... | - ]
read_ptr = write_ptr = 0
item_count = 0
full = 0
</div></code></pre>
</li>
<li>
<p><strong>Partially Filled State</strong>:</p>
<pre class="hljs"><code><div>mem: [ A | B | C | - | ... | - ]
read_ptr = 0
write_ptr = 3
item_count = 3
full = 0
</div></code></pre>
</li>
<li>
<p><strong>Full State</strong>:</p>
<pre class="hljs"><code><div>mem: [ A | B | C | ... | N ]
read_ptr = 0
write_ptr = 0
item_count = DEPTH
full = 1
</div></code></pre>
</li>
<li>
<p><strong>Steady State Operation</strong> (after additional writes):</p>
<pre class="hljs"><code><div>mem: [ O | P | C | ... | N ]
read_ptr = 2
write_ptr = 2
item_count = DEPTH
full = 1
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Overflow/Underflow Handling</strong>:</p>
<ul>
<li>No explicit overflow protection (by design)</li>
<li>Oldest data automatically discarded when full</li>
<li>No read operations when empty (count tracking)</li>
<li>Status signals prevent improper operations</li>
<li>Robust behavior under all operating conditions</li>
</ul>
</li>
</ol>
<p>This specialized FIFO implementation provides the foundation for the technical analysis system, maintaining the historical price window required for indicator calculations while optimizing for the specific access patterns and operational requirements of the system.</p>
<h4 id="overflowunderflow-protection">Overflow/Underflow Protection</h4>
<p>The price memory module incorporates specific mechanisms to handle overflow and underflow conditions, ensuring reliable operation under all circumstances. These protections prevent data corruption, maintain system integrity, and create predictable behavior even in edge cases.</p>
<p>The protection mechanisms include:</p>
<ol>
<li>
<p><strong>Overflow Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Still filling: increment count</span>
    item_count &lt;= item_count + <span class="hljs-number">1</span>;
<span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Already full: maintain count and advance both pointers</span>
    read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Automatic transition to circular buffer mode when full</li>
<li>Oldest data discarded when new data arrives in full state</li>
<li>No counter overflow due to conditional increment</li>
<li>Consistent FIFO size maintained regardless of input rate</li>
<li>Designed behavior rather than error condition</li>
</ul>
</li>
<li>
<p><strong>Underflow Prevention</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">assign</span> oldest_price = mem[read_ptr];  <span class="hljs-comment">// Always output current oldest price</span>
<span class="hljs-keyword">assign</span> full = (item_count == DEPTH);  <span class="hljs-comment">// Only signal full when actually full</span>
</div></code></pre>
<ul>
<li>No explicit read operation that could create underflow</li>
<li>Continuous output of current oldest price</li>
<li>Downstream modules use status signals for validity</li>
<li>System design prevents reading from empty buffer</li>
<li>Clear indication of data availability through count</li>
</ul>
</li>
<li>
<p><strong>Boundary Condition Handling</strong>:</p>
<ul>
<li>
<p><strong>Reset Condition</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    write_ptr &lt;= <span class="hljs-number">0</span>;
    read_ptr &lt;= <span class="hljs-number">0</span>;
    item_count &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Complete initialization to empty state</li>
<li>Known starting condition for predictable behavior</li>
<li>All status flags reflect empty state</li>
<li>Clean system state before operation</li>
<li>Synchronizes FIFO state with system reset</li>
</ul>
</li>
<li>
<p><strong>Write to Full Buffer</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (item_count == DEPTH) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Overwrite the oldest data</span>
    mem[write_ptr] &lt;= new_price;
    write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
    read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Automatically discards oldest data</li>
<li>Maintains constant buffer size</li>
<li>Updates both pointers atomically</li>
<li>No overflow condition generated</li>
<li>Intentional design for sliding window</li>
</ul>
</li>
<li>
<p><strong>Empty Buffer Reading</strong>:</p>
<ul>
<li>No explicit read operation to trigger underflow</li>
<li>Continuous output of current read location</li>
<li>Status signals indicate data validity</li>
<li>System-level coordination prevents invalid use</li>
<li>Implementation avoids error states</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Pointer Protection</strong>:</p>
<ul>
<li>5-bit pointers for addressing up to DEPTH=14 locations</li>
<li>Extra width provides margin against overflow</li>
<li>Modulo operation ensures valid addressing: <code>(ptr + 1) % DEPTH</code></li>
<li>Prevents pointers from exceeding valid range</li>
<li>Hardware-efficient implementation of wrapping</li>
</ul>
</li>
<li>
<p><strong>Counter Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// During filling phase</span>
item_count &lt;= item_count + <span class="hljs-number">1</span>;

<span class="hljs-comment">// During steady state (full)</span>
<span class="hljs-comment">// item_count remains unchanged</span>
</div></code></pre>
<ul>
<li>6-bit counter width accommodates DEPTH=14 plus margin</li>
<li>Conditional increment prevents overflow</li>
<li>No decrement during operation (specialized for application)</li>
<li>Counter saturates at DEPTH value</li>
<li>Provides reliable status information</li>
</ul>
</li>
<li>
<p><strong>Full/Empty Flag Logic</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">assign</span> full = (item_count == DEPTH);
<span class="hljs-comment">// Empty implicitly when item_count == 0</span>
</div></code></pre>
<ul>
<li>Direct comparison for reliable status</li>
<li>No complex derived conditions</li>
<li>Unambiguous state indication</li>
<li>Single-bit flags for simple integration</li>
<li>Immediate status updates with counter changes</li>
</ul>
</li>
<li>
<p><strong>System-Level Protection</strong>:</p>
<ul>
<li><code>compute_enable</code> signal derived from fill level</li>
<li>Calculation modules only activate when sufficient data available</li>
<li>Status monitoring prevents premature processing</li>
<li>Handshaking between modules for coordination</li>
<li>Consistent operation across system boundary</li>
</ul>
</li>
</ol>
<p>These protection mechanisms ensure that the price memory module maintains data integrity and operational reliability under all conditions. The approach treats overflow as a designed behavior rather than an error condition, implementing a circular buffer policy that automatically discards the oldest data when new data arrives in a full buffer. This aligns perfectly with the sliding window requirement of technical analysis indicators, where only the most recent N prices are relevant for calculation.</p>
<h3 id="computational-efficiency">Computational Efficiency</h3>
<h4 id="sliding-window-algorithm-details">Sliding Window Algorithm Details</h4>
<p>The technical analysis system implements an efficient sliding window algorithm for calculating the moving average. This algorithm achieves O(1) computational complexity per update, regardless of window size, making it significantly more efficient than naive approaches.</p>
<p>The sliding window algorithm is implemented in the Moving Average FSM module:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW     = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]  st = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            sum &lt;= <span class="hljs-number">0</span>; moving_avg &lt;= <span class="hljs-number">0</span>; done &lt;= <span class="hljs-number">0</span>; st &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (st)
                <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;
                <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
                    sum &lt;= sum + new_price - oldest_price;
                    moving_avg &lt;= sum / WINDOW;
                    done &lt;= <span class="hljs-number">1</span>;
                    st &lt;= <span class="hljs-number">2</span>;
                <span class="hljs-keyword">end</span>
                <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">0</span>;
                    st &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>The sliding window algorithm operates through the following key steps:</p>
<ol>
<li>
<p><strong>Algorithm Initialization</strong>:</p>
<ul>
<li>When the system starts, the sum register is initialized to zero</li>
<li>As prices fill the buffer, the sum accumulates the initial window values</li>
<li>Once the buffer is full, the sliding window operation begins</li>
<li>The initial sum represents the total of all prices in the window</li>
</ul>
</li>
<li>
<p><strong>Core Sliding Window Operation</strong>:</p>
<pre class="hljs"><code><div>sum &lt;= sum + new_price - oldest_price;
</div></code></pre>
<ul>
<li>When a new price arrives, it is added to the running sum</li>
<li>Simultaneously, the oldest price is subtracted from the sum</li>
<li>This maintains the sum of exactly WINDOW prices</li>
<li>No recalculation of the entire sum is needed</li>
<li>Operation complexity remains constant regardless of window size</li>
</ul>
</li>
<li>
<p><strong>Moving Average Calculation</strong>:</p>
<pre class="hljs"><code><div>moving_avg &lt;= sum / WINDOW;
</div></code></pre>
<ul>
<li>The moving average is calculated by dividing the sum by the window size</li>
<li>Single division operation per update</li>
<li>Results in the arithmetic mean of all prices in the window</li>
<li>Division by constant value (optimization opportunity)</li>
<li>Consistent precision across all calculations</li>
</ul>
</li>
<li>
<p><strong>Computational Complexity Analysis</strong>:</p>
<ul>
<li>
<p><strong>Naive Approach</strong> (not implemented):</p>
<pre class="hljs"><code><div>sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; WINDOW; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
    sum = sum + prices[i];
<span class="hljs-keyword">end</span>
moving_avg = sum / WINDOW;
</div></code></pre>
<ul>
<li>O(n) complexity, where n is the window size</li>
<li>Requires accessing all prices in the window</li>
<li>Recomputes the entire sum for each new price</li>
<li>Resource utilization and latency increase with window size</li>
<li>Inefficient for larger window sizes</li>
</ul>
</li>
<li>
<p><strong>Sliding Window Approach</strong> (implemented):</p>
<pre class="hljs"><code><div>sum = sum + new_price - oldest_price;
moving_avg = sum / WINDOW;
</div></code></pre>
<ul>
<li>O(1) complexity, independent of window size</li>
<li>Constant operation count for any window size</li>
<li>Minimal memory access (just newest and oldest prices)</li>
<li>Consistent performance as window size increases</li>
<li>Efficient for all practical window sizes</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Operation Count Comparison</strong>:</p>
<p>For a window size of 20:</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Additions</th>
<th>Subtractions</th>
<th>Divisions</th>
<th>Memory Accesses</th>
<th>Total Operations</th>
</tr>
</thead>
<tbody>
<tr>
<td>Naive</td>
<td>20</td>
<td>0</td>
<td>1</td>
<td>20</td>
<td>41</td>
</tr>
<tr>
<td>Sliding Window</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>This represents an approximately 8 reduction in operation count, with the advantage growing for larger window sizes.</p>
</li>
<li>
<p><strong>Implementation Considerations</strong>:</p>
<ul>
<li>
<p><strong>Sum Register Width</strong>:</p>
<ul>
<li>64-bit width prevents overflow during accumulation</li>
<li>Supports large price values and window sizes</li>
<li>Provides margin for growth without modification</li>
</ul>
</li>
<li>
<p><strong>Division Operation</strong>:</p>
<ul>
<li>Integer division for simplicity</li>
<li>Optimizable when WINDOW is a power of 2 (shift operation)</li>
<li>Potential for fixed-point implementation for better precision</li>
</ul>
</li>
<li>
<p><strong>Edge Case Handling</strong>:</p>
<ul>
<li>Calculation only begins when buffer is full</li>
<li>Clean reset behavior for sum register</li>
<li>Explicit state machine control</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Performance Benefits</strong>:</p>
<ul>
<li>Constant cycle count per update</li>
<li>Deterministic timing regardless of window size</li>
<li>Minimal resource utilization</li>
<li>Scalable to larger window sizes without performance impact</li>
<li>Simplified verification due to consistent behavior</li>
</ul>
</li>
</ol>
<p>The sliding window algorithm exemplifies the optimization approach used throughout the technical analysis system, focusing on computational efficiency, minimal resource utilization, and deterministic performance characteristics suitable for hardware implementation.</p>
<h4 id="register-sizing-optimization">Register Sizing Optimization</h4>
<p>The technical analysis system implements careful register sizing optimization to balance precision requirements with resource utilization. Each register is sized based on its specific role, range requirements, and performance impact, creating an efficient implementation that maintains calculation accuracy.</p>
<p>Key register sizing decisions include:</p>
<ol>
<li>
<p><strong>Price Data Registers (16-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,     <span class="hljs-comment">// DW=16 by default</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
<span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];      <span class="hljs-comment">// Price storage array</span>
</div></code></pre>
<ul>
<li>16-bit width accommodates typical price values</li>
<li>Sufficient range for most financial instruments</li>
<li>Standardized width across all price-related registers</li>
<li>Parameterized for flexibility (DW parameter)</li>
<li>Efficient FPGA memory utilization</li>
</ul>
<p><strong>Range Analysis</strong>:</p>
<ul>
<li>16-bit unsigned: 0 to 65,535</li>
<li>Sufficient for integer price representation</li>
<li>Covers typical stock and commodity price ranges</li>
<li>Could represent fixed-point values with scaling</li>
</ul>
</li>
<li>
<p><strong>Moving Average Sum Register (64-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Accumulator for MA calculation</span>
</div></code></pre>
<ul>
<li>Extended width prevents overflow during accumulation</li>
<li>Accommodates sum of multiple price values</li>
<li>Provides substantial margin beyond requirements</li>
<li>Eliminates need for overflow detection/handling</li>
<li>Simplifies implementation at minimal resource cost</li>
</ul>
<p><strong>Theoretical Requirements</strong>:</p>
<ul>
<li>For 16-bit prices and window size of 20:
<ul>
<li>Maximum possible sum: 20 * (2^16 - 1)  1.3 million</li>
<li>Required bits: log2(1.3 million)  21 bits</li>
</ul>
</li>
<li>64-bit implementation provides 43 bits of margin</li>
<li>Allows for future expansion of price width or window size</li>
</ul>
</li>
<li>
<p><strong>Moving Average Output Register (32-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,  <span class="hljs-comment">// Calculated moving average</span>
</div></code></pre>
<ul>
<li>32-bit width accommodates division results</li>
<li>Maintains precision after integer division</li>
<li>Standard data bus width for efficient integration</li>
<li>Sufficient range for all possible average values</li>
<li>Provides margin for fixed-point implementation</li>
</ul>
<p><strong>Precision Considerations</strong>:</p>
<ul>
<li>Result of division cannot exceed maximum price (16 bits)</li>
<li>Additional width accommodates future enhancements</li>
<li>Standardized interface width for system integration</li>
<li>Aligned with common processor data width</li>
</ul>
</li>
<li>
<p><strong>RSI Accumulators (32-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] gain_sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// Accumulator for gains</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] loss_sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// Accumulator for losses</span>
</div></code></pre>
<ul>
<li>32-bit width for gain and loss accumulators</li>
<li>Accommodates accumulation of price differences</li>
<li>Prevents overflow during extended operation</li>
<li>Balanced resource utilization for precision requirements</li>
<li>Consistent width for related registers</li>
</ul>
<p><strong>Range Requirements</strong>:</p>
<ul>
<li>Maximum single gain/loss = maximum price  65,535</li>
<li>For 14-period RSI with all gains/losses:
<ul>
<li>Maximum accumulated value: 14 * 65,535  0.92 million</li>
<li>Required bits: log2(0.92 million)  20 bits</li>
</ul>
</li>
<li>32-bit implementation provides 12 bits of margin</li>
</ul>
</li>
<li>
<p><strong>RSI Output Register (8-bit)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,  <span class="hljs-comment">// RSI value (0-100)</span>
</div></code></pre>
<ul>
<li>8-bit width perfectly matches RSI range (0-100)</li>
<li>No wasted bits or unnecessary precision</li>
<li>Efficient resource utilization</li>
<li>Clear relationship to RSI definition</li>
<li>Standard representation for technical indicators</li>
</ul>
<p><strong>Precision Analysis</strong>:</p>
<ul>
<li>Maximum RSI value is 100, requiring 7 bits</li>
<li>8-bit implementation allows for future range extension</li>
<li>Integer precision sufficient for trading decisions</li>
<li>Consistent with traditional RSI interpretation</li>
</ul>
</li>
<li>
<p><strong>State Registers (Minimal Width)</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] st = <span class="hljs-number">0</span>;     <span class="hljs-comment">// MA FSM state (3 states)</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;  <span class="hljs-comment">// RSI FSM state (6 states)</span>
</div></code></pre>
<ul>
<li>Minimal bit width to encode required states</li>
<li>2 bits for 3-state MA FSM (states 0-2)</li>
<li>3 bits for 6-state RSI FSM (states 0-5)</li>
<li>Efficient encoding for hardware implementation</li>
<li>Clear relationship between register and state count</li>
</ul>
</li>
<li>
<p><strong>Counter Registers</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] item_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// FIFO counter (0 to DEPTH)</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] sample_cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// RSI sample counter</span>
</div></code></pre>
<ul>
<li>Width sized to accommodate maximum count plus margin</li>
<li>6 bits for item_count (maximum value = DEPTH = 14)</li>
<li>5 bits for sample_cnt (maximum value = 19)</li>
<li>Prevention of counter overflow</li>
<li>Efficient implementation of counting logic</li>
</ul>
</li>
<li>
<p><strong>Pointer Registers</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;  <span class="hljs-comment">// FIFO write pointer</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;   <span class="hljs-comment">// FIFO read pointer</span>
</div></code></pre>
<ul>
<li>5-bit width allows addressing up to 32 locations</li>
<li>Sufficient for buffer depth of 14/20</li>
<li>Consistent width for related pointers</li>
<li>Efficient implementation of circular addressing</li>
<li>Prevents address overflow during wrapping</li>
</ul>
</li>
</ol>
<p>These register sizing optimizations collectively create an efficient implementation that balances precision requirements with resource utilization, ensuring accurate calculations while minimizing FPGA resource consumption and maintaining clear relationships between register widths and functional requirements.</p>
<h4 id="division-implementation-strategies">Division Implementation Strategies</h4>
<p>The technical analysis system implements division operations for both the moving average and RSI calculations. The division implementation strategy balances accuracy, resource utilization, and performance considerations while maintaining deterministic behavior.</p>
<p>The core division operations in the system include:</p>
<ol>
<li>
<p><strong>Moving Average Division</strong>:</p>
<pre class="hljs"><code><div>moving_avg &lt;= sum / WINDOW;  <span class="hljs-comment">// WINDOW = 20 by default</span>
</div></code></pre>
<ul>
<li>Divides the accumulated sum by the window size</li>
<li>Constant divisor (WINDOW parameter)</li>
<li>Single division operation per calculation</li>
<li>Integer division with truncation</li>
<li>Direct implementation in Verilog</li>
</ul>
</li>
<li>
<p><strong>RSI Division</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> ((gain_sum + loss_sum) &gt; <span class="hljs-number">0</span>)
    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
<span class="hljs-keyword">else</span>
    rsi &lt;= <span class="hljs-number">0</span>;
</div></code></pre>
<ul>
<li>More complex with variable divisor (gain_sum + loss_sum)</li>
<li>Pre-scaling by 100 for percentage calculation</li>
<li>Division protection for zero denominator</li>
<li>Integer division with truncation</li>
<li>Result constrained to 0-100 range</li>
</ul>
</li>
</ol>
<p>The implementation includes several strategies and considerations:</p>
<ol>
<li>
<p><strong>Integer Division Characteristics</strong>:</p>
<ul>
<li>Truncates fractional results (rounds toward zero)</li>
<li>Limited precision for non-integer results</li>
<li>Efficient implementation in hardware</li>
<li>Predictable behavior for all inputs</li>
<li>Sufficient for technical analysis applications</li>
</ul>
</li>
<li>
<p><strong>Synthesis Optimization Options</strong>:</p>
<ul>
<li>For constant divisors (like WINDOW), synthesis tools can optimize:
<ul>
<li>Division by powers of 2 becomes shift operations</li>
<li>Division by other constants becomes multiply-shift combinations</li>
<li>Specialized division circuits for specific values</li>
<li>Resource-efficient implementations</li>
<li>Reduced latency compared to general division</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Division by Powers of 2</strong>:
When WINDOW is a power of 2 (e.g., 16, 32), the division can be implemented as:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// For WINDOW = 16 (2^4)</span>
moving_avg &lt;= sum &gt;&gt; <span class="hljs-number">4</span>;  <span class="hljs-comment">// Right shift by 4 bits</span>
</div></code></pre>
<ul>
<li>Single shift operation</li>
<li>Minimal resource utilization</li>
<li>Single-cycle execution</li>
<li>Exact binary division</li>
<li>Optimal performance</li>
</ul>
</li>
<li>
<p><strong>Division by Non-Power-of-2 Constants</strong>:
For values like WINDOW = 20, optimized implementations include:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Method 1: Multiply-shift approximation</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] scaled_dividend = sum * <span class="hljs-number">32&#x27;d3355443</span>;  <span class="hljs-comment">// Magic number: 2^26 / 20</span>
moving_avg &lt;= scaled_dividend &gt;&gt; <span class="hljs-number">26</span>;

<span class="hljs-comment">// Method 2: Reciprocal multiplication</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] reciprocal = <span class="hljs-number">32&#x27;h0_0083126</span>;  <span class="hljs-comment">// Fixed-point 1/20 with 24 fraction bits</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] product = sum * reciprocal;
moving_avg &lt;= product &gt;&gt; <span class="hljs-number">24</span>;
</div></code></pre>
<ul>
<li>Replaces division with multiplication and shift</li>
<li>Typically more efficient in FPGA hardware</li>
<li>May introduce small calculation errors</li>
<li>Often synthesized automatically by tools</li>
<li>Balances accuracy and resource utilization</li>
</ul>
</li>
<li>
<p><strong>Variable Divisor Handling</strong> (for RSI):</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Standard approach</span>
rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);

<span class="hljs-comment">// Alternative: Scaled integer approximation</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] total = gain_sum + loss_sum;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] scaled_gain = (gain_sum &lt;&lt; <span class="hljs-number">7</span>);  <span class="hljs-comment">// Scale by 128</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ratio = scaled_gain / total;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] scaled_rsi = (ratio * <span class="hljs-number">100</span>) &gt;&gt; <span class="hljs-number">7</span>;
rsi &lt;= scaled_rsi &gt; <span class="hljs-number">100</span> ? <span class="hljs-number">100</span> : scaled_rsi;
</div></code></pre>
<ul>
<li>Multiple approaches depending on precision needs</li>
<li>Tradeoff between accuracy and resource utilization</li>
<li>Scaling improves precision for integer division</li>
<li>Potential for FPGA-specific optimizations</li>
<li>Flexibility based on application requirements</li>
</ul>
</li>
<li>
<p><strong>FPGA-Specific Division Resources</strong>:</p>
<ul>
<li>Modern FPGAs offer several implementation options:
<ul>
<li>LUT-based division for small operands</li>
<li>DSP block utilization for multiplication in approximation methods</li>
<li>Dedicated division IP cores for complex requirements</li>
<li>Pipelined implementations for higher throughput</li>
<li>Latency vs. resource tradeoffs</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Implementation Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Division Strategy</th>
<th>Latency</th>
<th>Resource Usage</th>
<th>Accuracy</th>
<th>Scalability</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct Integer</td>
<td>High</td>
<td>High</td>
<td>Limited</td>
<td>Good</td>
</tr>
<tr>
<td>Power-of-2 Shift</td>
<td>Low</td>
<td>Minimal</td>
<td>Exact</td>
<td>Excellent</td>
</tr>
<tr>
<td>Multiply-Shift</td>
<td>Medium</td>
<td>Medium</td>
<td>Approx.</td>
<td>Good</td>
</tr>
<tr>
<td>Reciprocal Mult.</td>
<td>Medium</td>
<td>Medium</td>
<td>Approx.</td>
<td>Good</td>
</tr>
<tr>
<td>IP Core</td>
<td>Variable</td>
<td>High</td>
<td>High</td>
<td>Excellent</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Current Implementation Approach</strong>:</p>
<ul>
<li>Straightforward integer division in Verilog</li>
<li>Relies on synthesis tool optimization</li>
<li>Acceptable precision for technical indicators</li>
<li>Deterministic behavior for all inputs</li>
<li>Balances implementation complexity and performance</li>
</ul>
</li>
</ol>
<p>These division implementation strategies provide several options for balancing accuracy, resource utilization, and performance based on specific application requirements. The current implementation uses direct integer division with synthesis optimizations, which provides sufficient accuracy for technical analysis applications while maintaining implementation simplicity.</p>
<h4 id="fixed-point-vs-integer-arithmetic">Fixed Point vs Integer Arithmetic</h4>
<p>The technical analysis system primarily uses integer arithmetic for calculations, but the design considerations and tradeoffs between fixed-point and integer arithmetic were carefully evaluated during development.</p>
<ol>
<li>
<p><strong>Current Integer Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average calculation</span>
moving_avg &lt;= sum / WINDOW;

<span class="hljs-comment">// RSI calculation</span>
rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
</div></code></pre>
<ul>
<li>Pure integer arithmetic with truncation</li>
<li>No decimal precision in calculations</li>
<li>Simplified implementation and verification</li>
<li>Reduced resource requirements</li>
<li>Sufficient for many trading applications</li>
</ul>
</li>
<li>
<p><strong>Fixed-Point Alternative</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Example 16.16 fixed-point implementation (16 integer bits, 16 fractional)</span>

<span class="hljs-comment">// Moving Average calculation</span>
moving_avg &lt;= (sum &lt;&lt; <span class="hljs-number">16</span>) / WINDOW;  <span class="hljs-comment">// Scale up before division</span>

<span class="hljs-comment">// RSI calculation with 8.24 format</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] scaled_gain = gain_sum &lt;&lt; <span class="hljs-number">24</span>;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] total = gain_sum + loss_sum;
rsi &lt;= ((scaled_gain / total) * <span class="hljs-number">100</span>) &gt;&gt; <span class="hljs-number">24</span>;
</div></code></pre>
<ul>
<li>Maintains fractional precision through scaling</li>
<li>More accurate representation of decimal values</li>
<li>Requires careful scaling management</li>
<li>Increased implementation complexity</li>
<li>Additional resource requirements for wider datapaths</li>
</ul>
</li>
<li>
<p><strong>Implementation Considerations</strong>:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Integer Arithmetic</th>
<th>Fixed-Point Arithmetic</th>
</tr>
</thead>
<tbody>
<tr>
<td>Precision</td>
<td>Limited to whole numbers</td>
<td>Configurable decimal precision</td>
</tr>
<tr>
<td>Resource Usage</td>
<td>Lower</td>
<td>Higher (wider datapaths)</td>
</tr>
<tr>
<td>Implementation</td>
<td>Simpler</td>
<td>More complex</td>
</tr>
<tr>
<td>Overflow Risk</td>
<td>Lower (narrower values)</td>
<td>Higher (scaling operations)</td>
</tr>
<tr>
<td>Rounding Control</td>
<td>Limited (truncation)</td>
<td>Configurable rounding modes</td>
</tr>
<tr>
<td>Error Accumulation</td>
<td>Higher for repeated ops</td>
<td>Lower with sufficient precision</td>
</tr>
<tr>
<td>FPGA Mapping</td>
<td>Efficient</td>
<td>Requires careful optimization</td>
</tr>
<tr>
<td>Verification</td>
<td>Straightforward</td>
<td>More complex test scenarios</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Application-Specific Considerations</strong>:</p>
<ul>
<li>
<p><strong>Price Representation</strong>:</p>
<ul>
<li>Integer: Suitable for whole-number prices (stocks, commodities)</li>
<li>Fixed-point: Better for forex or fractional price instruments</li>
</ul>
</li>
<li>
<p><strong>Indicator Precision Requirements</strong>:</p>
<ul>
<li>Moving Average: Integer often sufficient</li>
<li>RSI: Near range boundaries (0-30, 70-100), added precision may help</li>
<li>More complex indicators: May benefit from fixed-point</li>
</ul>
</li>
<li>
<p><strong>Signal Generation Thresholds</strong>:</p>
<ul>
<li>Binary decisions (buy/sell) often work well with integer</li>
<li>Fine-grained position sizing might benefit from fixed-point</li>
<li>Strategy sensitivity analysis may require higher precision</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Migration Path to Fixed-Point</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Parameterized fixed-point definition</span>
<span class="hljs-keyword">parameter</span> FRAC_BITS = <span class="hljs-number">16</span>;

<span class="hljs-comment">// Moving Average with configurable precision</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] scaled_sum = sum &lt;&lt; FRAC_BITS;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] scaled_window = WINDOW &lt;&lt; FRAC_BITS;
moving_avg &lt;= scaled_sum / scaled_window;
</div></code></pre>
<ul>
<li>Gradual transition possible through parameterization</li>
<li>Configurable precision based on application needs</li>
<li>Maintain compatibility with existing modules</li>
<li>Selective application to critical calculations</li>
<li>Performance impact can be isolated and managed</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Impact</strong>:</p>
<ul>
<li>Register width increases (1.5-2 typical)</li>
<li>More complex arithmetic operations</li>
<li>Potential DSP usage for multiplication</li>
<li>Additional logic for scaling and rounding</li>
<li>Synthesis optimizations may mitigate some impacts</li>
</ul>
</li>
<li>
<p><strong>Current Decision Rationale</strong>:</p>
<ul>
<li>
<p>Integer arithmetic selected for:</p>
<ul>
<li>Implementation simplicity</li>
<li>Reduced resource requirements</li>
<li>Sufficient precision for implemented indicators</li>
<li>Clear behavior and verification</li>
<li>Compatibility with price representation</li>
</ul>
</li>
<li>
<p>Design allows future migration to fixed-point when:</p>
<ul>
<li>More sophisticated indicators are added</li>
<li>Higher precision requirements emerge</li>
<li>Additional resources become available</li>
<li>Specific trading strategies require it</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The current integer arithmetic implementation provides a solid foundation with appropriate precision for the implemented technical indicators, while maintaining clear design, efficient resource utilization, and straightforward verification. The system architecture supports future migration to fixed-point arithmetic when required for specific applications or enhanced precision.</p>
<h4 id="computation-reuse-techniques">Computation Reuse Techniques</h4>
<p>The technical analysis system implements several computation reuse techniques to enhance efficiency, minimize redundant calculations, and reduce resource utilization. These techniques optimize the implementation while maintaining calculation accuracy.</p>
<p>Key computation reuse approaches include:</p>
<ol>
<li>
<p><strong>Running Sum Maintenance</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average calculation</span>
sum &lt;= sum + new_price - oldest_price;
</div></code></pre>
<ul>
<li>Maintains a running sum instead of recalculating</li>
<li>Reuses previous sum value for efficiency</li>
<li>Requires only two operations per update</li>
<li>Constant complexity regardless of window size</li>
<li>Enables O(1) moving average calculation</li>
</ul>
</li>
<li>
<p><strong>Shared Memory Architecture</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Price Memory module used by both indicators</span>
price_memory mem14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.wr_en</span>(new_price),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.full</span>(mem_full),
    <span class="hljs-variable">.count</span>(count)
);
</div></code></pre>
<ul>
<li>Single price history buffer shared by multiple indicators</li>
<li>Eliminates redundant storage of identical data</li>
<li>Consistent price history across calculations</li>
<li>Reduced memory resource requirements</li>
<li>Simplified data management</li>
</ul>
</li>
<li>
<p><strong>Common Input Processing</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Both indicators triggered by same condition</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

<span class="hljs-comment">// Moving Average FSM</span>
moving_average_fsm ma14 (
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);

<span class="hljs-comment">// RSI module</span>
rsi_inc rsi14 (
    <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Single trigger condition for multiple operations</li>
<li>Shared control signals reduce logic duplication</li>
<li>Synchronized calculation timing</li>
<li>Consistent behavior across modules</li>
<li>Reduced control logic complexity</li>
</ul>
</li>
<li>
<p><strong>Direct Data Routing</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Direct routing of price data to modules</span>
<span class="hljs-variable">.new_price</span>(price_in),
<span class="hljs-variable">.oldest_price</span>(oldest_price),
</div></code></pre>
<ul>
<li>Current price passes directly to all modules</li>
<li>Avoids redundant buffering or storage</li>
<li>Minimizes data path latency</li>
<li>Reduces register usage</li>
<li>Maintains data consistency across modules</li>
</ul>
</li>
<li>
<p><strong>Efficient Gain/Loss Calculation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// RSI calculation optimized branch logic</span>
<span class="hljs-keyword">if</span> (price_out &gt; prev_price)
    gain_sum &lt;= gain_sum + (price_out - prev_price);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_out &lt; prev_price)
    loss_sum &lt;= loss_sum + (prev_price - price_out);
</div></code></pre>
<ul>
<li>Mutually exclusive calculation paths</li>
<li>Only one accumulator updated per comparison</li>
<li>Direct calculation of absolute difference</li>
<li>No redundant calculations or storage</li>
<li>Simplified data flow through calculation</li>
</ul>
</li>
<li>
<p><strong>Temporal Computation Reuse</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Reuse of calculation results across cycles</span>
prev_price &lt;= price_out;  <span class="hljs-comment">// Store for next cycle</span>
</div></code></pre>
<ul>
<li>Values calculated once and stored for future use</li>
<li>Avoids recalculation of unchanged values</li>
<li>Enables incremental processing approach</li>
<li>Maintains calculation state efficiently</li>
<li>Supports sliding window algorithm</li>
</ul>
</li>
<li>
<p><strong>Parallel Indicator Calculation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Simultaneous calculation of multiple indicators</span>
moving_average_fsm ma14 (...);
rsi_inc rsi14 (...);
</div></code></pre>
<ul>
<li>Concurrent processing of different indicators</li>
<li>Shared input data from common memory</li>
<li>Independent calculation paths</li>
<li>Maximizes computational throughput</li>
<li>Efficient resource utilization</li>
</ul>
</li>
<li>
<p><strong>Indicator-Specific Optimizations</strong>:</p>
<ul>
<li>
<p><strong>Moving Average</strong>:</p>
<ul>
<li>Efficient sliding window algorithm</li>
<li>Minimal processing per price update</li>
<li>Sum maintenance optimization</li>
</ul>
</li>
<li>
<p><strong>RSI</strong>:</p>
<ul>
<li>Incremental gain/loss accumulation</li>
<li>Direct comparison with previous values</li>
<li>Selective accumulator updates</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>These computation reuse techniques collectively enhance the efficiency of the technical analysis system, minimizing redundant calculations, optimizing memory usage, and creating streamlined data flows. The approach focuses on maintaining calculation state where beneficial, sharing common data between modules, and implementing algorithms that minimize computational complexity for each price update.</p>
<h3 id="control-logic">Control Logic</h3>
<h4 id="fsm-implementation-principles">FSM Implementation Principles</h4>
<p>The technical analysis system implements Finite State Machines (FSMs) to control the sequence of operations for indicator calculations. These FSMs follow specific design principles that enhance clarity, reliability, and efficiency in hardware implementation.</p>
<p>Key FSM implementation principles include:</p>
<ol>
<li>
<p><strong>Clear State Definition</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average FSM states</span>
<span class="hljs-comment">// State 0: Idle - Wait for start signal</span>
<span class="hljs-comment">// State 1: Calculate - Update sum and compute average</span>
<span class="hljs-comment">// State 2: Done - Signal completion and return to idle</span>

<span class="hljs-comment">// RSI FSM states</span>
<span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">3&#x27;b000</span>,
           FILL_FIFO = <span class="hljs-number">3&#x27;b001</span>,
           READ_INIT = <span class="hljs-number">3&#x27;b010</span>,
           READ_WAIT = <span class="hljs-number">3&#x27;b011</span>,
           COMPARE   = <span class="hljs-number">3&#x27;b100</span>,
           DONE      = <span class="hljs-number">3&#x27;b101</span>;
</div></code></pre>
<ul>
<li>Explicit state enumeration with descriptive comments</li>
<li>State constants with meaningful names (when using parameters)</li>
<li>Minimal states for required functionality</li>
<li>Clear relationship between states and operations</li>
<li>Logical progression through calculation sequence</li>
</ul>
</li>
<li>
<p><strong>Single Process State Machine</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
        state &lt;= IDLE;
        <span class="hljs-comment">// Register initialization</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Default assignments</span>
        
        <span class="hljs-keyword">case</span> (state)
            <span class="hljs-comment">// State-specific logic</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Combined next-state logic and output logic</li>
<li>Single always block for entire state machine</li>
<li>Sequential design with synchronous state transitions</li>
<li>Clear reset behavior</li>
<li>Simplified synthesis to hardware</li>
</ul>
</li>
<li>
<p><strong>Explicit State Transitions</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">case</span> (state)
    IDLE: <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (start) state &lt;= FILL_FIFO;
    <span class="hljs-keyword">end</span>
    
    FILL_FIFO: <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (fifo_full) state &lt;= READ_INIT;
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Additional states...</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Clear conditions for each state transition</li>
<li>Explicit assignments to next state</li>
<li>Deterministic transition behavior</li>
<li>Predictable execution flow</li>
<li>Simple verification of state sequences</li>
</ul>
</li>
<li>
<p><strong>Default Signal Assignments</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Default signal assignments</span>
done &lt;= <span class="hljs-number">0</span>;
fifo_wr_en &lt;= <span class="hljs-number">0</span>;
fifo_rd_en &lt;= <span class="hljs-number">0</span>;

<span class="hljs-keyword">case</span> (state)
    <span class="hljs-comment">// Override defaults in specific states</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Default values assigned before case statement</li>
<li>Explicit overrides in specific states</li>
<li>Prevents latches from unassigned signals</li>
<li>Clear signal behavior in all states</li>
<li>Robust synthesis to hardware</li>
</ul>
</li>
<li>
<p><strong>Registered Outputs</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// In the DONE state</span>
done &lt;= <span class="hljs-number">1</span>;
rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
</div></code></pre>
<ul>
<li>All outputs registered (sequential logic)</li>
<li>Clean timing on output signals</li>
<li>No combinational outputs from state machine</li>
<li>Consistent output behavior</li>
<li>Simplified timing analysis</li>
</ul>
</li>
<li>
<p><strong>Reset Initialization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    state &lt;= IDLE;      <span class="hljs-comment">// Reset to idle state</span>
    sum &lt;= <span class="hljs-number">0</span>;           <span class="hljs-comment">// Clear calculation registers</span>
    moving_avg &lt;= <span class="hljs-number">0</span>;    <span class="hljs-comment">// Clear outputs</span>
    done &lt;= <span class="hljs-number">0</span>;          <span class="hljs-comment">// Clear control signals</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Complete initialization of all registers</li>
<li>Known starting state for predictable behavior</li>
<li>Default inactive values for control signals</li>
<li>Clear data registers to prevent invalid calculations</li>
<li>Robust startup behavior</li>
</ul>
</li>
<li>
<p><strong>One-Hot Encoded Flag Signals</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Only one flag active at a time</span>
done &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">// Default inactive</span>

<span class="hljs-keyword">case</span> (state)
    DONE: <span class="hljs-keyword">begin</span>
        done &lt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// Only active in DONE state</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Control flags have single activation state</li>
<li>Clear flag behavior across all states</li>
<li>Mutually exclusive signal activation</li>
<li>Simplified downstream logic</li>
<li>Deterministic behavior for system integration</li>
</ul>
</li>
<li>
<p><strong>State Transition Diagrams</strong>:</p>
<p>Moving Average FSM:</p>
<pre class="hljs"><code><div>        start        auto    
      IDLE    CALCULATE  DONE 
     (st=0)                 (st=1)               (st=2)
                             
                                                       
         
                               auto
</div></code></pre>
<p>RSI FSM (simplified):</p>
<pre class="hljs"><code><div>                  
                       
      IDLE 
                               
                          
                        
  FILL_FIFO                      
                        
                                 
               
  READ_INIT DONE 
        
       
  
  COMPARE 
  
      
 
 READ_WAIT
 
</div></code></pre>
<ul>
<li>Visual representation of state relationships</li>
<li>Clear transition conditions</li>
<li>Cyclical and linear paths identified</li>
<li>Simplified understanding of complex FSMs</li>
<li>Aid for verification and debugging</li>
</ul>
</li>
</ol>
<p>These FSM implementation principles create robust, deterministic state machines that efficiently control the calculation sequence for technical indicators. The approach emphasizes clarity, predictability, and efficient hardware implementation, resulting in reliable control logic that orchestrates the data flow and computational elements of the system.</p>
<h4 id="state-encoding-techniques">State Encoding Techniques</h4>
<p>The technical analysis system employs specific state encoding techniques for the Finite State Machines (FSMs) that control indicator calculations. These encoding approaches balance clarity, hardware efficiency, and reliable operation.</p>
<p>Key state encoding techniques include:</p>
<ol>
<li>
<p><strong>Binary Encoding for Moving Average FSM</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] st = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 2-bit state register for 3 states</span>

<span class="hljs-comment">// States implicitly defined:</span>
<span class="hljs-comment">// st = 0: IDLE</span>
<span class="hljs-comment">// st = 1: CALCULATE</span>
<span class="hljs-comment">// st = 2: DONE</span>
</div></code></pre>
<ul>
<li>2-bit encoding for 3 states (values 0-2)</li>
<li>Natural binary counting sequence</li>
<li>Minimal bits for required states</li>
<li>Simple incremental transitions</li>
<li>Efficient encoding for small state machines</li>
</ul>
</li>
<li>
<p><strong>Explicit Constants for RSI FSM</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">3&#x27;b000</span>,
           FILL_FIFO = <span class="hljs-number">3&#x27;b001</span>,
           READ_INIT = <span class="hljs-number">3&#x27;b010</span>,
           READ_WAIT = <span class="hljs-number">3&#x27;b011</span>,
           COMPARE   = <span class="hljs-number">3&#x27;b100</span>,
           DONE      = <span class="hljs-number">3&#x27;b101</span>;

<span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = IDLE;  <span class="hljs-comment">// 3-bit state register</span>
</div></code></pre>
<ul>
<li>Named constants for each state</li>
<li>3-bit encoding for 6 states</li>
<li>Binary values chosen for clarity</li>
<li>Explicit state values for documentation</li>
<li>Self-documenting code with named states</li>
</ul>
</li>
<li>
<p><strong>Sequential Value Assignment</strong>:</p>
<ul>
<li>
<p>Moving Average FSM:</p>
<ul>
<li>States follow simple counting sequence: 0, 1, 2</li>
<li>Linear progression through states</li>
<li>Natural relationship between state order and value</li>
</ul>
</li>
<li>
<p>RSI FSM:</p>
<ul>
<li>State values assigned in logical groups:
<ul>
<li>Initial states: 000 (IDLE), 001 (FILL_FIFO)</li>
<li>Reading states: 010 (READ_INIT), 011 (READ_WAIT)</li>
<li>Processing states: 100 (COMPARE), 101 (DONE)</li>
</ul>
</li>
<li>Related states have related binary patterns</li>
<li>Simplified next-state logic</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Encoding Efficiency Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Encoding Technique</th>
<th>Bits Required</th>
<th>States Supported</th>
<th>Hardware Efficiency</th>
<th>Coding Clarity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binary</td>
<td>log2(n)</td>
<td>2^b</td>
<td>High</td>
<td>Moderate</td>
</tr>
<tr>
<td>One-Hot</td>
<td>n</td>
<td>n</td>
<td>Low</td>
<td>High</td>
</tr>
<tr>
<td>Gray Code</td>
<td>log2(n)</td>
<td>2^b</td>
<td>Moderate</td>
<td>Low</td>
</tr>
<tr>
<td>Current Binary</td>
<td>2-3 bits</td>
<td>3-6 states</td>
<td>High</td>
<td>High</td>
</tr>
</tbody>
</table>
<p>The current implementation uses binary encoding, providing an optimal balance of register size and clarity for the relatively small state machines in the system.</p>
</li>
<li>
<p><strong>State Register Width Considerations</strong>:</p>
<ul>
<li>
<p>Moving Average FSM: 2-bit register for 3 states</p>
<ul>
<li>Minimal width for required states</li>
<li>One unused state value (3)</li>
<li>No impact on hardware efficiency</li>
</ul>
</li>
<li>
<p>RSI FSM: 3-bit register for 6 states</p>
<ul>
<li>Accommodates all required states</li>
<li>Two unused state values (6, 7)</li>
<li>Minimal resource overhead</li>
<li>Potential for future extension</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Alternative Encoding Options</strong>:</p>
<ul>
<li>
<p><strong>One-Hot Encoding Option</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// For RSI FSM with 6 states</span>
<span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">6&#x27;b000001</span>,
           FILL_FIFO = <span class="hljs-number">6&#x27;b000010</span>,
           READ_INIT = <span class="hljs-number">6&#x27;b000100</span>,
           READ_WAIT = <span class="hljs-number">6&#x27;b001000</span>,
           COMPARE   = <span class="hljs-number">6&#x27;b010000</span>,
           DONE      = <span class="hljs-number">6&#x27;b100000</span>;

<span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] state = IDLE;  <span class="hljs-comment">// 6-bit register</span>
</div></code></pre>
<ul>
<li>One bit per state (6 bits for 6 states)</li>
<li>Simplified next-state logic</li>
<li>Clearer state transitions</li>
<li>Increased register width</li>
<li>Less efficient resource utilization</li>
</ul>
</li>
<li>
<p><strong>Gray Code Option</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// For RSI FSM with 6 states</span>
<span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">3&#x27;b000</span>,
           FILL_FIFO = <span class="hljs-number">3&#x27;b001</span>,
           READ_INIT = <span class="hljs-number">3&#x27;b011</span>,
           READ_WAIT = <span class="hljs-number">3&#x27;b010</span>,
           COMPARE   = <span class="hljs-number">3&#x27;b110</span>,
           DONE      = <span class="hljs-number">3&#x27;b111</span>;
</div></code></pre>
<ul>
<li>Only one bit changes between adjacent states</li>
<li>Reduced transition glitches</li>
<li>More complex value assignment</li>
<li>Less intuitive state values</li>
<li>Same register width as binary encoding</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Encoding Implementation Impact</strong>:</p>
<ul>
<li>
<p><strong>Synthesis Results</strong>:</p>
<ul>
<li>Binary encoding typically produces efficient logic</li>
<li>Modern FPGA synthesis tools can optimize state machines</li>
<li>Register width directly impacts resource utilization</li>
<li>State transition logic complexity affects LUT usage</li>
<li>Encoding choice affects routing and timing</li>
</ul>
</li>
<li>
<p><strong>Verification Considerations</strong>:</p>
<ul>
<li>Binary encoding provides clear state progression</li>
<li>Named constants enhance debugging readability</li>
<li>Waveform analysis simplified with sequential values</li>
<li>State values visible in simulation</li>
<li>Straightforward mapping between code and behavior</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The current binary encoding approach provides an effective balance between hardware efficiency and code clarity, using minimal register bits while maintaining readable state definitions and transitions. The explicit state constants in the RSI FSM enhance code maintainability while preserving the hardware efficiency of binary encoding.</p>
<h4 id="control-datapath-separation">Control-Datapath Separation</h4>
<p>The technical analysis system implements a clear separation between control logic and datapath components, following a fundamental hardware design principle that enhances modularity, maintainability, and verification.</p>
<p>Key aspects of this control-datapath separation include:</p>
<ol>
<li>
<p><strong>Control Logic Isolation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// State machine for control flow</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        state &lt;= IDLE;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">if</span> (start) state &lt;= CALCULATE;
            CALCULATE: state &lt;= DONE;
            DONE: state &lt;= IDLE;
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Dedicated state machines for sequencing operations</li>
<li>Clear state transitions based on control conditions</li>
<li>Isolation from data processing logic</li>
<li>Focused responsibility for operational flow</li>
<li>Simplified verification of control sequences</li>
</ul>
</li>
<li>
<p><strong>Datapath Logic Encapsulation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Datapath operations in each state</span>
<span class="hljs-keyword">case</span> (state)
    CALCULATE: <span class="hljs-keyword">begin</span>
        sum &lt;= sum + new_price - oldest_price;
        moving_avg &lt;= sum / WINDOW;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Data operations triggered by control states</li>
<li>Clear association between state and computations</li>
<li>Focused logic for data transformation</li>
<li>Arithmetic operations isolated from control flow</li>
<li>Simplified verification of calculation correctness</li>
</ul>
</li>
<li>
<p><strong>Control Signal Generation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Control signal generation</span>
done &lt;= (state == DONE);  <span class="hljs-comment">// Control signal depends on state</span>

<span class="hljs-comment">// Or more explicitly:</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        done &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == DONE) <span class="hljs-keyword">begin</span>
        done &lt;= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        done &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Explicit mapping from states to control signals</li>
<li>Clear relationship between FSM state and system control</li>
<li>Dedicated logic for control signal management</li>
<li>Consistent control behavior</li>
<li>Simplified debugging of control flow</li>
</ul>
</li>
<li>
<p><strong>Datapath Structure</strong>:</p>
<ul>
<li><strong>Price Memory</strong>: Datapath component for storing price history</li>
<li><strong>Accumulators</strong>: Sum, gain_sum, loss_sum registers</li>
<li><strong>Calculation Units</strong>: Division and comparison operations</li>
<li><strong>Output Registers</strong>: moving_avg, rsi result registers</li>
<li>Clear flow of data through dedicated components</li>
</ul>
</li>
<li>
<p><strong>Interface Between Control and Datapath</strong>:</p>
<ul>
<li>
<p><strong>Trigger Signals</strong>:</p>
<ul>
<li>start: Initiates calculation sequence</li>
<li>compute_enable: Triggers indicator calculations</li>
<li>fifo_wr_en/fifo_rd_en: Controls memory operations</li>
</ul>
</li>
<li>
<p><strong>Status Signals</strong>:</p>
<ul>
<li>memory_full: Indicates data availability</li>
<li>read_delay: Synchronizes data access timing</li>
<li>done: Signals calculation completion</li>
</ul>
</li>
<li>
<p><strong>Well-defined interfaces</strong> between control and datapath elements</p>
</li>
</ul>
</li>
<li>
<p><strong>Module-Level Separation</strong>:</p>
<ul>
<li><strong>Price Memory</strong>: Primarily datapath with minimal control</li>
<li><strong>Moving Average FSM</strong>: Integrated control and datapath</li>
<li><strong>RSI FSM</strong>: More complex control with multiple datapath elements</li>
<li><strong>Trading Decision</strong>: Simple control with conditional datapath</li>
<li><strong>Top-Level Integration</strong>: System-level control connecting datapath modules</li>
</ul>
</li>
<li>
<p><strong>Benefits of Separation</strong>:</p>
<ul>
<li>
<p><strong>Enhanced Testability</strong>:</p>
<ul>
<li>Control logic can be verified independently</li>
<li>Datapath functionality tested separately</li>
<li>Simplified test case development</li>
<li>Focused verification for each aspect</li>
<li>Comprehensive coverage with targeted tests</li>
</ul>
</li>
<li>
<p><strong>Improved Maintainability</strong>:</p>
<ul>
<li>Localized changes for control modifications</li>
<li>Isolated updates for calculation refinements</li>
<li>Reduced risk of unintended interactions</li>
<li>Clear documentation of system behavior</li>
<li>Easier understanding of complex operations</li>
</ul>
</li>
<li>
<p><strong>Design Reuse Opportunities</strong>:</p>
<ul>
<li>Control logic can be adapted for different calculations</li>
<li>Datapath components can be reused with different controllers</li>
<li>Modular enhancements for specific functions</li>
<li>Scalable architecture for additional features</li>
<li>Simplified integration of new components</li>
</ul>
</li>
<li>
<p><strong>Efficient Hardware Implementation</strong>:</p>
<ul>
<li>Clean mapping to hardware structures</li>
<li>Control typically maps to state machines/LUTs</li>
<li>Datapath maps to ALUs, multipliers, registers</li>
<li>Optimized resource utilization</li>
<li>Improved timing closure</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Implementation Patterns</strong>:</p>
<ul>
<li>
<p><strong>Small Modules</strong>: Moving Average combines control and datapath in single module</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Compact integration for simple functionality</span>
<span class="hljs-keyword">module</span> moving_average_fsm #(parameters) (ports);
    <span class="hljs-comment">// Both control (FSM) and datapath (sum, division) in one module</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>
<p><strong>Complex Modules</strong>: RSI separates internal control and datapath</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> rsi_inc #(parameters) (ports);
    <span class="hljs-comment">// Internal separation of control (state machine)</span>
    <span class="hljs-comment">// and datapath (accumulators, calculation)</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>
<p><strong>System Level</strong>: Explicit module separation by function</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Top-level integration shows separation</span>
price_memory mem14 (...);       <span class="hljs-comment">// Primarily datapath</span>
moving_average_fsm ma14 (...);  <span class="hljs-comment">// Mixed control/datapath</span>
rsi_inc rsi14 (...);            <span class="hljs-comment">// Mixed control/datapath</span>
trading_decision dec (...);      <span class="hljs-comment">// Simple control/datapath</span>
</div></code></pre>
</li>
</ul>
</li>
</ol>
<p>This control-datapath separation creates a clean architectural structure that enhances design clarity, simplifies verification, and improves maintainability. The approach is applied consistently throughout the system, with the level of separation scaled appropriately for the complexity of each module.</p>
<h4 id="state-transition-management">State Transition Management</h4>
<p>The technical analysis system implements sophisticated state transition management to ensure proper sequencing of operations, clear control flow, and reliable system behavior. This approach creates deterministic execution paths through the calculation process.</p>
<p>Key aspects of state transition management include:</p>
<ol>
<li>
<p><strong>Condition-Based Transitions</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average FSM</span>
<span class="hljs-keyword">case</span> (st)
    <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;         <span class="hljs-comment">// Transition on external trigger</span>
    <span class="hljs-number">1</span>: st &lt;= <span class="hljs-number">2</span>;                    <span class="hljs-comment">// Unconditional transition</span>
    <span class="hljs-number">2</span>: st &lt;= <span class="hljs-number">0</span>;                    <span class="hljs-comment">// Return to idle</span>
<span class="hljs-keyword">endcase</span>

<span class="hljs-comment">// RSI FSM</span>
<span class="hljs-keyword">case</span> (state)
    IDLE: <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (start) state &lt;= FILL_FIFO;  <span class="hljs-comment">// External trigger</span>
    <span class="hljs-keyword">end</span>
    
    FILL_FIFO: <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (fifo_full) state &lt;= READ_INIT;  <span class="hljs-comment">// Transition on data condition</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Other states...</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Clear conditional expressions for state changes</li>
<li>Explicit transition conditions for each state</li>
<li>Combination of external triggers and internal conditions</li>
<li>Deterministic progression through operational sequence</li>
<li>Straightforward relationship between conditions and transitions</li>
</ul>
</li>
<li>
<p><strong>Transition Trigger Categories</strong>:</p>
<ul>
<li>
<p><strong>External Control Triggers</strong>:</p>
<ul>
<li><code>start</code> signal initiates calculation sequence</li>
<li><code>new_price</code> indicates data availability</li>
<li>System-level control for orchestration</li>
</ul>
</li>
<li>
<p><strong>Data Status Conditions</strong>:</p>
<ul>
<li><code>fifo_full</code> indicates sufficient data for calculation</li>
<li><code>mem_count &gt;= 14</code> enables computation</li>
<li><code>fifo_empty</code> prevents underflow conditions</li>
</ul>
</li>
<li>
<p><strong>Processing Completion</strong>:</p>
<ul>
<li>Counter-based completion (<code>sample_cnt &lt; 19</code>)</li>
<li>Internal processing flags (<code>read_delay</code>)</li>
<li>Single-cycle operation completion</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>State Sequencing Patterns</strong>:</p>
<ul>
<li>
<p><strong>Linear Sequence</strong> (Moving Average FSM):</p>
<pre class="hljs"><code><div>IDLE  CALCULATE  DONE  IDLE
</div></code></pre>
<ul>
<li>Straightforward progression through states</li>
<li>Simple, predictable execution path</li>
<li>Minimal control logic complexity</li>
<li>Consistent operational behavior</li>
<li>Clear beginning and end points</li>
</ul>
</li>
<li>
<p><strong>Branching Sequences</strong> (RSI FSM):</p>
<pre class="hljs"><code><div>IDLE  FILL_FIFO  READ_INIT  COMPARE  READ_WAIT  DONE  IDLE
                                  ___________|
</div></code></pre>
<ul>
<li>Multiple possible paths through states</li>
<li>Conditional branches based on data conditions</li>
<li>Iterative processing loops for multiple samples</li>
<li>More complex but deterministic flow</li>
<li>Complete coverage of all processing requirements</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Transition Timing Control</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Single-cycle state</span>
READ_INIT: <span class="hljs-keyword">begin</span>
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (read_delay) <span class="hljs-keyword">begin</span>
        prev_price &lt;= price_out;
        read_delay &lt;= <span class="hljs-number">0</span>;
        state &lt;= COMPARE;  <span class="hljs-comment">// Immediate transition</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Data-dependent iteration</span>
COMPARE: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (sample_cnt &lt; <span class="hljs-number">19</span> &amp;&amp; !fifo_empty) <span class="hljs-keyword">begin</span>
        fifo_rd_en &lt;= <span class="hljs-number">1</span>;
        read_delay &lt;= <span class="hljs-number">1</span>;
        state &lt;= READ_WAIT;  <span class="hljs-comment">// Continue processing</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        state &lt;= DONE;  <span class="hljs-comment">// Exit when complete</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Explicit control of transition timing</li>
<li>Conditional progression based on data processing state</li>
<li>Clear exit conditions from iterative processes</li>
<li>Synchronization with data availability</li>
<li>Deterministic cycle count for operations</li>
</ul>
</li>
<li>
<p><strong>Default State Handling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">case</span> (state)
    <span class="hljs-comment">// State-specific logic</span>
    
    <span class="hljs-keyword">default</span>: state &lt;= IDLE;  <span class="hljs-comment">// Safe default transition</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Explicit handling of undefined or invalid states</li>
<li>Return to known state for recovery</li>
<li>Protection against unexpected conditions</li>
<li>Fault tolerance in state machine operation</li>
<li>Simplified verification of error recovery</li>
</ul>
</li>
<li>
<p><strong>Transition Gap Prevention</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// RSI FSM with default assignments</span>
done &lt;= <span class="hljs-number">0</span>;                 <span class="hljs-comment">// Default inactive</span>
fifo_wr_en &lt;= <span class="hljs-number">0</span>;           <span class="hljs-comment">// Default inactive</span>
fifo_rd_en &lt;= <span class="hljs-number">0</span>;           <span class="hljs-comment">// Default inactive</span>

<span class="hljs-keyword">case</span> (state)
    <span class="hljs-comment">// State-specific logic with selective overrides</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Default signal assignments before state-specific logic</li>
<li>Ensures complete signal definition in all states</li>
<li>Prevents inadvertent signal retention</li>
<li>Clean transitions between states</li>
<li>Predictable signal behavior during state changes</li>
</ul>
</li>
<li>
<p><strong>Transition Verification Approach</strong>:</p>
<ul>
<li>
<p><strong>Exhaustive Coverage</strong>:</p>
<ul>
<li>All possible state transitions defined</li>
<li>Each state has clear exit conditions</li>
<li>Complete state reachability</li>
</ul>
</li>
<li>
<p><strong>Deterministic Behavior</strong>:</p>
<ul>
<li>Repeatable execution sequences</li>
<li>Predictable response to inputs</li>
<li>Consistent operational flow</li>
</ul>
</li>
<li>
<p><strong>Cycle-Accurate Definition</strong>:</p>
<ul>
<li>Known number of cycles for each operation</li>
<li>Precise timing relationships</li>
<li>Synchronized transitions</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>These state transition management techniques create a robust control framework for the technical analysis system, ensuring proper sequencing of operations with deterministic behavior. The design emphasizes clarity, predictability, and reliability, with transition mechanisms tailored to the specific requirements of each FSM within the system.</p>
<h4 id="reset-strategy">Reset Strategy</h4>
<p>The technical analysis system implements a comprehensive reset strategy to ensure reliable initialization, consistent startup behavior, and robust operation. This strategy addresses both system-level and module-specific reset requirements.</p>
<p>Key aspects of the reset strategy include:</p>
<ol>
<li>
<p><strong>Asynchronous Reset Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
        state &lt;= IDLE;
        sum &lt;= <span class="hljs-number">0</span>;
        moving_avg &lt;= <span class="hljs-number">0</span>;
        done &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Normal operation</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Active-high reset signal (<code>rst</code>)</li>
<li>Asynchronous assertion (triggered immediately, regardless of clock)</li>
<li>Synchronous release (de-assertion synchronized to clock)</li>
<li>Immediate response to system reset</li>
<li>Predictable initialization behavior</li>
</ul>
</li>
<li>
<p><strong>Reset Distribution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Top-level reset distribution</span>
price_memory mem14 (
    <span class="hljs-variable">.rst</span>(rst),  <span class="hljs-comment">// Same reset signal to all modules</span>
    <span class="hljs-comment">// Other connections</span>
);

moving_average_fsm ma14 (
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-comment">// Other connections</span>
);

rsi_inc rsi14 (
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Common reset signal for all modules</li>
<li>Consistent reset timing across system</li>
<li>Simplified reset control</li>
<li>Synchronized initialization</li>
<li>Clean system-wide startup</li>
</ul>
</li>
<li>
<p><strong>Module-Specific Reset Actions</strong>:</p>
<ul>
<li>
<p><strong>Price Memory Reset</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    write_ptr &lt;= <span class="hljs-number">0</span>;        <span class="hljs-comment">// Reset pointers</span>
    read_ptr &lt;= <span class="hljs-number">0</span>;
    item_count &lt;= <span class="hljs-number">0</span>;       <span class="hljs-comment">// Clear counter</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Initialize memory management pointers</li>
<li>Clear item counter</li>
<li>Establish empty buffer condition</li>
<li>Memory contents implicitly undefined</li>
<li>Prepare for data acquisition</li>
</ul>
</li>
<li>
<p><strong>Moving Average FSM Reset</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    sum &lt;= <span class="hljs-number">0</span>;             <span class="hljs-comment">// Clear accumulators</span>
    moving_avg &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Reset outputs</span>
    done &lt;= <span class="hljs-number">0</span>;            <span class="hljs-comment">// Clear control signals</span>
    st &lt;= <span class="hljs-number">0</span>;              <span class="hljs-comment">// Return to idle state</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Clear calculation accumulators</li>
<li>Reset output registers</li>
<li>Deactivate control signals</li>
<li>Initialize to idle state</li>
<li>Prepare for new calculation sequence</li>
</ul>
</li>
<li>
<p><strong>RSI FSM Reset</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    state &lt;= IDLE;        <span class="hljs-comment">// Reset state machine</span>
    fifo_wr_en &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Clear control signals</span>
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    done &lt;= <span class="hljs-number">0</span>;
    rsi &lt;= <span class="hljs-number">0</span>;             <span class="hljs-comment">// Reset output</span>
    sample_cnt &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Clear counters</span>
    gain_sum &lt;= <span class="hljs-number">0</span>;        <span class="hljs-comment">// Reset accumulators</span>
    loss_sum &lt;= <span class="hljs-number">0</span>;
    prev_price &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Clear price registers</span>
    read_delay &lt;= <span class="hljs-number">0</span>;      <span class="hljs-comment">// Reset flags</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Comprehensive register initialization</li>
<li>All counters and accumulators cleared</li>
<li>Control signals deactivated</li>
<li>Flags reset to inactive</li>
<li>Complete preparation for new calculation</li>
</ul>
</li>
<li>
<p><strong>Trading Decision Reset</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    buy  &lt;= <span class="hljs-number">0</span>;            <span class="hljs-comment">// Clear output signals</span>
    sell &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Deactivate trading signals</li>
<li>Simple reset for combinational logic</li>
<li>Safe initial state for system integration</li>
<li>Clean startup behavior</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Reset Signal Characteristics</strong>:</p>
<ul>
<li><strong>Active High</strong>: Asserted by driving to logical '1'</li>
<li><strong>Globally Distributed</strong>: Same signal to all modules</li>
<li><strong>Externally Generated</strong>: Provided from system level</li>
<li><strong>Asynchronous Assertion</strong>: Immediate effect regardless of clock</li>
<li><strong>Sufficient Duration</strong>: Multiple clock cycles for stable initialization</li>
</ul>
</li>
<li>
<p><strong>Reset Sequence Timing</strong>:</p>
<pre class="hljs"><code><div>rst \________________/
clk _/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_
                 |
                 V
            Reset captured
                 |
                 V
            All registers cleared
                 |
                 V
            System in known state
</div></code></pre>
<ul>
<li>Reset asserted for multiple clock cycles</li>
<li>All modules reset simultaneously</li>
<li>Synchronous operation begins after reset release</li>
<li>Clean transition to normal operation</li>
<li>Predictable startup behavior</li>
</ul>
</li>
<li>
<p><strong>Power-On Reset Considerations</strong>:</p>
<ul>
<li>External reset circuitry typically required</li>
<li>Reset signal held active during power stabilization</li>
<li>Release only after clock is stable</li>
<li>Sufficient duration to initialize all registers</li>
<li>Consistent with FPGA platform requirements</li>
</ul>
</li>
<li>
<p><strong>Reset Verification Approach</strong>:</p>
<ul>
<li>Reset applied at various operational phases</li>
<li>Verification of register initialization values</li>
<li>Confirmation of state machine reset to idle</li>
<li>Validation of signal deactivation</li>
<li>Testing of transition to normal operation</li>
</ul>
</li>
</ol>
<p>The reset strategy ensures that the technical analysis system starts from a known, stable state and can recover from error conditions. The approach emphasizes comprehensive initialization, consistent behavior across modules, and reliable operation after reset, creating a robust foundation for system operation.</p>
<h4 id="flag-and-control-signal-design">Flag and Control Signal Design</h4>
<p>The technical analysis system implements a comprehensive flag and control signal design strategy to manage system operation, coordinate between modules, and indicate status conditions. These signals create a robust communication framework that ensures proper system behavior.</p>
<p>Key aspects of the flag and control signal design include:</p>
<ol>
<li>
<p><strong>Signal Categorization</strong>:</p>
<ul>
<li><strong>Trigger Signals</strong>: Initiate operations or state transitions</li>
<li><strong>Status Flags</strong>: Indicate current system state or conditions</li>
<li><strong>Handshaking Signals</strong>: Coordinate between modules</li>
<li><strong>Control Outputs</strong>: Direct external system behavior</li>
<li><strong>Internal Flags</strong>: Manage module-specific operation</li>
</ul>
</li>
<li>
<p><strong>Primary Control Signals</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// External inputs</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_price;       <span class="hljs-comment">// New price available</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start;           <span class="hljs-comment">// Start calculation</span>

<span class="hljs-comment">// Internal triggers</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);  <span class="hljs-comment">// Calculation trigger</span>

<span class="hljs-comment">// Module-specific control</span>
<span class="hljs-keyword">reg</span> fifo_wr_en = <span class="hljs-number">0</span>;         <span class="hljs-comment">// FIFO write enable</span>
<span class="hljs-keyword">reg</span> fifo_rd_en = <span class="hljs-number">0</span>;         <span class="hljs-comment">// FIFO read enable</span>

<span class="hljs-comment">// System outputs</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy;             <span class="hljs-comment">// Buy signal</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell;            <span class="hljs-comment">// Sell signal</span>
</div></code></pre>
<ul>
<li>Clear purpose for each signal</li>
<li>Consistent naming convention</li>
<li>Appropriate signal direction</li>
<li>Explicit type (reg/wire)</li>
<li>Documented functionality</li>
</ul>
</li>
<li>
<p><strong>Status Flag Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Memory status flags</span>
<span class="hljs-keyword">assign</span> full = (item_count == DEPTH);   <span class="hljs-comment">// FIFO full flag</span>
<span class="hljs-keyword">assign</span> count = item_count;             <span class="hljs-comment">// FIFO count</span>

<span class="hljs-comment">// Calculation status</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done;             <span class="hljs-comment">// Calculation complete</span>

<span class="hljs-comment">// Internal status tracking</span>
<span class="hljs-keyword">reg</span> read_delay = <span class="hljs-number">0</span>;          <span class="hljs-comment">// FIFO read synchronization</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] sample_cnt = <span class="hljs-number">0</span>;    <span class="hljs-comment">// Sample counter</span>
</div></code></pre>
<ul>
<li>Direct mapping to system conditions</li>
<li>Clear relationship to operational state</li>
<li>Boolean logic for binary conditions</li>
<li>Counters for quantitative status</li>
<li>Explicit flag for critical conditions</li>
</ul>
</li>
<li>
<p><strong>Signal Timing Characteristics</strong>:</p>
<ul>
<li>
<p><strong>Level-Sensitive Control</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Signal active while condition true</span>
<span class="hljs-keyword">assign</span> memory_full = (mem_cnt == <span class="hljs-number">14</span>);
</div></code></pre>
<ul>
<li>Signal level directly reflects condition</li>
<li>Remains active while condition persists</li>
<li>Simple combinational implementation</li>
<li>Direct relationship to system state</li>
<li>Continuous status indication</li>
</ul>
</li>
<li>
<p><strong>Pulse-Based Signaling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// One-cycle pulse signal</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">case</span> (state)
        DONE: <span class="hljs-keyword">begin</span>
            done &lt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// Activate for one cycle</span>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>
            done &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">// Inactive in all other states</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endcase</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Signal active for exactly one clock cycle</li>
<li>Clean transitions for edge detection</li>
<li>Clear timing relationship to triggering event</li>
<li>Simplified downstream detection logic</li>
<li>Prevents multi-cycle activation issues</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Control Signal Generation Patterns</strong>:</p>
<ul>
<li>
<p><strong>State-Based Generation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Signal depends on current state</span>
fifo_rd_en &lt;= (state == COMPARE &amp;&amp; sample_cnt &lt; <span class="hljs-number">19</span> &amp;&amp; !fifo_empty);
</div></code></pre>
<ul>
<li>Direct relationship to state machine</li>
<li>Conditional activation based on state</li>
<li>Synchronized to clock edge</li>
<li>Clear timing relative to operations</li>
<li>Deterministic activation pattern</li>
</ul>
</li>
<li>
<p><strong>Condition-Based Generation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Signal active when condition met</span>
buy &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
</div></code></pre>
<ul>
<li>Direct mapping from conditions</li>
<li>Combinational logic with registered output</li>
<li>Immediate response to input changes</li>
<li>Clear relationship to system conditions</li>
<li>Simple implementation and verification</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Signal Coordination Techniques</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// RSI FSM internal coordination</span>
<span class="hljs-keyword">if</span> (read_delay) <span class="hljs-keyword">begin</span>
    curr_price &lt;= price_out;
    <span class="hljs-comment">// Process data...</span>
    read_delay &lt;= <span class="hljs-number">0</span>;
    state &lt;= COMPARE;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Explicit flags for operation sequencing</li>
<li>Clear handshaking between operations</li>
<li>Controlled timing relationships</li>
<li>Synchronization of data access</li>
<li>Deterministic operational flow</li>
</ul>
</li>
<li>
<p><strong>Default Signal Assignment</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Initialize to inactive</span>
fifo_wr_en &lt;= <span class="hljs-number">0</span>;
fifo_rd_en &lt;= <span class="hljs-number">0</span>;
done &lt;= <span class="hljs-number">0</span>;

<span class="hljs-comment">// Override in specific states</span>
<span class="hljs-keyword">case</span> (state)
    <span class="hljs-comment">// Selective activation</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Default inactive state for all control signals</li>
<li>Explicit activation in specific conditions</li>
<li>Prevents unintended signal persistence</li>
<li>Clean transition between states</li>
<li>Clear signal behavior in all conditions</li>
</ul>
</li>
<li>
<p><strong>Signal Routing Architecture</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Top-level signal connection</span>
<span class="hljs-keyword">wire</span> memory_full;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count;

price_memory mem14 (
    <span class="hljs-comment">// Connections</span>
    <span class="hljs-variable">.full</span>(memory_full),
    <span class="hljs-variable">.count</span>(count)
);

<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

moving_average_fsm ma14 (
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Direct signal routing where possible</li>
<li>Derived signals for specific conditions</li>
<li>Minimized signal transformation</li>
<li>Clear signal flow through system</li>
<li>Simplified timing analysis</li>
</ul>
</li>
<li>
<p><strong>Signal Specification Summary</strong>:</p>
<table>
<thead>
<tr>
<th>Signal Category</th>
<th>Examples</th>
<th>Implementation</th>
<th>Timing Characteristics</th>
</tr>
</thead>
<tbody>
<tr>
<td>External Inputs</td>
<td>new_price, start</td>
<td>Input ports</td>
<td>Asynchronous, externally timed</td>
</tr>
<tr>
<td>Trigger Signals</td>
<td>compute_enable, fifo_wr_en</td>
<td>Derived or state-based</td>
<td>One-cycle pulses</td>
</tr>
<tr>
<td>Status Flags</td>
<td>full, memory_full</td>
<td>Condition-based assignment</td>
<td>Level-sensitive, condition-based</td>
</tr>
<tr>
<td>Handshaking</td>
<td>done, read_delay</td>
<td>State-based with reset</td>
<td>One-cycle pulses or state flags</td>
</tr>
<tr>
<td>Control Outputs</td>
<td>buy, sell</td>
<td>Registered condition evaluation</td>
<td>Level-sensitive with clean edges</td>
</tr>
<tr>
<td>Counters</td>
<td>item_count, sample_cnt</td>
<td>Incremental with conditions</td>
<td>Value-based status</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>This flag and control signal design creates a robust communication framework within the technical analysis system, ensuring proper coordination between modules, clear operational flow, and reliable system behavior. The approach emphasizes explicit control relationships, deterministic timing, and simplified integration.</p>
<h3 id="system-integration">System Integration</h3>
<h4 id="clock-domain-management">Clock Domain Management</h4>
<p>The technical analysis system implements a single clock domain strategy to simplify timing analysis, ensure deterministic behavior, and eliminate synchronization issues. This approach provides a solid foundation for reliable system operation.</p>
<p>Key aspects of the clock domain management include:</p>
<ol>
<li>
<p><strong>Single Clock Architecture</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Module port declarations</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,  <span class="hljs-comment">// System clock</span>

<span class="hljs-comment">// Clock distribution through hierarchy</span>
price_memory mem14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-comment">// Other connections</span>
);

moving_average_fsm ma14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Common clock signal throughout system</li>
<li>Direct distribution without gating or division</li>
<li>Synchronized operation across all modules</li>
<li>Simplified timing analysis</li>
<li>No clock domain crossing complexity</li>
</ul>
</li>
<li>
<p><strong>Clock Characteristics</strong>:</p>
<ul>
<li><strong>Frequency</strong>: Design validated at 100 MHz (10ns period)</li>
<li><strong>Duty Cycle</strong>: 50% (standard for FPGA designs)</li>
<li><strong>Global Routing</strong>: Utilizes dedicated clock resources</li>
<li><strong>Edge Usage</strong>: Rising edge for all sequential logic</li>
<li><strong>Stability Requirements</strong>: Standard jitter/skew tolerance</li>
</ul>
</li>
<li>
<p><strong>Sequential Element Synchronization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// All registers use same clock edge</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Normal operation</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Universal posedge clk triggering</li>
<li>Consistent clock polarity</li>
<li>Synchronized state transitions</li>
<li>Aligned data capture</li>
<li>Predictable timing relationships</li>
</ul>
</li>
<li>
<p><strong>System Timing Relationships</strong>:</p>
<pre class="hljs"><code><div>clk    _/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_

new_price ___/\___________________________/\___

write_en  ___/\___________________________/\___

mem_full  _________________/

start     _________________/\____________________

done      ___________________________/\___________
</div></code></pre>
<ul>
<li>Synchronized signal relationships</li>
<li>Predictable cycle counts between events</li>
<li>Deterministic operational flow</li>
<li>Clean signal transitions</li>
<li>Explicit timing relationships</li>
</ul>
</li>
<li>
<p><strong>Input Handling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Direct sampling of input signals</span>
<span class="hljs-keyword">if</span> (new_price) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Process new price</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>External inputs sampled on clock edge</li>
<li>No explicit synchronization logic</li>
<li>Assumes inputs stable during sampling</li>
<li>Simplified interface design</li>
<li>Potential metastability risk for truly asynchronous inputs</li>
</ul>
</li>
<li>
<p><strong>Alternative Approaches Considered</strong>:</p>
<ul>
<li>
<p><strong>Multiple Clock Domains</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Not implemented but considered</span>
<span class="hljs-keyword">module</span> dual_clock_system (
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk_fast,  <span class="hljs-comment">// Higher frequency for calculation</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk_slow,  <span class="hljs-comment">// Lower frequency for interface</span>
    <span class="hljs-comment">// Other ports</span>
);

<span class="hljs-comment">// Would require synchronization:</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sync_req;
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk_fast) <span class="hljs-keyword">begin</span>
    sync_req &lt;= {sync_req[<span class="hljs-number">0</span>], req};  <span class="hljs-comment">// 2-stage synchronizer</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Rejected due to:
<ul>
<li>Increased complexity</li>
<li>Synchronization overhead</li>
<li>Potential metastability issues</li>
<li>More complex verification</li>
<li>Limited performance benefit for application</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Gating</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Not implemented but considered</span>
<span class="hljs-keyword">wire</span> gated_clk = clk &amp; enable;  <span class="hljs-comment">// Simple clock gating</span>
</div></code></pre>
<ul>
<li>Rejected due to:
<ul>
<li>Potential glitch issues</li>
<li>Non-standard practice for FPGAs</li>
<li>Clock skew concerns</li>
<li>Verification complexity</li>
<li>Limited power benefit in FPGA</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Considerations for System Integration</strong>:</p>
<ul>
<li>
<p><strong>External Interface Timing</strong>:</p>
<ul>
<li>Input synchronization may be required at system boundary</li>
<li>Double-flop synchronizers for truly asynchronous inputs</li>
<li>Output hold time guarantees for external systems</li>
</ul>
</li>
<li>
<p><strong>Integration with Multi-Clock Systems</strong>:</p>
<ul>
<li>Interface registers for crossing to different domains</li>
<li>Handshaking protocols for safe data transfer</li>
<li>Gray-coded counters for multi-bit transfers</li>
</ul>
</li>
<li>
<p><strong>Future Extension Options</strong>:</p>
<ul>
<li>Framework supports adding clock domain crossing if needed</li>
<li>Modular design allows selective domain assignment</li>
<li>Clear interfaces simplify future synchronization</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Resource Management</strong>:</p>
<ul>
<li><strong>FPGA-Specific Considerations</strong>:
<ul>
<li>Utilization of dedicated clock networks</li>
<li>Appropriate buffering for clock distribution</li>
<li>Minimized clock skew through design practices</li>
<li>Clock region planning for larger implementations</li>
<li>Power optimization through proper resource usage</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The single clock domain approach provides significant advantages for this application:</p>
<ul>
<li>Simplified timing analysis and verification</li>
<li>Elimination of synchronization overhead</li>
<li>Deterministic behavior and cycle counts</li>
<li>Reduced risk of timing-related bugs</li>
<li>Straightforward system integration</li>
</ul>
<p>This approach aligns with the performance requirements of the technical analysis system, where calculation frequency far exceeds market data update rates, making the additional complexity of multiple clock domains unnecessary for this application.</p>
<h4 id="parallel-processing-approach">Parallel Processing Approach</h4>
<p>The technical analysis system implements a parallel processing approach to efficiently calculate multiple technical indicators simultaneously. This approach maximizes throughput, optimizes resource utilization, and creates a scalable architecture for system extension.</p>
<p>Key aspects of the parallel processing approach include:</p>
<ol>
<li>
<p><strong>Concurrent Indicator Calculation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Simultaneous instantiation and operation</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

<span class="hljs-comment">// Moving Average calculation</span>
moving_average_fsm ma14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),
    <span class="hljs-variable">.done</span>(ma_done)
);

<span class="hljs-comment">// RSI calculation (parallel operation)</span>
rsi_inc rsi14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.mem_full</span>(mem_full),
    <span class="hljs-variable">.mem_count</span>(mem_cnt),
    <span class="hljs-variable">.rsi</span>(rsi),
    <span class="hljs-variable">.done</span>(rsi_done)
);
</div></code></pre>
<ul>
<li>Independent calculation modules</li>
<li>Simultaneous operation on same clock cycle</li>
<li>Common trigger signal for synchronization</li>
<li>Parallel data paths for each indicator</li>
<li>Maximum computational throughput</li>
</ul>
</li>
<li>
<p><strong>Shared Data Architecture</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Common price memory shared by indicators</span>
price_memory mem14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.wr_en</span>(new_price),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.full</span>(mem_full),
    <span class="hljs-variable">.count</span>(count)
);
</div></code></pre>
<ul>
<li>Centralized price history storage</li>
<li>Common access to newest and oldest prices</li>
<li>Shared memory resource for efficiency</li>
<li>Consistent data source for all calculations</li>
<li>Elimination of data duplication</li>
</ul>
</li>
<li>
<p><strong>Independent Calculation Paths</strong>:</p>
<ul>
<li>Each indicator module contains:
<ul>
<li>Dedicated state machine for control</li>
<li>Private registers for calculation state</li>
<li>Isolated computational logic</li>
<li>Independent completion signaling</li>
<li>Module-specific optimization</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Parallel Dataflow Architecture</strong>:</p>
<pre class="hljs"><code><div>                       Price Data
                           
                           
                 
                     Price Memory     
                 
                           
                
                                     
                                     
          
        Moving Average       RSI Calculator 
             FSM                            
          
                                     
                                     
                   
              MA                  RSI    
            Result              Result   
                   
                                     
                
                          
                          
                 
                  Trading Decision 
                 
</div></code></pre>
<ul>
<li>Clean separation of calculation paths</li>
<li>Parallel data flow through system</li>
<li>Concurrent operation at each stage</li>
<li>Clear data dependencies</li>
<li>Optimal resource utilization</li>
</ul>
</li>
<li>
<p><strong>Synchronization Points</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Common trigger for indicators</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

<span class="hljs-comment">// Independent completion signals</span>
<span class="hljs-keyword">wire</span> ma_done;  <span class="hljs-comment">// From MA module</span>
<span class="hljs-keyword">wire</span> rsi_done; <span class="hljs-comment">// From RSI module</span>

<span class="hljs-comment">// Trading decision uses completed results</span>
trading_decision dec (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.price_now</span>(price_in),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),  <span class="hljs-comment">// From MA calculation</span>
    <span class="hljs-variable">.rsi</span>(rsi),                <span class="hljs-comment">// From RSI calculation</span>
    <span class="hljs-variable">.buy</span>(buy),
    <span class="hljs-variable">.sell</span>(sell)
);
</div></code></pre>
<ul>
<li>Synchronous initiation of calculations</li>
<li>Independent completion timing</li>
<li>Readiness indicated by done signals</li>
<li>Downstream modules use completed results</li>
<li>Clean coordination without tight coupling</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Efficiency</strong>:</p>
<ul>
<li>
<p><strong>Computational Resources</strong>:</p>
<ul>
<li>Independent arithmetic units for each indicator</li>
<li>Dedicated state machines for control</li>
<li>Selective application of optimization techniques</li>
</ul>
</li>
<li>
<p><strong>Memory Resources</strong>:</p>
<ul>
<li>Shared price history buffer</li>
<li>Dedicated registers for calculation state</li>
<li>Optimized register width for each application</li>
</ul>
</li>
<li>
<p><strong>Control Resources</strong>:</p>
<ul>
<li>Common triggering logic</li>
<li>Separate completion signaling</li>
<li>Independent state management</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Scalability Characteristics</strong>:</p>
<ul>
<li>
<p><strong>Horizontal Scaling</strong>:</p>
<ul>
<li>Additional indicators can be added in parallel</li>
<li>Common price memory architecture</li>
<li>Independent calculation modules</li>
<li>Minimal modification to existing components</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// Adding new indicator (example)</span>
macd_calculator macd_inst (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.macd_line</span>(macd),
    <span class="hljs-variable">.signal_line</span>(signal),
    <span class="hljs-variable">.done</span>(macd_done)
);
</div></code></pre>
</li>
<li>
<p><strong>Vertical Scaling</strong>:</p>
<ul>
<li>Multiple instrument tracking by replicating structure</li>
<li>Array of parallel systems for different symbols</li>
<li>Shared control with independent data paths</li>
<li>Linear resource scaling with instrument count</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Performance Characteristics</strong>:</p>
<ul>
<li>
<p><strong>Latency Impact</strong>:</p>
<ul>
<li>Parallel processing does not reduce latency of individual calculations</li>
<li>Overall system latency determined by longest path (typically RSI)</li>
<li>Consistent cycle count regardless of parallelism</li>
</ul>
</li>
<li>
<p><strong>Throughput Enhancement</strong>:</p>
<ul>
<li>Multiple indicators calculated per clock cycle</li>
<li>Overall system throughput significantly increased</li>
<li>Maximum data processing efficiency</li>
<li>Optimal utilization of clock cycles</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>This parallel processing approach maximizes the computational efficiency of the technical analysis system, enabling simultaneous calculation of multiple indicators without increasing latency. The architecture provides a scalable foundation for extension with additional indicators while maintaining deterministic timing and efficient resource utilization.</p>
<h4 id="synchronous-design-principles">Synchronous Design Principles</h4>
<p>The technical analysis system implements a thoroughly synchronous design approach, following best practices for digital hardware implementation. This approach ensures reliable operation, simplified timing analysis, and robust system behavior.</p>
<p>Key synchronous design principles include:</p>
<ol>
<li>
<p><strong>Clock-Driven Sequential Logic</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// All sequential elements synchronized to clock</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Normal operation</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>All state changes occur on clock edges</li>
<li>Consistent clock edge usage (rising edge)</li>
<li>No asynchronous state updates (except reset)</li>
<li>Predictable timing relationships</li>
<li>Clean synchronization boundaries</li>
</ul>
</li>
<li>
<p><strong>Registered Outputs</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Registered output signals</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        moving_avg &lt;= <span class="hljs-number">0</span>;
        done &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Update logic with registered outputs</span>
        moving_avg &lt;= sum / WINDOW;
        done &lt;= (state == DONE);
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>All outputs driven by registers</li>
<li>Clean output timing</li>
<li>Glitch-free external interfaces</li>
<li>Predictable setup/hold timing</li>
<li>Simplified timing constraints</li>
</ul>
</li>
<li>
<p><strong>Synchronous State Machines</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// State transition on clock edge</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        state &lt;= IDLE;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            <span class="hljs-comment">// Next state logic</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>State changes only on clock edges</li>
<li>Deterministic state sequencing</li>
<li>Clear operational flow</li>
<li>Simplified timing analysis</li>
<li>Reduced risk of timing hazards</li>
</ul>
</li>
<li>
<p><strong>Two-Process State Machine Model</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// State register process</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        state &lt;= IDLE;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        state &lt;= next_state;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Next state &amp; output logic process</span>
<span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Default assignments</span>
    next_state = state;
    
    <span class="hljs-keyword">case</span> (state)
        <span class="hljs-comment">// State-specific logic</span>
    <span class="hljs-keyword">endcase</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Clear separation of state register and combinational logic</li>
<li>Simplified analysis and verification</li>
<li>Consistent design pattern</li>
<li>Standard synthesis optimization</li>
<li>Readable code structure</li>
</ul>
</li>
<li>
<p><strong>Synchronous Memory Access</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Synchronous write, asynchronous read</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
        mem[write_ptr] &lt;= new_price;
        <span class="hljs-comment">// Pointer update logic</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Asynchronous read output</span>
<span class="hljs-keyword">assign</span> oldest_price = mem[read_ptr];
</div></code></pre>
<ul>
<li>Memory writes synchronized to clock</li>
<li>Clean timing for write operations</li>
<li>Pointer updates on clock edge</li>
<li>Consistent memory update timing</li>
<li>Standard FPGA memory access pattern</li>
</ul>
</li>
<li>
<p><strong>Input Sampling</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Synchronous sampling of inputs</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (new_price) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Process using sampled input</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>External inputs sampled on clock edge</li>
<li>Stable input values during processing</li>
<li>Consistent timing reference</li>
<li>Simplified input handling</li>
<li>Deterministic behavior for changing inputs</li>
</ul>
</li>
<li>
<p><strong>Single-Cycle Operations vs. Multi-Cycle Operations</strong>:</p>
<ul>
<li>
<p><strong>Single-Cycle</strong> (implemented):</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Complete operation in one cycle</span>
sum &lt;= sum + new_price - oldest_price;
moving_avg &lt;= sum / WINDOW;
</div></code></pre>
<ul>
<li>Simplifies control logic</li>
<li>Reduces state machine complexity</li>
<li>Minimizes latency</li>
<li>Clear timing boundaries</li>
<li>Straightforward verification</li>
</ul>
</li>
<li>
<p><strong>Multi-Cycle</strong> (alternative approach):</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Multi-cycle division operation</span>
<span class="hljs-keyword">case</span> (div_state)
    <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>
        remainder &lt;= sum;
        quotient &lt;= <span class="hljs-number">0</span>;
        count &lt;= <span class="hljs-number">5</span>;  <span class="hljs-comment">// log2(WINDOW) iterations</span>
        div_state &lt;= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">end</span>
    <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Division algorithm steps</span>
        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)
            div_state &lt;= <span class="hljs-number">2</span>;
        <span class="hljs-keyword">else</span>
            count &lt;= count - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">end</span>
    <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
        moving_avg &lt;= quotient;
        div_state &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>More complex control</li>
<li>Potentially more efficient for complex operations</li>
<li>Explicit cycle counting</li>
<li>Extended latency</li>
<li>More involved verification</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Integrity</strong>:</p>
<ul>
<li>Single clock domain for all sequential logic</li>
<li>No gated clocks or derived clocks</li>
<li>Global clock distribution</li>
<li>Consistent clocking scheme</li>
<li>Elimination of domain crossing issues</li>
</ul>
</li>
<li>
<p><strong>Timing Path Management</strong>:</p>
<ul>
<li>Register-to-register paths for critical timing</li>
<li>Balanced logic depth between registers</li>
<li>Critical path optimization</li>
<li>Predictable timing closure</li>
<li>Margin for implementation variations</li>
</ul>
</li>
</ol>
<p>These synchronous design principles create a robust foundation for the technical analysis system, ensuring reliable operation with deterministic timing. The approach follows standard best practices for digital hardware design, resulting in a system that is straightforward to verify, synthesize, and integrate.</p>
<h4 id="interface-definition-standards">Interface Definition Standards</h4>
<p>The technical analysis system implements consistent interface definition standards across all modules, creating clear communication boundaries, simplified integration, and maintainable code. These standards ensure proper interaction between components and establish a foundation for system extension.</p>
<p>Key interface definition standards include:</p>
<ol>
<li>
<p><strong>Port Declaration Organization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,    <span class="hljs-comment">// Parameters first</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Clock and reset signals first</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Control inputs</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start,
    
    <span class="hljs-comment">// Data inputs</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    
    <span class="hljs-comment">// Data outputs</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    
    <span class="hljs-comment">// Control outputs</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
</div></code></pre>
<ul>
<li>Consistent port ordering across modules</li>
<li>Logical grouping by signal function</li>
<li>Clock and reset signals first</li>
<li>Control signals before data signals</li>
<li>Inputs before outputs</li>
<li>Clear width specification for multi-bit signals</li>
</ul>
</li>
<li>
<p><strong>Parameter Definition Standards</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,    <span class="hljs-comment">// Buffer depth</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>        <span class="hljs-comment">// Data width</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<ul>
<li>Parameters precede port declarations</li>
<li>Default values provided for all parameters</li>
<li>Clear naming reflecting parameter purpose</li>
<li>Consistent naming across modules</li>
<li>Descriptive comments for documentation</li>
</ul>
</li>
<li>
<p><strong>Signal Direction Clarity</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Explicit direction for all ports</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,          <span class="hljs-comment">// Input signal, wire type</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum,   <span class="hljs-comment">// Output signal, register type</span>
<span class="hljs-keyword">inout</span> <span class="hljs-keyword">tri</span> data_bus       <span class="hljs-comment">// Bidirectional signal (if used)</span>
</div></code></pre>
<ul>
<li>Explicit direction for all ports (input/output/inout)</li>
<li>Clear type specification (wire/reg)</li>
<li>Width specification for multi-bit signals</li>
<li>Consistency in type usage</li>
<li>Adherence to hardware requirements</li>
</ul>
</li>
<li>
<p><strong>Interface Signal Categories</strong>:</p>
<ul>
<li>
<p><strong>Clock and Reset</strong>:</p>
<ul>
<li><code>clk</code>: System clock (rising edge active)</li>
<li><code>rst</code>: Asynchronous reset (active high)</li>
</ul>
</li>
<li>
<p><strong>Control Signals</strong>:</p>
<ul>
<li><code>start</code>, <code>new_price</code>: Trigger signals (one-cycle pulses)</li>
<li><code>done</code>: Completion indicator (one-cycle pulse)</li>
</ul>
</li>
<li>
<p><strong>Data Signals</strong>:</p>
<ul>
<li><code>price_in</code>, <code>oldest_price</code>: Price data values</li>
<li><code>moving_avg</code>, <code>rsi</code>: Calculation results</li>
</ul>
</li>
<li>
<p><strong>Status Signals</strong>:</p>
<ul>
<li><code>full</code>, <code>memory_full</code>: Condition indicators</li>
<li><code>count</code>, <code>mem_cnt</code>: Quantitative status</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Module Header Documentation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// ==========================================================================</span>
<span class="hljs-comment">// moving_average_fsm.v</span>
<span class="hljs-comment">// 20-period rolling mean (integer division)</span>
<span class="hljs-comment">// ==========================================================================</span>

<span class="hljs-comment">// ==========================================================================</span>
<span class="hljs-comment">// trading_decision.v</span>
<span class="hljs-comment">// Simple rule: BUY when price&gt;MA &amp; RSI&lt;30, SELL when price&lt;MA &amp; RSI&gt;70</span>
<span class="hljs-comment">// ==========================================================================</span>
</div></code></pre>
<ul>
<li>Consistent header format across modules</li>
<li>Clear module identification</li>
<li>Concise functional description</li>
<li>Key parameters or characteristics</li>
<li>Separation from implementation details</li>
</ul>
</li>
<li>
<p><strong>Interface Timing Specification</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Timing implied through implementation</span>

<span class="hljs-comment">// Input sampling on clock edge</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Process triggered by start signal</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Output generation on clock edge</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    done &lt;= (state == DONE);  <span class="hljs-comment">// One-cycle pulse</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Clear timing relationships through code structure</li>
<li>Consistent interpretation across modules</li>
<li>Synchronous interface timing</li>
<li>Edge-triggered control signals</li>
<li>Deterministic input/output behavior</li>
</ul>
</li>
<li>
<p><strong>Signal Naming Conventions</strong>:</p>
<ul>
<li>
<p><strong>Clock and Reset</strong>:</p>
<ul>
<li><code>clk</code>: System clock</li>
<li><code>rst</code>: Reset signal</li>
</ul>
</li>
<li>
<p><strong>Control Signals</strong>:</p>
<ul>
<li><code>start</code>, <code>done</code>: Capitalized verbs or states</li>
<li><code>wr_en</code>, <code>rd_en</code>: Action-based abbreviations</li>
</ul>
</li>
<li>
<p><strong>Data Signals</strong>:</p>
<ul>
<li><code>price_in</code>, <code>oldest_price</code>: Descriptive of content</li>
<li><code>moving_avg</code>, <code>rsi</code>: Result identification</li>
</ul>
</li>
<li>
<p><strong>Internal Signals</strong>:</p>
<ul>
<li><code>state</code>, <code>st</code>: State registers</li>
<li><code>sum</code>, <code>gain_sum</code>: Accumulator identification</li>
</ul>
</li>
<li>
<p><strong>Counter/Pointer Signals</strong>:</p>
<ul>
<li><code>write_ptr</code>, <code>read_ptr</code>: Function-based naming</li>
<li><code>item_count</code>, <code>sample_cnt</code>: Quantity indication</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Module Instantiation Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Named port connection for clarity</span>
moving_average_fsm ma14 (
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst</span>(rst),
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.oldest_price</span>(oldest_price),
    <span class="hljs-variable">.moving_avg</span>(moving_avg),
    <span class="hljs-variable">.done</span>(ma_done)
);

<span class="hljs-comment">// Parameter override when needed</span>
trading_decision #(
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">25</span>),     <span class="hljs-comment">// Override default</span>
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">75</span>)
) decision_module (
    <span class="hljs-comment">// Port connections</span>
);
</div></code></pre>
<ul>
<li>Named port connections for readability</li>
<li>Explicit parameter overrides when needed</li>
<li>Consistent instantiation style</li>
<li>Instance names reflecting function</li>
<li>Clear relationship to module definition</li>
</ul>
</li>
<li>
<p><strong>Interface Consistency Between Modules</strong>:</p>
<ul>
<li>Common signal naming across module boundaries</li>
<li>Consistent bit widths for shared signals</li>
<li>Compatible timing characteristics</li>
<li>Aligned control signal behavior</li>
<li>Standardized reset response</li>
</ul>
</li>
</ol>
<p>These interface definition standards create clear, consistent boundaries between modules in the technical analysis system. The approach enhances code readability, simplifies integration, and establishes a foundation for maintainable and extensible design.</p>
<h4 id="timing-closure-strategies">Timing Closure Strategies</h4>
<p>The technical analysis system implements several timing closure strategies to ensure reliable operation across various implementation scenarios. These strategies address critical timing paths, establish margins for variability, and enable consistent performance on FPGA platforms.</p>
<p>Key timing closure strategies include:</p>
<ol>
<li>
<p><strong>Register-to-Register Paths</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Registered inputs and outputs</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Input sampling</span>
    curr_price &lt;= price_out;
    
    <span class="hljs-comment">// Processing</span>
    <span class="hljs-keyword">if</span> (price_out &gt; prev_price)
        gain_sum &lt;= gain_sum + (price_out - prev_price);
    
    <span class="hljs-comment">// Output registration</span>
    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Sequential elements on both ends of logic paths</li>
<li>Synchronous capture of inputs</li>
<li>Registered outputs for clean timing</li>
<li>Clear timing boundaries</li>
<li>Predictable path delays</li>
</ul>
</li>
<li>
<p><strong>Logic Depth Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Balanced logic depth between registers</span>

<span class="hljs-comment">// Moderate complexity in single cycle:</span>
sum &lt;= sum + new_price - oldest_price;
moving_avg &lt;= sum / WINDOW;

<span class="hljs-comment">// Alternative with pipelining (not implemented):</span>
<span class="hljs-comment">// Cycle 1:</span>
sum_temp &lt;= sum + new_price - oldest_price;
<span class="hljs-comment">// Cycle 2:</span>
sum &lt;= sum_temp;
moving_avg &lt;= sum_temp / WINDOW;
</div></code></pre>
<ul>
<li>Reasonable combinational depth between registers</li>
<li>Balanced complexity for critical operations</li>
<li>Operation partitioning when necessary</li>
<li>Consideration of synthesis optimization</li>
<li>Target technology capabilities factored in</li>
</ul>
</li>
<li>
<p><strong>Critical Path Identification</strong>:</p>
<ul>
<li>
<p><strong>Primary Critical Paths</strong>:</p>
<ol>
<li>Division Operation: <code>moving_avg &lt;= sum / WINDOW;</code></li>
<li>RSI Calculation: <code>rsi &lt;= (100 * gain_sum) / (gain_sum + loss_sum);</code></li>
<li>Comparison Logic: <code>buy &lt;= (price_now &gt; moving_avg[15:0]) &amp;&amp; (rsi &lt; BUY_RSI_THR);</code></li>
</ol>
</li>
<li>
<p><strong>Mitigation Approaches</strong>:</p>
<ul>
<li>Wide registers to prevent overflow issues</li>
<li>Constant divisors for optimization</li>
<li>Simple comparison logic</li>
<li>Minimal arithmetic complexity</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Frequency Selection</strong>:</p>
<ul>
<li>Target frequency: 100 MHz (10ns period)</li>
<li>Provides sufficient margin for critical paths</li>
<li>Accommodates synthesis and implementation variations</li>
<li>Realistic for target FPGA platforms</li>
<li>Exceeds requirements for market data processing</li>
</ul>
</li>
<li>
<p><strong>Synthesis Optimization Directives</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Synthesis attributes (example)</span>
(* use_dsp = <span class="hljs-string">&quot;yes&quot;</span> *) <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum;  <span class="hljs-comment">// Hint for DSP usage</span>

<span class="hljs-comment">// Timing constraints (in constraint file)</span>
<span class="hljs-comment">// create_clock -period 10.000 -name clk [get_ports clk]</span>
<span class="hljs-comment">// set_input_delay -clock clk 2.000 [get_ports {new_price*}]</span>
<span class="hljs-comment">// set_output_delay -clock clk 2.000 [get_ports {moving_avg* rsi* buy sell}]</span>
</div></code></pre>
<ul>
<li>Synthesis attributes for critical components</li>
<li>Explicit timing constraints</li>
<li>Reasonable input/output delays</li>
<li>Clock definition with appropriate period</li>
<li>Path-specific constraints when needed</li>
</ul>
</li>
<li>
<p><strong>Reset Path Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Asynchronous reset with synchronous release</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset logic</span>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Normal operation</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Standard asynchronous reset pattern</li>
<li>Clear reset path for all registers</li>
<li>Synchronous release for stability</li>
<li>Reset tree optimization through synthesis</li>
<li>Predictable reset behavior</li>
</ul>
</li>
<li>
<p><strong>Timing Analysis Approach</strong>:</p>
<ul>
<li>
<p><strong>Static Timing Analysis (STA)</strong>:</p>
<ul>
<li>Path-based analysis for worst-case scenarios</li>
<li>Setup time verification for maximum path delay</li>
<li>Hold time verification for minimum path delay</li>
<li>Clock-to-output timing for interface signals</li>
<li>Input-to-clock timing for external interfaces</li>
</ul>
</li>
<li>
<p><strong>Critical Path Analysis</strong>:</p>
<ul>
<li>Identification of longest delay paths</li>
<li>Focused optimization for critical paths</li>
<li>Margin assessment for implementation variables</li>
<li>Technology-specific timing consideration</li>
<li>Corner case analysis</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Considerations</strong>:</p>
<ul>
<li>Single clock domain eliminates crossing issues</li>
<li>Consistent clock distribution network</li>
<li>Minimized clock skew through proper constraints</li>
<li>Global clock usage for optimal distribution</li>
<li>Avoidance of derived or gated clocks</li>
</ul>
</li>
<li>
<p><strong>Implementation Margin Strategy</strong>:</p>
<ul>
<li>Target timing closure at 120-130% of required frequency</li>
<li>Accommodation for implementation variables</li>
<li>Margin for temperature and voltage variation</li>
<li>Allowance for tool and process differences</li>
<li>Robust operation across conditions</li>
</ul>
</li>
<li>
<p><strong>Placement and Routing Considerations</strong>:</p>
<ul>
<li>Logical grouping of related logic</li>
<li>Minimized interconnect delays</li>
<li>Balanced resource utilization</li>
<li>Area constraints for critical components</li>
<li>Floorplanning guidance for complex implementations</li>
</ul>
</li>
</ol>
<p>These timing closure strategies create a robust implementation foundation that enables reliable operation across various FPGA platforms and operating conditions. The approach emphasizes clear timing boundaries, balanced logic complexity, and appropriate margins for variability.</p>
<h4 id="resource-sharing-approaches">Resource Sharing Approaches</h4>
<p>The technical analysis system implements strategic resource sharing approaches to optimize FPGA utilization while maintaining performance and functionality. These approaches balance sharing opportunities with parallel processing requirements to create an efficient implementation.</p>
<p>Key resource sharing approaches include:</p>
<ol>
<li>
<p><strong>Shared Price Memory</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Single price memory module shared by indicators</span>
price_memory mem14 (
    <span class="hljs-comment">// Connections for module access</span>
);

<span class="hljs-comment">// Common signals derived from shared memory</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);
<span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] oldest_price;  <span class="hljs-comment">// From memory to both modules</span>
</div></code></pre>
<ul>
<li>Central price history storage</li>
<li>Eliminates duplicate memory structures</li>
<li>Common access for both indicator calculations</li>
<li>Consistent data view across modules</li>
<li>Efficient memory resource utilization</li>
</ul>
</li>
<li>
<p><strong>Dedicated Calculation Engines</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Independent calculation modules</span>
moving_average_fsm ma14 (
    <span class="hljs-comment">// Connections for MA calculation</span>
);

rsi_inc rsi14 (
    <span class="hljs-comment">// Connections for RSI calculation</span>
);
</div></code></pre>
<ul>
<li>Separate processing modules for different indicators</li>
<li>Independent state machines and control logic</li>
<li>Parallel calculation for maximum throughput</li>
<li>Optimized implementation for each algorithm</li>
<li>Clear functional separation</li>
</ul>
</li>
<li>
<p><strong>Input Path Sharing</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Common input path for all modules</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_in,     <span class="hljs-comment">// Top-level input</span>
<span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_price,           <span class="hljs-comment">// Top-level strobe</span>

<span class="hljs-comment">// Direct connection to multiple modules</span>
price_memory mem14 (
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-variable">.wr_en</span>(new_price),
    <span class="hljs-comment">// Other connections</span>
);

moving_average_fsm ma14 (
    <span class="hljs-variable">.new_price</span>(price_in),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Single input interface at system boundary</li>
<li>Direct distribution to relevant modules</li>
<li>No input buffering or replication</li>
<li>Consistent timing for all components</li>
<li>Simplified input handling</li>
</ul>
</li>
<li>
<p><strong>Control Signal Distribution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Derived control signals distributed to modules</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

<span class="hljs-comment">// Signal drives multiple modules</span>
moving_average_fsm ma14 (
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);

rsi_inc rsi14 (
    <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Common triggering conditions</li>
<li>Centralized condition evaluation</li>
<li>Distributed control to multiple modules</li>
<li>Synchronized operation</li>
<li>Reduced control logic duplication</li>
</ul>
</li>
<li>
<p><strong>Module-Specific Resource Allocation</strong>:</p>
<ul>
<li>
<p><strong>Arithmetic Resources</strong>:</p>
<ul>
<li>Dedicated arithmetic units for each indicator</li>
<li>Independent accumulators and registers</li>
<li>Parallel calculation capability</li>
<li>Optimized implementation for each algorithm</li>
<li>Clear performance isolation</li>
</ul>
</li>
<li>
<p><strong>Memory Resources</strong>:</p>
<ul>
<li>Shared price history buffer</li>
<li>Dedicated calculation state registers</li>
<li>Optimized register width for each application</li>
<li>Efficient FPGA memory utilization</li>
<li>Balance between sharing and parallelism</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Resource Sharing Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Resource Type</th>
<th>Sharing Approach</th>
<th>Rationale</th>
</tr>
</thead>
<tbody>
<tr>
<td>Price Memory</td>
<td>Fully Shared</td>
<td>Common data, single source of truth</td>
</tr>
<tr>
<td>Calculation Logic</td>
<td>Dedicated</td>
<td>Different algorithms, parallel processing</td>
</tr>
<tr>
<td>Input Interface</td>
<td>Shared Distribution</td>
<td>Common external interface, multiple users</td>
</tr>
<tr>
<td>Control Generation</td>
<td>Centralized, Distributed</td>
<td>Common trigger conditions, separate control</td>
</tr>
<tr>
<td>State Machines</td>
<td>Dedicated</td>
<td>Independent operation, different requirements</td>
</tr>
<tr>
<td>Output Generation</td>
<td>Dedicated</td>
<td>Separate results, parallel generation</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Alternative Approaches Considered</strong>:</p>
<ul>
<li>
<p><strong>Shared Arithmetic Units</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Not implemented:</span>
<span class="hljs-keyword">module</span> shared_arithmetic_unit (
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> select,  <span class="hljs-comment">// 0: MA, 1: RSI</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] operand_a,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] operand_b,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> operation,  <span class="hljs-comment">// 0: add, 1: subtract</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] result
);
</div></code></pre>
<ul>
<li>Rejected due to:
<ul>
<li>Increased control complexity</li>
<li>Sequential rather than parallel operation</li>
<li>Performance impact for minimal resource savings</li>
<li>More complex verification</li>
<li>Reduced scalability</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Time-Multiplexed Calculation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Not implemented:</span>
<span class="hljs-keyword">module</span> time_multiplexed_calculator (
    <span class="hljs-comment">// Ports</span>
);
    <span class="hljs-comment">// Sequential processing of indicators</span>
    <span class="hljs-keyword">case</span> (calc_phase)
        <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span> <span class="hljs-comment">// MA calculation</span>
           <span class="hljs-comment">// MA-specific logic</span>
        <span class="hljs-keyword">end</span>
        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span> <span class="hljs-comment">// RSI calculation</span>
           <span class="hljs-comment">// RSI-specific logic</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endcase</span>
</div></code></pre>
<ul>
<li>Rejected due to:
<ul>
<li>Reduced throughput</li>
<li>Increased latency</li>
<li>More complex control logic</li>
<li>Minimal resource savings</li>
<li>Compromised scalability</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>FPGA-Specific Considerations</strong>:</p>
<ul>
<li>
<p><strong>DSP Block Allocation</strong>:</p>
<ul>
<li>Available for critical arithmetic operations</li>
<li>Dedicated to specific calculation paths</li>
<li>Optimized usage for complex operations</li>
<li>Strategic placement for timing closure</li>
<li>Appropriate inferencing through coding style</li>
</ul>
</li>
<li>
<p><strong>Memory Resource Allocation</strong>:</p>
<ul>
<li>Small arrays implemented in distributed RAM</li>
<li>Larger buffers mapped to block RAM</li>
<li>Register usage optimized for width</li>
<li>Appropriate memory structure selection</li>
<li>Balance between performance and capacity</li>
</ul>
</li>
<li>
<p><strong>LUT Utilization Strategy</strong>:</p>
<ul>
<li>Optimized encoding for state machines</li>
<li>Efficient implementation of control logic</li>
<li>Balanced combinational depth</li>
<li>Appropriate sharing of common functions</li>
<li>Strategic partitioning for placement</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>These resource sharing approaches create an efficient implementation that balances parallelism with resource utilization. The strategy prioritizes performance for critical calculations while sharing common infrastructure, resulting in an optimized system design suitable for FPGA implementation.</p>
<h2 id="6-modules-documentation">6. Modules Documentation</h2>
<h3 id="moving-average-system">Moving Average System</h3>
<h4 id="memory-module-details">Memory Module Details</h4>
<p>The Memory module implements a specialized FIFO buffer for storing price history used in the moving average calculation. This module manages the sliding window of price data, providing both storage and access functionality tailored to the requirements of technical analysis indicators.</p>
<p><strong>Module Declaration:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> memory (
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,               <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,               <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] new_price,  <span class="hljs-comment">// Incoming new price</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> write_enable,      <span class="hljs-comment">// Enables writing to memory</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Provides the oldest price for rolling sum</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> memory_full,      <span class="hljs-comment">// Becomes HIGH when FIFO is full</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">319</span>:<span class="hljs-number">0</span>] prices_flat, <span class="hljs-comment">// Flattened 10-price array (debugging)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] fifo_data_count <span class="hljs-comment">// Tracks number of stored prices</span>
);
</div></code></pre>
<p><strong>Internal Structure:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] prices[<span class="hljs-number">9</span>:<span class="hljs-number">0</span>]; <span class="hljs-comment">// FIFO Memory (10 prices)</span>
<span class="hljs-keyword">integer</span> i;
    
<span class="hljs-keyword">assign</span> memory_full = (fifo_data_count &gt;= <span class="hljs-number">10</span>);
</div></code></pre>
<p>The module contains:</p>
<ul>
<li>A 10-element array of 32-bit registers for price storage</li>
<li>An integer counter for loops</li>
<li>A memory_full flag derived from the fill level</li>
<li>A flattened output array for debugging purposes</li>
<li>Counters and pointers for memory management</li>
</ul>
<p><strong>Operational Flow:</strong></p>
<ol>
<li><strong>Reset Operation:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
        prices[i] &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span>
    fifo_data_count &lt;= <span class="hljs-number">0</span>;
    oldest_price &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Clears all price registers to zero</li>
<li>Resets the FIFO counter to zero</li>
<li>Initializes the oldest price output to zero</li>
<li>Creates a known starting state</li>
</ul>
<ol start="2">
<li><strong>Write Operation:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (write_enable) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// FIFO Shift: Remove oldest price, add new price</span>
    oldest_price &lt;= prices[<span class="hljs-number">0</span>];  
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
        prices[i] &lt;= prices[i + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">end</span>
    prices[<span class="hljs-number">9</span>] &lt;= new_price;

    <span class="hljs-comment">// Flattened Array for Debugging</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
        prices_flat[i * <span class="hljs-number">32</span> +: <span class="hljs-number">32</span>] &lt;= prices[i];
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// Update FIFO Count</span>
    <span class="hljs-keyword">if</span> (fifo_data_count &lt; <span class="hljs-number">10</span>)
        fifo_data_count &lt;= fifo_data_count + <span class="hljs-number">1</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Captures the oldest price (at index 0)</li>
<li>Shifts all prices one position toward index 0</li>
<li>Stores the new price at the highest index (9)</li>
<li>Updates the flattened debug array</li>
<li>Increments the counter if not full</li>
</ul>
<p><strong>Implementation Details:</strong></p>
<ol>
<li><strong>FIFO Mechanism:</strong></li>
</ol>
<ul>
<li>Implements a shift register approach rather than a circular buffer</li>
<li>All elements shift on each write operation</li>
<li>Oldest element is always at index 0</li>
<li>Newest element is always at index 9</li>
<li>Fill level tracked by explicit counter</li>
</ul>
<ol start="2">
<li><strong>Memory Full Detection:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">assign</span> memory_full = (fifo_data_count &gt;= <span class="hljs-number">10</span>);
</div></code></pre>
<ul>
<li>Becomes true when 10 or more prices are stored</li>
<li>Indicates sufficient data for moving average calculation</li>
<li>Used as a trigger for downstream processing</li>
<li>Remains true during steady-state operation</li>
<li>Provides synchronization point for system</li>
</ul>
<ol start="3">
<li><strong>Debug Interface:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">319</span>:<span class="hljs-number">0</span>] prices_flat; <span class="hljs-comment">// Flattened 10-price array</span>
</div></code></pre>
<ul>
<li>Concatenates all 10 price registers into a single vector</li>
<li>Facilitates debugging and visualization</li>
<li>Provides complete visibility into price history</li>
<li>Updated synchronously with price array</li>
<li>32 bits  10 elements = 320 bits total width</li>
</ul>
<ol start="4">
<li><strong>Capacity Management:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (fifo_data_count &lt; <span class="hljs-number">10</span>)
    fifo_data_count &lt;= fifo_data_count + <span class="hljs-number">1</span>;
</div></code></pre>
<ul>
<li>Counter tracks valid entries in the FIFO</li>
<li>Stops incrementing when capacity is reached</li>
<li>Provides accurate fill level information</li>
<li>Used to derive full status flag</li>
<li>Initialized to zero on reset</li>
</ul>
<ol start="5">
<li><strong>Interface Timing:</strong></li>
</ol>
<ul>
<li>Write operations occur on positive clock edge when write_enable is high</li>
<li>oldest_price updates one cycle after write_enable assertion</li>
<li>memory_full signal is combinationally derived from counter</li>
<li>Write latency is one clock cycle from enable to completion</li>
<li>Read access is continuous (asynchronous read port)</li>
</ul>
<p><strong>Operational Characteristics:</strong></p>
<ol>
<li><strong>Filling Phase:</strong></li>
</ol>
<ul>
<li>FIFO initially empty after reset</li>
<li>Each write increments the counter</li>
<li>memory_full remains false until 10 prices stored</li>
<li>Partial data available but insufficient for calculation</li>
<li>Sequential filling of array from lowest to highest index</li>
</ul>
<ol start="2">
<li><strong>Steady State:</strong></li>
</ol>
<ul>
<li>FIFO contains 10 valid prices</li>
<li>Counter remains at 10</li>
<li>memory_full remains true</li>
<li>Each write shifts out oldest price</li>
<li>Maintains constant window size</li>
</ul>
<p><strong>Usage Considerations:</strong></p>
<ol>
<li><strong>Performance:</strong></li>
</ol>
<ul>
<li>Can accept one new price per clock cycle</li>
<li>Shift operation completes in a single cycle</li>
<li>No stall cycles or backpressure</li>
<li>Deterministic timing for all operations</li>
<li>Suitable for high-throughput applications</li>
</ul>
<ol start="2">
<li><strong>Resource Utilization:</strong></li>
</ol>
<ul>
<li>10  32-bit registers for price storage (320 bits)</li>
<li>4-bit counter for fill level</li>
<li>32-bit register for oldest_price output</li>
<li>320-bit register for prices_flat (debug)</li>
<li>Additional control logic for shifting and counting</li>
</ul>
<ol start="3">
<li><strong>Integration Requirements:</strong></li>
</ol>
<ul>
<li>write_enable should be asserted for exactly one cycle per price</li>
<li>new_price must be stable during write_enable assertion</li>
<li>External reset should be held for multiple cycles</li>
<li>No protection against write to full buffer (by design)</li>
<li>External logic should monitor memory_full for calculation triggering</li>
</ul>
<p>The Memory module provides the foundation for the moving average calculation, maintaining the sliding window of price data with simple, efficient operations tailored to the specific requirements of technical analysis indicators.</p>
<h4 id="moving-average-fsm-implementation">Moving Average FSM Implementation</h4>
<p>The Moving Average FSM module implements the control logic and arithmetic operations for calculating a 20-period simple moving average. This module employs a finite state machine approach with optimized calculation methods to efficiently compute the moving average as new price data arrives.</p>
<p><strong>Module Declaration:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,    <span class="hljs-comment">// Window size for moving average</span>
    <span class="hljs-keyword">parameter</span> DW     = <span class="hljs-number">16</span>     <span class="hljs-comment">// Data width for prices</span>
)(
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>           clk,        <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>           rst,        <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>           start,      <span class="hljs-comment">// Start calculation signal</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]  new_price,  <span class="hljs-comment">// New price input</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]  oldest_price, <span class="hljs-comment">// Oldest price from FIFO</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]    moving_avg, <span class="hljs-comment">// Calculated moving average</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>            done        <span class="hljs-comment">// Calculation complete signal</span>
);
</div></code></pre>
<p><strong>Internal Structure:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 64-bit sum for overflow prevention</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]  st = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 2-bit state register for FSM</span>
</div></code></pre>
<p>The module contains:</p>
<ul>
<li>A 64-bit sum register for price accumulation</li>
<li>A 2-bit state register for the finite state machine</li>
<li>Parameterized width and window size</li>
<li>Output registers for results and status</li>
</ul>
<p><strong>Finite State Machine:</strong></p>
<p>The FSM consists of three states that control the calculation sequence:</p>
<ol>
<li>
<p><strong>State 0: IDLE</strong></p>
<ul>
<li>Default state after reset</li>
<li>Waits for the start signal</li>
<li>No operations performed in this state</li>
<li>Transitions to CALCULATE when start is asserted</li>
</ul>
</li>
<li>
<p><strong>State 1: CALCULATE</strong></p>
<ul>
<li>Updates the running sum</li>
<li>Calculates the moving average</li>
<li>Sets the done flag</li>
<li>Transitions to DONE state</li>
</ul>
</li>
<li>
<p><strong>State 2: DONE</strong></p>
<ul>
<li>Maintains calculation results</li>
<li>Clears the done flag</li>
<li>Returns to IDLE state</li>
<li>Prepares for next calculation cycle</li>
</ul>
</li>
</ol>
<p>The FSM implementation:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        sum &lt;= <span class="hljs-number">0</span>; moving_avg &lt;= <span class="hljs-number">0</span>; done &lt;= <span class="hljs-number">0</span>; st &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (st)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
                sum &lt;= sum + new_price - oldest_price;
                moving_avg &lt;= sum / WINDOW;
                done &lt;= <span class="hljs-number">1</span>;
                st &lt;= <span class="hljs-number">2</span>;
            <span class="hljs-keyword">end</span>
            <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">0</span>;
                st &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>Calculation Algorithm:</strong></p>
<p>The module implements an efficient sliding window algorithm for moving average calculation:</p>
<pre class="hljs"><code><div>sum &lt;= sum + new_price - oldest_price;
moving_avg &lt;= sum / WINDOW;
</div></code></pre>
<p>Key algorithmic features:</p>
<ul>
<li>Maintains a running sum rather than recalculating from scratch</li>
<li>Adds new price and subtracts oldest price to update sum</li>
<li>Divides by window size to calculate the average</li>
<li>Achieves O(1) complexity regardless of window size</li>
<li>Provides significant performance advantage for larger windows</li>
</ul>
<p><strong>Implementation Details:</strong></p>
<ol>
<li>
<p><strong>Sum Register Sizing:</strong></p>
<ul>
<li>64-bit width provides substantial overflow protection</li>
<li>For 16-bit prices and 20-period window:
<ul>
<li>Maximum possible sum: 20  (2^16 - 1)  1.3 million</li>
<li>64-bit register capacity: 2^64  18.4 quintillion</li>
</ul>
</li>
<li>Prevents overflow in all practical scenarios</li>
<li>Simplifies implementation by eliminating overflow handling</li>
<li>Provides margin for future extensions</li>
</ul>
</li>
<li>
<p><strong>Division Implementation:</strong></p>
<ul>
<li>Integer division by the window size parameter</li>
<li>Result stored in 32-bit output register</li>
<li>Truncates fractional results (rounds toward zero)</li>
<li>Sufficient precision for trading applications</li>
<li>Potential optimization for power-of-2 window sizes</li>
</ul>
</li>
<li>
<p><strong>State Transition Timing:</strong></p>
<ul>
<li>Transitions occur on positive clock edge</li>
<li>Single-cycle state progression</li>
<li>Complete calculation cycle requires 3 clock cycles:
<ul>
<li>Cycle 1: IDLE  CALCULATE</li>
<li>Cycle 2: CALCULATE  DONE</li>
<li>Cycle 3: DONE  IDLE</li>
</ul>
</li>
<li>Predictable latency for all operations</li>
<li>Clean timing boundaries between calculations</li>
</ul>
</li>
<li>
<p><strong>Interface Signaling:</strong></p>
<ul>
<li>start signal triggers calculation</li>
<li>done signal pulses for one cycle when calculation completes</li>
<li>All inputs sampled on state transition to CALCULATE</li>
<li>Outputs updated in the CALCULATE state</li>
<li>Clear handshaking protocol for system integration</li>
</ul>
</li>
<li>
<p><strong>Reset Behavior:</strong></p>
<ul>
<li>Asynchronous reset for immediate initialization</li>
<li>Clears sum to prevent incorrect calculations</li>
<li>Resets moving_avg output to zero</li>
<li>Clears done flag to prevent false signals</li>
<li>Returns to IDLE state for clean startup</li>
</ul>
</li>
</ol>
<p><strong>Operational Characteristics:</strong></p>
<ol>
<li>
<p><strong>Initialization Phase:</strong></p>
<ul>
<li>Initial sum value is zero</li>
<li>First N calculations may produce incorrect results</li>
<li>Typically used only after buffer is full</li>
<li>External logic should manage initial filling</li>
<li>Start signal typically derived from buffer full condition</li>
</ul>
</li>
<li>
<p><strong>Steady State Operation:</strong></p>
<ul>
<li>Continuous updating as new prices arrive</li>
<li>Consistent timing for all calculations</li>
<li>Predictable result generation</li>
<li>One-cycle pulse for done signal</li>
<li>Clean transition back to IDLE for next cycle</li>
</ul>
</li>
</ol>
<p><strong>Implementation Optimization:</strong></p>
<ol>
<li>
<p><strong>Performance Optimization:</strong></p>
<ul>
<li>Single-cycle calculation for maximum throughput</li>
<li>O(1) algorithm complexity regardless of window size</li>
<li>Minimal state machine overhead</li>
<li>Direct calculation without intermediate steps</li>
<li>Maximum throughput of one calculation per 3 clock cycles</li>
</ul>
</li>
<li>
<p><strong>Resource Optimization:</strong></p>
<ul>
<li>Minimal register usage for state machine</li>
<li>Efficient sliding window algorithm</li>
<li>Appropriate register sizing for required precision</li>
<li>Simple control logic with clear states</li>
<li>Division optimization through synthesis</li>
</ul>
</li>
<li>
<p><strong>Potential Enhancements:</strong></p>
<ul>
<li>Fixed-point implementation for decimal precision</li>
<li>Optimized division for power-of-2 window sizes</li>
<li>Pipelined calculation for complex operations</li>
<li>Parameterized arithmetic precision</li>
<li>Additional status flags for system coordination</li>
</ul>
</li>
</ol>
<p><strong>Usage Considerations:</strong></p>
<ol>
<li>
<p><strong>Integration Requirements:</strong></p>
<ul>
<li>start signal should be asserted for one cycle to begin calculation</li>
<li>new_price and oldest_price must be valid when start is asserted</li>
<li>External logic should monitor done signal for result validity</li>
<li>Typically triggered when memory buffer is full</li>
<li>Results valid when done signal is asserted</li>
</ul>
</li>
<li>
<p><strong>Timing Relationships:</strong></p>
<ul>
<li>Calculation latency: 2 clock cycles from start to done</li>
<li>Result validity: moving_avg stable when done is asserted</li>
<li>Minimum calculation interval: 3 clock cycles</li>
<li>start signal should not be asserted during active calculation</li>
<li>Reset should be held for multiple clock cycles</li>
</ul>
</li>
<li>
<p><strong>Parameter Configuration:</strong></p>
<ul>
<li>WINDOW parameter sets divisor for average calculation</li>
<li>Typical values: 10, 20, 50, 200 (common in technical analysis)</li>
<li>DW parameter sets input data width</li>
<li>Must match price data representation in system</li>
<li>Default configuration suitable for most applications</li>
</ul>
</li>
</ol>
<p>The Moving Average FSM module provides an efficient, parameterized implementation of the simple moving average calculation, with a clean interface for system integration and optimized performance for hardware deployment.</p>
<p><strong>1. IDLE State (3'b000)</strong>:</p>
<ul>
<li>Initial state after reset and default state between calculations</li>
<li>Waits for the <code>start</code> signal to begin a new calculation cycle</li>
<li>Initializes counters and accumulators when transitioning to FILL_FIFO</li>
<li>Handles reset and startup conditions</li>
<li>Transition: IDLE  FILL_FIFO when <code>start</code> is asserted</li>
</ul>
<pre class="hljs"><code><div>IDLE: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
        gain_sum &lt;= <span class="hljs-number">0</span>;
        loss_sum &lt;= <span class="hljs-number">0</span>;
        sample_cnt &lt;= <span class="hljs-number">0</span>;
        done &lt;= <span class="hljs-number">0</span>;
        state &lt;= FILL_FIFO;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>2. FILL_FIFO State (3'b001)</strong>:</p>
<ul>
<li>Manages loading price data into the FIFO buffer</li>
<li>Continues until the FIFO is full (contains sufficient price history)</li>
<li>Controls write operations to the price FIFO</li>
<li>Initiates the first read operation when the FIFO becomes full</li>
<li>Transition: FILL_FIFO  READ_INIT when FIFO becomes full</li>
</ul>
<pre class="hljs"><code><div>FILL_FIFO: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (new_price &amp;&amp; !fifo_full)
        fifo_wr_en &lt;= <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (fifo_full) <span class="hljs-keyword">begin</span>
        fifo_rd_en &lt;= <span class="hljs-number">1</span>;
        read_delay &lt;= <span class="hljs-number">1</span>;
        state &lt;= READ_INIT;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>3. READ_INIT State (3'b010)</strong>:</p>
<ul>
<li>Initializes the first price value for comparison</li>
<li>Handles the one-cycle delay in FIFO read operations</li>
<li>Captures the first price value from the FIFO</li>
<li>Prepares for the price comparison sequence</li>
<li>Transition: READ_INIT  COMPARE when first price is captured</li>
</ul>
<pre class="hljs"><code><div>READ_INIT: <span class="hljs-keyword">begin</span>
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (read_delay) <span class="hljs-keyword">begin</span>
        prev_price &lt;= price_out;
        read_delay &lt;= <span class="hljs-number">0</span>;
        state &lt;= COMPARE;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>4. COMPARE State (3'b100)</strong>:</p>
<ul>
<li>Determines whether to continue processing price data</li>
<li>Checks if all required samples have been processed</li>
<li>Initiates read operations for subsequent price values</li>
<li>Controls the flow of the comparison sequence</li>
<li>Transitions:
<ul>
<li>COMPARE  READ_WAIT if more samples need processing</li>
<li>COMPARE  DONE if all samples have been processed</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>COMPARE: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (sample_cnt &lt; <span class="hljs-number">19</span> &amp;&amp; !fifo_empty) <span class="hljs-keyword">begin</span>
        fifo_rd_en &lt;= <span class="hljs-number">1</span>;
        read_delay &lt;= <span class="hljs-number">1</span>;
        state &lt;= READ_WAIT;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        state &lt;= DONE;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>5. READ_WAIT State (3'b011)</strong>:</p>
<ul>
<li>Handles the core RSI calculation by comparing consecutive prices</li>
<li>Manages the one-cycle delay for FIFO read operations</li>
<li>Determines price changes and accumulates gains/losses</li>
<li>Updates counters and manages state variables</li>
<li>Transition: READ_WAIT  COMPARE after processing each price</li>
</ul>
<pre class="hljs"><code><div>READ_WAIT: <span class="hljs-keyword">begin</span>
    fifo_rd_en &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (read_delay) <span class="hljs-keyword">begin</span>
        curr_price &lt;= price_out;

        <span class="hljs-keyword">if</span> (price_out &gt; prev_price)
            gain_sum &lt;= gain_sum + (price_out - prev_price);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_out &lt; prev_price)
            loss_sum &lt;= loss_sum + (prev_price - price_out);

        prev_price &lt;= price_out;
        sample_cnt &lt;= sample_cnt + <span class="hljs-number">1</span>;
        read_delay &lt;= <span class="hljs-number">0</span>;
        state &lt;= COMPARE;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p><strong>6. DONE State (3'b101)</strong>:</p>
<ul>
<li>Calculates the final RSI value using the accumulated gains and losses</li>
<li>Handles the division operation with protection against division by zero</li>
<li>Sets the output RSI value in the 0-100 range</li>
<li>Signals calculation completion</li>
<li>Transition: DONE  IDLE to prepare for the next calculation cycle</li>
</ul>
<pre class="hljs"><code><div>DONE: <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> ((gain_sum + loss_sum) &gt; <span class="hljs-number">0</span>)
        rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
    <span class="hljs-keyword">else</span>
        rsi &lt;= <span class="hljs-number">0</span>;

    done &lt;= <span class="hljs-number">1</span>;
    state &lt;= IDLE;
<span class="hljs-keyword">end</span>
</div></code></pre>
<h2 id="6-modules-documentation">6. Modules Documentation</h2>
<h3 id="moving-average-system">Moving Average System</h3>
<p>The Moving Average system consists of specialized hardware components designed to efficiently calculate the Simple Moving Average (SMA) of price data streams in real-time. The implementation prioritizes computational efficiency, resource utilization, and reliable operation.</p>
<h4 id="memory-module-details">Memory Module Details</h4>
<p>The Memory module implements a specialized FIFO buffer for storing price history used in moving average calculations:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> memory (
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,               <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,               <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] new_price,  <span class="hljs-comment">// Incoming new price</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> write_enable,      <span class="hljs-comment">// Enables writing to memory</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Provides the oldest price for rolling sum</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> memory_full,      <span class="hljs-comment">// Becomes HIGH when FIFO is full</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">319</span>:<span class="hljs-number">0</span>] prices_flat, <span class="hljs-comment">// Flattened 10-price array (debugging)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] fifo_data_count <span class="hljs-comment">// Tracks number of stored prices</span>
);
</div></code></pre>
<p>The module contains:</p>
<ul>
<li>A 10-element array of 32-bit registers for price storage</li>
<li>A counter to track the number of valid entries</li>
<li>Logic to shift prices as new values arrive</li>
<li>Status signals indicating buffer state</li>
<li>Debugging output showing all stored prices</li>
</ul>
<p>The memory module operates as a shift register, where:</p>
<ol>
<li>On reset, all price registers and counters are cleared</li>
<li>When <code>write_enable</code> is asserted, the newest price is stored</li>
<li>All existing prices shift one position (prices[i] = prices[i+1])</li>
<li>The oldest price is output before being discarded</li>
<li>The FIFO counter is incremented until full (count == 10)</li>
</ol>
<p>The <code>memory_full</code> signal is critical for system coordination, as it triggers the moving average calculation once sufficient data is available.</p>
<h4 id="moving-average-fsm-implementation">Moving Average FSM Implementation</h4>
<p>The Moving Average FSM module implements an efficient state machine for calculating the moving average:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm (
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,                <span class="hljs-comment">// System clock</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,                <span class="hljs-comment">// Asynchronous reset</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start,              <span class="hljs-comment">// Signal to begin calculation</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] new_price,   <span class="hljs-comment">// New price data</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] oldest_price, <span class="hljs-comment">// Oldest price from FIFO</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,  <span class="hljs-comment">// Calculated moving average</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done                <span class="hljs-comment">// Calculation complete flag</span>
);
</div></code></pre>
<p>This module employs a sliding window algorithm with O(1) complexity:</p>
<pre class="hljs"><code><div>sum &lt;= sum + new_price - oldest_price;
moving_avg &lt;= sum / WINDOW;
</div></code></pre>
<p>Key features include:</p>
<ul>
<li>64-bit sum register to prevent overflow during accumulation</li>
<li>3-state FSM (IDLE, CALCULATE, DONE) for control flow</li>
<li>Single-cycle calculation of the moving average</li>
<li>Clean handshaking with other system components</li>
</ul>
<p>The FSM state transitions follow this pattern:</p>
<ol>
<li>IDLE (0): Waits for the <code>start</code> signal</li>
<li>CALCULATE (1): Updates sum, calculates average, asserts <code>done</code></li>
<li>DONE (2): Clears the <code>done</code> signal, returns to IDLE</li>
</ol>
<p>This implementation is optimized for FPGA deployment, with careful consideration of register sizing, state encoding, and timing relationships.</p>
<h4 id="port-descriptions-and-timing">Port Descriptions and Timing</h4>
<p>The Moving Average system follows strict timing relationships:</p>
<ul>
<li>All sequential logic operates on the positive clock edge</li>
<li>The <code>start</code> signal must be asserted for one clock cycle</li>
<li>The <code>done</code> signal pulses for exactly one clock cycle</li>
<li>Data inputs must be valid when <code>start</code> is asserted</li>
<li>Results are valid when <code>done</code> is asserted</li>
</ul>
<p>The module interfaces with the rest of the system through:</p>
<ul>
<li><code>clk</code> and <code>rst</code>: Standard system signals</li>
<li><code>start</code>: Calculation trigger (typically driven by <code>memory_full</code>)</li>
<li><code>new_price</code> and <code>oldest_price</code>: Data inputs for calculation</li>
<li><code>moving_avg</code>: Calculation result</li>
<li><code>done</code>: Completion indicator</li>
</ul>
<p>Signal timing diagram:</p>
<pre class="hljs"><code><div>clk      _||_||_||_||_||_||_||_||_
start    ___||_________________________
new_pri  XXXXX|VALID|XXXXXXXXXXXXXXXXXXXXX
old_pri  XXXXX|VALID|XXXXXXXXXXXXXXXXXXXXX
state    0|0|0|1|2|0|0|0
done     _______||_______________________
mov_avg  XXXXXXXXXXXXX|VALID|XXXXXXXXXXXXX
</div></code></pre>
<p>This clean timing interface facilitates integration with the larger trading system.</p>
<h4 id="internal-register-architecture">Internal Register Architecture</h4>
<p>The internal registers of the Moving Average FSM are carefully sized for their specific functions:</p>
<ol>
<li>
<p><strong>Sum Register (64-bit)</strong></p>
<ul>
<li>Accumulates price values for the moving average calculation</li>
<li>Extended width prevents overflow during accumulation</li>
<li>For 32-bit prices and a 10-period window, the theoretical maximum sum is:
<ul>
<li>10  (2 - 1)  43 billion</li>
<li>Requires approximately 36 bits</li>
</ul>
</li>
<li>The 64-bit implementation provides substantial margin</li>
</ul>
</li>
<li>
<p><strong>State Register (2-bit)</strong></p>
<ul>
<li>Encodes the three FSM states (IDLE, CALCULATE, DONE)</li>
<li>Minimal width reduces resource utilization</li>
<li>Efficient encoding for state transitions</li>
</ul>
</li>
<li>
<p><strong>Moving Average Output (32-bit)</strong></p>
<ul>
<li>Stores the calculated moving average</li>
<li>Matches the price input width for consistency</li>
<li>Provides sufficient precision for the calculation result</li>
</ul>
</li>
</ol>
<p>This careful register sizing balances precision requirements with resource utilization.</p>
<h4 id="state-machine-design">State Machine Design</h4>
<p>The Moving Average FSM implements a straightforward 3-state machine:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        sum &lt;= <span class="hljs-number">0</span>; moving_avg &lt;= <span class="hljs-number">0</span>; done &lt;= <span class="hljs-number">0</span>; st &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (st)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (start) st &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>
                sum &lt;= sum + new_price - oldest_price;
                moving_avg &lt;= sum / WINDOW;
                done &lt;= <span class="hljs-number">1</span>;
                st &lt;= <span class="hljs-number">2</span>;
            <span class="hljs-keyword">end</span>
            <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">0</span>;
                st &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>This design provides:</p>
<ul>
<li>Clear state boundaries and transitions</li>
<li>Predictable control flow</li>
<li>Minimal state overhead</li>
<li>Deterministic operation</li>
<li>Efficient hardware implementation</li>
</ul>
<p>The state encoding uses a binary counter pattern (0,1,2) for simplicity and efficiency.</p>
<h4 id="signal-timing-relationships">Signal Timing Relationships</h4>
<p>Critical timing relationships in the Moving Average FSM include:</p>
<ol>
<li>
<p><strong>Input Sampling</strong></p>
<ul>
<li><code>new_price</code> and <code>oldest_price</code> are sampled when <code>start</code> is asserted</li>
<li>Must be valid during the clock cycle when state transitions to CALCULATE</li>
</ul>
</li>
<li>
<p><strong>Calculation Timing</strong></p>
<ul>
<li>Sum update and division occur in the same clock cycle</li>
<li>One-cycle latency from input to calculation completion</li>
</ul>
</li>
<li>
<p><strong>Output Validity</strong></p>
<ul>
<li><code>moving_avg</code> becomes valid during the CALCULATE state</li>
<li>Remains stable until the next calculation</li>
</ul>
</li>
<li>
<p><strong>Done Signaling</strong></p>
<ul>
<li><code>done</code> asserts for exactly one clock cycle</li>
<li>Timing aligns with the availability of valid results</li>
</ul>
</li>
</ol>
<p>These relationships ensure deterministic timing and reliable operation.</p>
<h4 id="module-constraints">Module Constraints</h4>
<p>The Moving Average module has several operational constraints:</p>
<ol>
<li>
<p><strong>Data Validity</strong></p>
<ul>
<li>Requires valid price data when <code>start</code> is asserted</li>
<li>Cannot operate on partial or empty data sets</li>
</ul>
</li>
<li>
<p><strong>Overflow Prevention</strong></p>
<ul>
<li>Sum register (64-bit) must not overflow</li>
<li>Maximum price value and window size must be considered</li>
<li>Current implementation supports 32-bit prices with typical window sizes</li>
</ul>
</li>
<li>
<p><strong>Timing Requirements</strong></p>
<ul>
<li>Maximum clock frequency depends on critical path (division operation)</li>
<li>Typical constraint: Fmax  100 MHz on modern FPGAs</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization</strong></p>
<ul>
<li>Register usage scales with data width and window size</li>
<li>Division operation may require DSP resources</li>
</ul>
</li>
</ol>
<p>These constraints should be considered when integrating the module into larger systems.</p>
<h4 id="integration-guidelines">Integration Guidelines</h4>
<p>When integrating the Moving Average module, follow these guidelines:</p>
<ol>
<li>
<p><strong>Clock and Reset</strong></p>
<ul>
<li>Provide stable clock with controlled skew</li>
<li>Assert reset for multiple clock cycles during initialization</li>
<li>Ensure synchronous deassertion of reset</li>
</ul>
</li>
<li>
<p><strong>Data Interfaces</strong></p>
<ul>
<li>Ensure <code>new_price</code> and <code>oldest_price</code> are valid when <code>start</code> is asserted</li>
<li>Respect the one-cycle <code>done</code> pulse for result validity</li>
</ul>
</li>
<li>
<p><strong>Parameter Customization</strong></p>
<ul>
<li>WINDOW parameter can be adjusted for different moving average periods</li>
<li>DW parameter should match the price data width in the system</li>
</ul>
</li>
<li>
<p><strong>System Integration</strong></p>
<ul>
<li>Connect <code>memory_full</code> signal to <code>start</code> input for proper triggering</li>
<li>Monitor <code>done</code> signal for result validity and synchronization</li>
</ul>
</li>
<li>
<p><strong>Verification</strong></p>
<ul>
<li>Test with representative price sequences</li>
<li>Verify correct operation at window boundaries</li>
<li>Confirm proper reset behavior</li>
</ul>
</li>
</ol>
<p>Following these guidelines ensures reliable integration and operation.</p>
<h3 id="rsi-calculator">RSI Calculator</h3>
<p>The RSI Calculator module implements a Relative Strength Index calculator designed for FPGA implementation. This module uses a finite state machine approach to efficiently compute the RSI indicator, which measures the speed and magnitude of price movements.</p>
<h4 id="price-fifo-module-details">Price FIFO Module Details</h4>
<p>The Price FIFO module implements a circular buffer for storing price history:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_fifo #(<span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">20</span>, WIDTH = <span class="hljs-number">16</span>) (
    <span class="hljs-keyword">input</span> clk,
    <span class="hljs-keyword">input</span> rst,
    <span class="hljs-keyword">input</span> wr_en,
    <span class="hljs-keyword">input</span> rd_en,
    <span class="hljs-keyword">input</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] din,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] dout,
    <span class="hljs-keyword">output</span> full,
    <span class="hljs-keyword">output</span> empty
);
</div></code></pre>
<p>Key features include:</p>
<ul>
<li>Parameterized depth and width for adaptability</li>
<li>Full and empty status flags</li>
<li>Write and read enable signals for control</li>
<li>Internal pointers for circular buffer management</li>
</ul>
<p>The module implements:</p>
<ul>
<li>Memory array: <code>reg [WIDTH-1:0] mem[0:DEPTH-1];</code></li>
<li>Write and read pointers: <code>reg [4:0] wr_ptr, rd_ptr;</code></li>
<li>Item counter: <code>reg [5:0] count;</code></li>
<li>Status signals: <code>assign full = (count == DEPTH);</code></li>
</ul>
<p>This efficient implementation supports the RSI calculation's need for sequential price history.</p>
<h4 id="rsi-fsm-module-implementation">RSI FSM Module Implementation</h4>
<p>The RSI FSM module implements a 6-state finite state machine to control the RSI calculation process:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> rsi_fsm (
    <span class="hljs-keyword">input</span> clk,
    <span class="hljs-keyword">input</span> rst,
    <span class="hljs-keyword">input</span> start,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_in,
    <span class="hljs-keyword">input</span> new_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi
);
</div></code></pre>
<p>The RSI calculation follows these steps:</p>
<ol>
<li>Store 20 consecutive price samples in the FIFO</li>
<li>Calculate price changes by comparing consecutive prices</li>
<li>Accumulate gains (price increases) and losses (price decreases)</li>
<li>Calculate RSI = 100 * gain_sum / (gain_sum + loss_sum)</li>
</ol>
<p>The module uses six states:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">localparam</span> IDLE      = <span class="hljs-number">3&#x27;b000</span>,
           FILL_FIFO = <span class="hljs-number">3&#x27;b001</span>,
           READ_INIT = <span class="hljs-number">3&#x27;b010</span>,
           READ_WAIT = <span class="hljs-number">3&#x27;b011</span>,
           COMPARE   = <span class="hljs-number">3&#x27;b100</span>,
           DONE      = <span class="hljs-number">3&#x27;b101</span>;
</div></code></pre>
<p>This state machine design enables efficient sequential processing of price data.</p>
<h4 id="state-machine-deep-dive">State Machine Deep Dive</h4>
<p>The RSI module uses a sophisticated state machine to manage the calculation process:</p>
<ol>
<li>
<p><strong>IDLE State (3'b000)</strong></p>
<ul>
<li>Default state after reset</li>
<li>Waits for the <code>start</code> signal</li>
<li>Initializes counters and accumulators when starting</li>
</ul>
</li>
<li>
<p><strong>FILL_FIFO State (3'b001)</strong></p>
<ul>
<li>Stores incoming prices in the FIFO buffer</li>
<li>Asserts <code>fifo_wr_en</code> when new prices arrive</li>
<li>Transitions to READ_INIT when FIFO is full</li>
</ul>
</li>
<li>
<p><strong>READ_INIT State (3'b010)</strong></p>
<ul>
<li>Initializes the first price from FIFO</li>
<li>Handles the one-cycle delay in FIFO read operations</li>
<li>Sets up the first comparison point</li>
</ul>
</li>
<li>
<p><strong>COMPARE State (3'b100)</strong></p>
<ul>
<li>Determines whether to continue processing</li>
<li>Initiates reading next price if needed</li>
<li>Transitions to DONE when all samples processed</li>
</ul>
</li>
<li>
<p><strong>READ_WAIT State (3'b011)</strong></p>
<ul>
<li>Compares consecutive prices to determine gains/losses</li>
<li>Updates gain_sum and loss_sum accumulators</li>
<li>Increments sample counter</li>
</ul>
</li>
<li>
<p><strong>DONE State (3'b101)</strong></p>
<ul>
<li>Calculates final RSI value</li>
<li>Handles division by zero protection</li>
<li>Asserts done signal and returns to IDLE</li>
</ul>
</li>
</ol>
<p>This state machine design ensures proper sequencing of operations with clear control flow.</p>
<h4 id="calculation-logic-details">Calculation Logic Details</h4>
<p>The RSI calculation logic focuses on accumulating gains and losses:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// In READ_WAIT state</span>
<span class="hljs-keyword">if</span> (price_out &gt; prev_price)
    gain_sum &lt;= gain_sum + (price_out - prev_price);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_out &lt; prev_price)
    loss_sum &lt;= loss_sum + (prev_price - price_out);
</div></code></pre>
<p>Key calculation features:</p>
<ul>
<li>32-bit accumulators for gain_sum and loss_sum</li>
<li>Conditional comparison for determining gains vs losses</li>
<li>Protection against division by zero in final calculation</li>
<li>8-bit output register for the 0-100 RSI range</li>
</ul>
<p>The final RSI formula is implemented as:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// In DONE state</span>
<span class="hljs-keyword">if</span> ((gain_sum + loss_sum) &gt; <span class="hljs-number">0</span>)
    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
<span class="hljs-keyword">else</span>
    rsi &lt;= <span class="hljs-number">0</span>;
</div></code></pre>
<p>This implementation balances accuracy with resource efficiency.</p>
<h4 id="timing-requirements">Timing Requirements</h4>
<p>The RSI calculator has specific timing requirements:</p>
<ol>
<li>
<p><strong>Input Timing</strong></p>
<ul>
<li><code>new_price</code> signal must be asserted for one clock cycle</li>
<li><code>price_in</code> must be valid when <code>new_price</code> is asserted</li>
<li><code>start</code> signal initiates calculation after FIFO is filled</li>
</ul>
</li>
<li>
<p><strong>FIFO Timing</strong></p>
<ul>
<li>One-cycle delay between read request and data availability</li>
<li>Managed through the <code>read_delay</code> flag</li>
</ul>
</li>
<li>
<p><strong>Processing Timing</strong></p>
<ul>
<li>Variable latency based on state machine progression</li>
<li>Typically 20+ clock cycles for complete calculation</li>
<li><code>done</code> signal pulses for one cycle when calculation completes</li>
</ul>
</li>
<li>
<p><strong>Output Timing</strong></p>
<ul>
<li>RSI value becomes valid when <code>done</code> is asserted</li>
<li>Remains stable until the next calculation</li>
</ul>
</li>
</ol>
<p>These timing relationships ensure proper operation in the larger system.</p>
<h4 id="resource-utilization-analysis">Resource Utilization Analysis</h4>
<p>The RSI calculator's resource utilization includes:</p>
<ol>
<li>
<p><strong>Register Usage</strong></p>
<ul>
<li>State register: 3 bits</li>
<li>FIFO control flags: 2 bits</li>
<li>Price registers: 2  16 bits</li>
<li>Gain/loss accumulators: 2  32 bits</li>
<li>Sample counter: 5 bits</li>
<li>RSI output: 8 bits</li>
<li>Total flip-flops: ~110</li>
</ul>
</li>
<li>
<p><strong>Memory Resources</strong></p>
<ul>
<li>FIFO buffer: 20 entries  16 bits = 320 bits</li>
<li>May use distributed RAM or block RAM depending on FPGA</li>
</ul>
</li>
<li>
<p><strong>Arithmetic Resources</strong></p>
<ul>
<li>Comparators for price evaluation</li>
<li>Adders for accumulation</li>
<li>Divider for final calculation (may use DSP resources)</li>
</ul>
</li>
<li>
<p><strong>Control Logic</strong></p>
<ul>
<li>FSM implementation</li>
<li>FIFO control signals</li>
<li>Handshaking logic</li>
</ul>
</li>
</ol>
<p>This analysis aids in resource planning and device selection.</p>
<h4 id="interface-specifications">Interface Specifications</h4>
<p>The RSI calculator interfaces with the rest of the system through:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">input</span> clk,                 <span class="hljs-comment">// System clock</span>
<span class="hljs-keyword">input</span> rst,                 <span class="hljs-comment">// Asynchronous reset</span>
<span class="hljs-keyword">input</span> start,               <span class="hljs-comment">// Signal to start calculation</span>
<span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_in,     <span class="hljs-comment">// New price data</span>
<span class="hljs-keyword">input</span> new_price,           <span class="hljs-comment">// Signal indicating valid price</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done,           <span class="hljs-comment">// Calculation complete signal</span>
<span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi       <span class="hljs-comment">// Calculated RSI value (0-100)</span>
</div></code></pre>
<p>Interface timing:</p>
<ul>
<li><code>new_price</code> must be asserted for one clock cycle per price</li>
<li><code>start</code> triggers the calculation after sufficient prices</li>
<li><code>done</code> pulses for one cycle when calculation completes</li>
<li><code>rsi</code> becomes valid when <code>done</code> is asserted</li>
</ul>
<p>These clear interfaces facilitate system integration.</p>
<h4 id="integration-considerations">Integration Considerations</h4>
<p>When integrating the RSI module, consider these factors:</p>
<ol>
<li>
<p><strong>Clock Domain</strong></p>
<ul>
<li>All components should share a common clock domain</li>
<li>Synchronization required if crossing clock domains</li>
</ul>
</li>
<li>
<p><strong>Reset Handling</strong></p>
<ul>
<li>Assert reset for multiple clock cycles during initialization</li>
<li>Ensure clean deassertion aligned with clock edge</li>
</ul>
</li>
<li>
<p><strong>Data Flow</strong></p>
<ul>
<li>Feed prices sequentially using <code>new_price</code> signal</li>
<li>Assert <code>start</code> after sufficient prices are available</li>
<li>Monitor <code>done</code> for result validity</li>
</ul>
</li>
<li>
<p><strong>Parameter Customization</strong></p>
<ul>
<li>DEPTH parameter can be adjusted for different RSI periods</li>
<li>WIDTH parameter should match price representation</li>
</ul>
</li>
<li>
<p><strong>System Integration</strong></p>
<ul>
<li>Coordinate with other indicators for consistent triggering</li>
<li>Consider signal buffering for high-fanout nets</li>
</ul>
</li>
</ol>
<p>Following these guidelines ensures successful integration into the larger trading system.</p>
<h3 id="trading-decision-system">Trading Decision System</h3>
<p>The Trading Decision module implements a configurable strategy engine that generates buy and sell signals based on technical indicators. It combines trend information from the moving average with momentum signals from the RSI.</p>
<h4 id="module-implementation-details">Module Implementation Details</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>
)(
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_now,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>  [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         sell
);
</div></code></pre>
<p>The module implements a mean reversion strategy with trend confirmation:</p>
<ul>
<li>Buy when price &gt; MA (uptrend) AND RSI &lt; threshold (oversold)</li>
<li>Sell when price &lt; MA (downtrend) AND RSI &gt; threshold (overbought)</li>
</ul>
<p>This combines trend information (price vs. MA) with momentum signals (RSI thresholds) for robust trade decisions.</p>
<h4 id="signal-processing-logic">Signal Processing Logic</h4>
<p>The core signal processing logic is elegantly simple:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        buy  &lt;= <span class="hljs-number">0</span>;
        sell &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
        buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
        sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>This implementation:</p>
<ul>
<li>Evaluates conditions on every clock cycle</li>
<li>Generates clean, registered output signals</li>
<li>Enforces mutual exclusivity between buy and sell</li>
<li>Provides one-cycle latency from condition to signal</li>
<li>Maintains synchronous behavior with the system clock</li>
</ul>
<p>The direct mapping from conditions to signals creates a clear and maintainable implementation.</p>
<h4 id="threshold-management">Threshold Management</h4>
<p>The module uses parameterized thresholds for strategy customization:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,  <span class="hljs-comment">// RSI buy threshold </span>
<span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>   <span class="hljs-comment">// RSI sell threshold</span>
</div></code></pre>
<p>These parameters enable:</p>
<ul>
<li>Customization without code changes</li>
<li>Threshold optimization for different markets</li>
<li>Strategy tuning based on risk preferences</li>
<li>Backtesting with different parameter sets</li>
</ul>
<p>The default values (30/70) represent standard technical analysis practice for RSI-based trading.</p>
<h4 id="signal-generation-implementation">Signal Generation Implementation</h4>
<p>The signal generation uses straightforward logical conditions:</p>
<pre class="hljs"><code><div>buy  &lt;= (price_now &gt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &lt; BUY_RSI_THR);
sell &lt;= (price_now &lt; moving_avg[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]) &amp;&amp; (rsi &gt; SELL_RSI_THR);
</div></code></pre>
<p>Key implementation features:</p>
<ul>
<li>Bit width matching between price and MA comparisons</li>
<li>Direct boolean operations for clear intent</li>
<li>Registered outputs for clean timing</li>
<li>Reset protection for initialization</li>
<li>Single-cycle evaluation of all conditions</li>
</ul>
<p>This implementation creates clear and predictable trading signals.</p>
<h4 id="timing-characteristics">Timing Characteristics</h4>
<p>The Trading Decision module has straightforward timing characteristics:</p>
<ol>
<li>
<p><strong>Input Sampling</strong></p>
<ul>
<li>All inputs sampled on positive clock edge</li>
<li>No explicit synchronization or buffering</li>
<li>Assumes inputs are synchronous to system clock</li>
</ul>
</li>
<li>
<p><strong>Signal Generation</strong></p>
<ul>
<li>One-cycle latency from input change to output update</li>
<li>Registered outputs for glitch-free operation</li>
<li>Immediate response to condition changes</li>
</ul>
</li>
<li>
<p><strong>Reset Timing</strong></p>
<ul>
<li>Asynchronous assertion for immediate signal clearing</li>
<li>Synchronous deassertion aligned with clock</li>
<li>Both signals initialize to inactive (0)</li>
</ul>
</li>
</ol>
<p>These clean timing characteristics simplify system integration.</p>
<h4 id="parameterization-details">Parameterization Details</h4>
<p>The Trading Decision module provides two key parameters:</p>
<ol>
<li>
<p><strong>BUY_RSI_THR (default: 30)</strong></p>
<ul>
<li>Controls the RSI threshold for buy signals</li>
<li>Lower values create more aggressive buying</li>
<li>Higher values create more conservative buying</li>
<li>Common ranges: 20-40 depending on market volatility</li>
</ul>
</li>
<li>
<p><strong>SELL_RSI_THR (default: 70)</strong></p>
<ul>
<li>Controls the RSI threshold for sell signals</li>
<li>Higher values create more aggressive selling</li>
<li>Lower values create more conservative selling</li>
<li>Common ranges: 60-80 depending on market volatility</li>
</ul>
</li>
</ol>
<p>These parameters can be overridden during module instantiation:</p>
<pre class="hljs"><code><div>trading_decision #(
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">25</span>),    <span class="hljs-comment">// More aggressive buying</span>
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">75</span>)    <span class="hljs-comment">// More aggressive selling</span>
) decision_module (
    <span class="hljs-comment">// Port connections</span>
);
</div></code></pre>
<p>This parameterization enables strategy customization without code changes.</p>
<h4 id="extension-options">Extension Options</h4>
<p>The Trading Decision module could be extended in several ways:</p>
<ol>
<li>
<p><strong>Multiple Indicator Support</strong></p>
<ul>
<li>Add inputs for additional technical indicators</li>
<li>Implement more complex decision logic</li>
<li>Support for MACD, Bollinger Bands, etc.</li>
</ul>
</li>
<li>
<p><strong>Signal Strength Indication</strong></p>
<ul>
<li>Add output signals indicating confidence level</li>
<li>Implement amplitude-based signal strength</li>
<li>Enable position sizing based on signal strength</li>
</ul>
</li>
<li>
<p><strong>Hysteresis Implementation</strong></p>
<ul>
<li>Add state tracking to prevent signal oscillation</li>
<li>Implement minimum holding periods</li>
<li>Reduce false signals in choppy markets</li>
</ul>
</li>
<li>
<p><strong>Adaptive Thresholds</strong></p>
<ul>
<li>Implement automatic threshold adjustment</li>
<li>Market regime detection and adaptation</li>
<li>Volatility-based parameter tuning</li>
</ul>
</li>
</ol>
<p>These extensions would enhance the module's functionality while maintaining its clean architecture.</p>
<h3 id="price-memory-fifo">Price Memory (FIFO)</h3>
<p>The Price Memory module implements a circular FIFO buffer for storing and managing price history, providing both the newest and oldest prices for technical indicator calculations.</p>
<h4 id="circular-buffer-implementation-details">Circular Buffer Implementation Details</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,    <span class="hljs-comment">// FIFO depth</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>        <span class="hljs-comment">// Data width</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk, rst, wr_en,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> full,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count
);

    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];  <span class="hljs-comment">// Memory array</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;       <span class="hljs-comment">// Write pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Read pointer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] item_count = <span class="hljs-number">0</span>;      <span class="hljs-comment">// Item counter</span>
</div></code></pre>
<p>The circular buffer design:</p>
<ul>
<li>Uses fixed-size memory array with parameterized depth</li>
<li>Maintains pointers to track read/write positions</li>
<li>Implements circular behavior through pointer wrapping</li>
<li>Tracks buffer fullness with an item counter</li>
<li>Provides status signals for system coordination</li>
</ul>
<p>This implementation efficiently manages the sliding window of prices needed for technical indicators.</p>
<h4 id="readwrite-pointer-management">Read/Write Pointer Management</h4>
<p>The circular buffer uses pointer management to implement FIFO behavior:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
        write_ptr &lt;= <span class="hljs-number">0</span>;
        read_ptr &lt;= <span class="hljs-number">0</span>;
        item_count &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Not full yet, just write and increment count</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            item_count &lt;= item_count + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Buffer full, overwrite oldest and advance both pointers</span>
            mem[write_ptr] &lt;= new_price;
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Key pointer management features:</p>
<ul>
<li>Initial filling phase increments only write pointer</li>
<li>Full buffer phase advances both pointers in lockstep</li>
<li>Modulo arithmetic creates circular behavior</li>
<li>Pointer reset on system reset</li>
<li>Clear differentiation between filling and full states</li>
</ul>
<p>This implementation efficiently maintains the proper sequential order of prices.</p>
<h4 id="fullempty-flag-generation">Full/Empty Flag Generation</h4>
<p>The FIFO uses status flags to coordinate with other system components:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">assign</span> full = (item_count == DEPTH);   <span class="hljs-comment">// FIFO is full</span>
<span class="hljs-keyword">assign</span> count = item_count;             <span class="hljs-comment">// Current item count</span>
</div></code></pre>
<p>These signals enable:</p>
<ul>
<li>Triggering calculations when sufficient data is available</li>
<li>Monitoring buffer state for system coordination</li>
<li>Preventing overflow conditions (not implemented since overwrite is desired)</li>
<li>Tracking filling progress during initialization</li>
</ul>
<p>The <code>full</code> flag is particularly important, as it triggers the start of technical indicator calculations.</p>
<h4 id="data-access-timing">Data Access Timing</h4>
<p>The Price Memory module implements specific data access timing:</p>
<ol>
<li>
<p><strong>Write Timing</strong></p>
<ul>
<li>Synchronous writes on positive clock edge</li>
<li>One-cycle write latency</li>
<li>Controlled by the <code>wr_en</code> signal</li>
<li>New prices written to <code>write_ptr</code> location</li>
</ul>
</li>
<li>
<p><strong>Read Timing</strong></p>
<ul>
<li>Asynchronous read of oldest price</li>
<li>Continuous output of the value at <code>read_ptr</code></li>
<li>No explicit read enable required</li>
<li>Immediate availability of the oldest price</li>
</ul>
</li>
<li>
<p><strong>Access Pattern</strong></p>
<ul>
<li>Single-ported memory array</li>
<li>No simultaneous access to the same location</li>
<li>Read pointer accesses oldest data</li>
<li>Write pointer accesses newest location</li>
</ul>
</li>
</ol>
<p>This access pattern supports the sliding window operation of technical indicators.</p>
<h4 id="reset-behavior">Reset Behavior</h4>
<p>The Price Memory implements clean reset behavior:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
    write_ptr &lt;= <span class="hljs-number">0</span>;
    read_ptr &lt;= <span class="hljs-number">0</span>;
    item_count &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Reset effects include:</p>
<ul>
<li>Initialization of both pointers to zero</li>
<li>Clearing of the item counter</li>
<li>Implicit invalidation of memory contents</li>
<li>Deactivation of status flags</li>
<li>Preparation for the initial filling phase</li>
</ul>
<p>This ensures deterministic behavior after system reset.</p>
<h4 id="parameterization-options">Parameterization Options</h4>
<p>The Price Memory module provides two key parameters:</p>
<ol>
<li>
<p><strong>DEPTH Parameter</strong></p>
<ul>
<li>Controls the size of the FIFO buffer</li>
<li>Default value of 14 supports RSI calculation</li>
<li>Can be adjusted for different indicator window sizes</li>
<li>Affects memory resource utilization</li>
</ul>
</li>
<li>
<p><strong>DW (Data Width) Parameter</strong></p>
<ul>
<li>Controls the bit width of price values</li>
<li>Default value of 16 supports typical price ranges</li>
<li>Can be adjusted for different precision requirements</li>
<li>Affects register resource utilization</li>
</ul>
</li>
</ol>
<p>These parameters enable customization for different applications without code changes.</p>
<h4 id="resource-efficiency-techniques">Resource Efficiency Techniques</h4>
<p>The Price Memory module employs several resource efficiency techniques:</p>
<ol>
<li>
<p><strong>Minimal Storage</strong></p>
<ul>
<li>Uses exactly DEPTH * DW bits for price storage</li>
<li>No redundant storage or buffering</li>
<li>Efficient memory utilization</li>
</ul>
</li>
<li>
<p><strong>Pointer Optimization</strong></p>
<ul>
<li>5-bit pointers sufficient for typical window sizes</li>
<li>Implicit pointer wrapping through modulo operation</li>
<li>Counter-based full detection instead of pointer comparison</li>
</ul>
</li>
<li>
<p><strong>Control Simplification</strong></p>
<ul>
<li>Single write enable signal</li>
<li>No explicit read control</li>
<li>Continuous output of oldest price</li>
<li>Minimal control logic overhead</li>
</ul>
</li>
<li>
<p><strong>Status Generation</strong></p>
<ul>
<li>Direct assignment from counter comparison</li>
<li>No complex flag logic</li>
<li>Clear relationship to buffer state</li>
</ul>
</li>
</ol>
<p>These techniques create an efficient implementation suitable for FPGA deployment.</p>
<h2 id="7-implementation-optimizations">7. Implementation Optimizations</h2>
<h3 id="sliding-window-optimization">Sliding Window Optimization</h3>
<h4 id="algorithm-details">Algorithm Details</h4>
<p>The moving average implementation uses a sliding window algorithm that maintains a running sum of the values within the window, updating it incrementally as new values arrive and old values leave:</p>
<pre class="hljs"><code><div>sum &lt;= sum + new_price - oldest_price;
moving_avg &lt;= sum / WINDOW;
</div></code></pre>
<p>This algorithm provides significant computational advantages:</p>
<ul>
<li>O(1) complexity regardless of window size</li>
<li>Minimal operations per update (one addition, one subtraction, one division)</li>
<li>Constant execution time for any window size</li>
<li>Efficient resource utilization</li>
</ul>
<p>The algorithm maintains state between updates, preserving the sum across calculations.</p>
<h4 id="computational-complexity-analysis">Computational Complexity Analysis</h4>
<p>The sliding window algorithm achieves optimal computational complexity:</p>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Time Complexity</th>
<th>Operations per Update</th>
</tr>
</thead>
<tbody>
<tr>
<td>Naive (recalculation)</td>
<td>O(n)</td>
<td>n additions + 1 division</td>
</tr>
<tr>
<td>Sliding Window</td>
<td>O(1)</td>
<td>1 addition + 1 subtraction + 1 division</td>
</tr>
</tbody>
</table>
<p>For a 20-sample window, this represents approximately a 10 reduction in operations.</p>
<p>Key complexity aspects:</p>
<ul>
<li>Independent of window size (constant time)</li>
<li>Fixed number of operations per update</li>
<li>Deterministic execution time</li>
<li>Minimal memory access (only newest and oldest values)</li>
</ul>
<p>This optimization is particularly valuable for larger window sizes and high-throughput systems.</p>
<h4 id="hardware-implementation-efficiency">Hardware Implementation Efficiency</h4>
<p>The sliding window algorithm translates efficiently to hardware:</p>
<ul>
<li>Simple datapath with minimal components</li>
<li>Clear register requirements (sum, inputs, output)</li>
<li>Straightforward control flow</li>
<li>Minimal multiplexing or routing complexity</li>
<li>Efficient ALU utilization</li>
</ul>
<p>Implementation advantages include:</p>
<ul>
<li>Reduced resource utilization</li>
<li>Lower power consumption</li>
<li>Better timing closure</li>
<li>Simplified verification</li>
<li>Enhanced scalability</li>
</ul>
<p>These efficiency gains make the approach ideal for FPGA implementation.</p>
<h4 id="comparison-with-alternative-approaches">Comparison with Alternative Approaches</h4>
<p>Several alternative approaches were considered:</p>
<ol>
<li>
<p><strong>Complete Recalculation</strong></p>
<ul>
<li><strong>Method</strong>: Recalculate the entire sum for each new price</li>
<li><strong>Advantages</strong>: No state maintenance, simpler control</li>
<li><strong>Disadvantages</strong>: O(n) complexity, higher resource usage, increased latency</li>
<li><strong>Assessment</strong>: Inefficient for hardware implementation</li>
</ul>
</li>
<li>
<p><strong>Shift Register with Parallel Adder</strong></p>
<ul>
<li><strong>Method</strong>: Maintain full history, use parallel adder tree</li>
<li><strong>Advantages</strong>: No separate memory module, direct access to all values</li>
<li><strong>Disadvantages</strong>: Complex routing, high register count, poor scaling</li>
<li><strong>Assessment</strong>: Inefficient for larger window sizes</li>
</ul>
</li>
<li>
<p><strong>Moving Average Filter (IIR)</strong></p>
<ul>
<li><strong>Method</strong>: Recursive filter with exponential weighting</li>
<li><strong>Advantages</strong>: Minimal storage, very simple computation</li>
<li><strong>Disadvantages</strong>: Not a true SMA, exponential weighting, initialization issues</li>
<li><strong>Assessment</strong>: Different mathematical properties than desired SMA</li>
</ul>
</li>
</ol>
<p>The sliding window approach provides the optimal balance of mathematical correctness, computational efficiency, and hardware implementation suitability.</p>
<h3 id="memory-usage-optimization">Memory Usage Optimization</h3>
<h4 id="circular-buffer-efficiency">Circular Buffer Efficiency</h4>
<p>The price memory implements a circular buffer using an efficient array-based approach:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];  <span class="hljs-comment">// Memory array</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Write pointer</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;         <span class="hljs-comment">// Read pointer</span>
</div></code></pre>
<p>Key efficiency aspects:</p>
<ul>
<li>Fixed-size allocation matching exactly the required window size</li>
<li>No dynamic memory management overhead</li>
<li>Efficient pointer arithmetic for addressing</li>
<li>Minimal control logic for buffer management</li>
<li>Clear overwrite semantics for sliding window operation</li>
</ul>
<p>This implementation balances simplicity with resource efficiency.</p>
<h4 id="pointer-management-details">Pointer Management Details</h4>
<p>The pointer management system efficiently implements circular behavior:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Update write pointer with wrapping</span>
write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;

<span class="hljs-comment">// Update read pointer with wrapping</span>
read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
</div></code></pre>
<p>This approach provides:</p>
<ul>
<li>Automatic wrapping around buffer boundaries</li>
<li>Constant-time pointer updates</li>
<li>Minimal logic for pointer management</li>
<li>Clear relationship between pointers and buffer state</li>
<li>Efficient synthesis to hardware structures</li>
</ul>
<p>The modulo operation ensures that pointers always reference valid memory locations.</p>
<h4 id="memory-architecture-considerations">Memory Architecture Considerations</h4>
<p>The memory architecture is optimized for the specific requirements of technical indicators:</p>
<ol>
<li>
<p><strong>Single-Port Memory</strong></p>
<ul>
<li>Only one write operation per cycle required</li>
<li>Simplifies control and timing</li>
<li>Reduces resource requirements</li>
<li>Matches application access patterns</li>
</ul>
</li>
<li>
<p><strong>Dual Access Mechanism</strong></p>
<ul>
<li>Write access through write pointer</li>
<li>Read access through read pointer</li>
<li>Clear separation of read and write paths</li>
<li>No port conflicts or arbitration required</li>
</ul>
</li>
<li>
<p><strong>Sequential Access Pattern</strong></p>
<ul>
<li>Predictable write sequence</li>
<li>Predictable read sequence</li>
<li>No random access requirements</li>
<li>Aligned with FIFO operation</li>
</ul>
</li>
<li>
<p><strong>Optimization for Sliding Window</strong></p>
<ul>
<li>Efficient access to both newest and oldest values</li>
<li>Direct support for the sliding window algorithm</li>
<li>Specialized for technical indicator calculation</li>
<li>Minimal overhead for the required functionality</li>
</ul>
</li>
</ol>
<p>This architecture provides the exact memory functionality needed without unnecessary features.</p>
<h4 id="fpga-specific-memory-optimizations">FPGA-Specific Memory Optimizations</h4>
<p>The implementation includes optimizations specific to FPGA deployment:</p>
<ol>
<li>
<p><strong>Register Array Implementation</strong></p>
<ul>
<li>Small buffer sizes implemented using register arrays</li>
<li>Maps efficiently to FPGA slice registers or distributed RAM</li>
<li>Direct compilation to hardware resources</li>
<li>Minimal access latency</li>
</ul>
</li>
<li>
<p><strong>Potential Block RAM Mapping</strong></p>
<ul>
<li>Larger buffer sizes could map to block RAM</li>
<li>Automatic inference by synthesis tools</li>
<li>Resource optimization for larger window sizes</li>
<li>Maintainable code structure regardless of implementation</li>
</ul>
</li>
<li>
<p><strong>Reset Handling</strong></p>
<ul>
<li>Only pointers and counters reset</li>
<li>Memory contents implicitly invalid until filled</li>
<li>Reduced reset fanout</li>
<li>Faster initialization</li>
</ul>
</li>
<li>
<p><strong>Synchronous Write, Asynchronous Read</strong></p>
<ul>
<li>Standard FPGA memory pattern</li>
<li>Efficient mapping to hardware resources</li>
<li>Clear timing boundaries</li>
<li>Simplified timing analysis</li>
</ul>
</li>
</ol>
<p>These optimizations enhance FPGA implementation efficiency without compromising functionality.</p>
<h3 id="register-width-optimization">Register Width Optimization</h3>
<h4 id="precision-requirements-analysis">Precision Requirements Analysis</h4>
<p>The system implements careful register width selection based on precision requirements:</p>
<ol>
<li>
<p><strong>Price Representation (16-bit)</strong></p>
<ul>
<li>Sufficient for typical financial instruments</li>
<li>Range: 0 to 65,535</li>
<li>Balances precision with resource usage</li>
<li>Standard data width for system interfaces</li>
</ul>
</li>
<li>
<p><strong>Sum Accumulator (64-bit)</strong></p>
<ul>
<li>Required for preventing overflow during accumulation</li>
<li>For 20  16-bit values, theoretical minimum: ~21 bits</li>
<li>Conservative sizing with substantial margin</li>
<li>Elimination of overflow concerns</li>
</ul>
</li>
<li>
<p><strong>RSI Calculation (32-bit accumulators, 8-bit output)</strong></p>
<ul>
<li>Gain/loss accumulators: 32 bits for sufficient range</li>
<li>RSI output: 8 bits for 0-100 range</li>
<li>Appropriate precision for the calculation</li>
<li>Minimal resource usage for required accuracy</li>
</ul>
</li>
</ol>
<p>This analysis ensures sufficient precision while optimizing resource utilization.</p>
<h4 id="overflow-prevention-strategies">Overflow Prevention Strategies</h4>
<p>The implementation employs several strategies to prevent overflow:</p>
<ol>
<li>
<p><strong>Extended-Width Accumulators</strong></p>
<ul>
<li>Sum register (64-bit) much wider than required</li>
<li>Gain/loss accumulators (32-bit) with ample margin</li>
<li>Prevents overflow during normal operation</li>
<li>Eliminates need for complex overflow handling</li>
</ul>
</li>
<li>
<p><strong>Intermediate Calculation Precision</strong></p>
<ul>
<li>Calculations maintain full precision until final output</li>
<li>No premature truncation or rounding</li>
<li>Preserves accuracy throughout calculation chain</li>
<li>Prevents cumulative precision loss</li>
</ul>
</li>
<li>
<p><strong>Division Protection</strong></p>
<ul>
<li>RSI calculation includes divide-by-zero protection</li>
<li>Conditional execution based on denominator check</li>
<li>Safe default values for edge cases</li>
<li>Robust operation under all conditions</li>
</ul>
</li>
</ol>
<p>These strategies ensure reliable operation without overflow-related failures.</p>
<h4 id="resource-utilization-tradeoffs">Resource Utilization Tradeoffs</h4>
<p>Register width selection involves several resource tradeoffs:</p>
<ol>
<li>
<p><strong>Price Width (16-bit)</strong></p>
<ul>
<li><strong>Wider</strong>: Better precision, higher resource usage</li>
<li><strong>Narrower</strong>: Limited range, resource savings</li>
<li><strong>Decision</strong>: 16 bits provides suitable balance</li>
</ul>
</li>
<li>
<p><strong>Sum Register (64-bit)</strong></p>
<ul>
<li><strong>Wider</strong>: Absolute overflow prevention, higher resource usage</li>
<li><strong>Narrower</strong>: Risk of overflow, resource savings</li>
<li><strong>Decision</strong>: Conservative 64-bit implementation for reliability</li>
</ul>
</li>
<li>
<p><strong>RSI Output (8-bit)</strong></p>
<ul>
<li><strong>Wider</strong>: Unnecessary precision, higher resource usage</li>
<li><strong>Narrower</strong>: Matches exact requirements, resource optimization</li>
<li><strong>Decision</strong>: 8 bits exactly matches 0-100 range requirement</li>
</ul>
</li>
<li>
<p><strong>State Registers (2-3 bits)</strong></p>
<ul>
<li><strong>Wider</strong>: Unnecessary bits, higher resource usage</li>
<li><strong>Narrower</strong>: Matches state count, resource optimization</li>
<li><strong>Decision</strong>: Minimal width based on state count</li>
</ul>
</li>
</ol>
<p>These tradeoffs balance precision requirements with efficient resource utilization.</p>
<h4 id="bit-width-selection-methodology">Bit Width Selection Methodology</h4>
<p>The bit width selection follows a structured methodology:</p>
<ol>
<li>
<p><strong>Analysis Phase</strong></p>
<ul>
<li>Determine value ranges for each register</li>
<li>Identify minimum bits required for representation</li>
<li>Assess overflow and precision risks</li>
<li>Consider system integration requirements</li>
</ul>
</li>
<li>
<p><strong>Margin Allocation</strong></p>
<ul>
<li>Add safety margin based on criticality</li>
<li>Ensure sufficient headroom for edge cases</li>
<li>Balance margin with resource considerations</li>
<li>Apply conservative sizing where appropriate</li>
</ul>
</li>
<li>
<p><strong>Standardization</strong></p>
<ul>
<li>Align widths with standard data paths where possible</li>
<li>Use power-of-2 widths for efficiency</li>
<li>Maintain consistency across related signals</li>
<li>Consider synthesis tool optimization capabilities</li>
</ul>
</li>
<li>
<p><strong>Verification</strong></p>
<ul>
<li>Test with extreme values to verify margin adequacy</li>
<li>Confirm overflow prevention</li>
<li>Validate precision for all operational scenarios</li>
<li>Assess resource utilization impact</li>
</ul>
</li>
</ol>
<p>This methodology ensures appropriate register sizing throughout the system.</p>
<h3 id="parameterized-design-techniques">Parameterized Design Techniques</h3>
<h4 id="parameter-definition-strategy">Parameter Definition Strategy</h4>
<p>The system implements parameterization to enhance flexibility and reusability:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,    <span class="hljs-comment">// Moving average window size</span>
    <span class="hljs-keyword">parameter</span> DW     = <span class="hljs-number">16</span>     <span class="hljs-comment">// Data width for price values</span>
)(
    <span class="hljs-comment">// Port list...</span>
);

<span class="hljs-keyword">module</span> price_memory #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,     <span class="hljs-comment">// FIFO buffer depth</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>         <span class="hljs-comment">// Data width for price values</span>
)(
    <span class="hljs-comment">// Port list...</span>
);

<span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,  <span class="hljs-comment">// RSI buy threshold</span>
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>   <span class="hljs-comment">// RSI sell threshold</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<p>The parameter strategy includes:</p>
<ul>
<li>Descriptive parameter names for clarity</li>
<li>Meaningful default values for common scenarios</li>
<li>Consistent naming across related modules</li>
<li>Clear documentation through comments</li>
<li>Type and width specifications where appropriate</li>
</ul>
<p>This approach enhances code readability and maintenance.</p>
<h4 id="compile-time-configurability">Compile-Time Configurability</h4>
<p>Parameters provide compile-time configurability:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Module instantiation with parameter overrides</span>
moving_average_fsm #(
    <span class="hljs-variable">.WINDOW</span>(<span class="hljs-number">50</span>),         <span class="hljs-comment">// 50-period moving average</span>
    <span class="hljs-variable">.DW</span>(<span class="hljs-number">24</span>)              <span class="hljs-comment">// 24-bit price width</span>
) ma_module (
    <span class="hljs-comment">// Port connections...</span>
);

trading_decision #(
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">25</span>),    <span class="hljs-comment">// More aggressive buy threshold</span>
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">75</span>)    <span class="hljs-comment">// More aggressive sell threshold</span>
) decision_module (
    <span class="hljs-comment">// Port connections...</span>
);
</div></code></pre>
<p>This configurability enables:</p>
<ul>
<li>Customization without code changes</li>
<li>Adaptation to different trading strategies</li>
<li>Optimization for specific applications</li>
<li>Easy experimentation with different parameters</li>
<li>Consistent implementation across configurations</li>
</ul>
<p>The compile-time nature ensures zero runtime overhead.</p>
<h4 id="design-reuse-approaches">Design Reuse Approaches</h4>
<p>Parameterization supports several design reuse approaches:</p>
<ol>
<li>
<p><strong>Window Size Variation</strong></p>
<ul>
<li>Different technical indicators use different periods</li>
<li>Parameter adjustment accommodates various requirements</li>
<li>Consistent implementation across window sizes</li>
<li>Shared algorithm with different configurations</li>
</ul>
</li>
<li>
<p><strong>Data Width Adaptation</strong></p>
<ul>
<li>Different markets may require different precision</li>
<li>Parameter adjustment for price representation</li>
<li>Consistent implementation across data widths</li>
<li>Scalable design for various applications</li>
</ul>
</li>
<li>
<p><strong>Strategy Customization</strong></p>
<ul>
<li>Different trading strategies use different thresholds</li>
<li>Parameter adjustment for strategy tuning</li>
<li>Experimental optimization through parameter sweeps</li>
<li>Market-specific customization</li>
</ul>
</li>
<li>
<p><strong>Module Replication</strong></p>
<ul>
<li>Multiple instances with different configurations</li>
<li>Support for multi-timeframe analysis</li>
<li>Parallel strategy evaluation</li>
<li>Enhanced system capabilities through replication</li>
</ul>
</li>
</ol>
<p>These approaches maximize code reuse while maintaining flexibility.</p>
<h4 id="implementation-flexibility">Implementation Flexibility</h4>
<p>The parameterized design enables several implementation options:</p>
<ol>
<li>
<p><strong>Multi-Indicator Systems</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Short-term indicator</span>
moving_average_fsm <span class="hljs-variable">#(.WINDOW(10)) ma_short (...)</span>;

<span class="hljs-comment">// Medium-term indicator</span>
moving_average_fsm <span class="hljs-variable">#(.WINDOW(20)) ma_medium (...)</span>;

<span class="hljs-comment">// Long-term indicator</span>
moving_average_fsm <span class="hljs-variable">#(.WINDOW(50)) ma_long (...)</span>;
</div></code></pre>
</li>
<li>
<p><strong>Multi-Market Adaptation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// High-value market (wider data path)</span>
moving_average_fsm <span class="hljs-variable">#(.DW(24)) ma_bitcoin (...)</span>;

<span class="hljs-comment">// Standard market</span>
moving_average_fsm <span class="hljs-variable">#(.DW(16)) ma_stocks (...)</span>;
</div></code></pre>
</li>
<li>
<p><strong>Strategy Variations</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Conservative strategy</span>
trading_decision <span class="hljs-variable">#(.BUY_RSI_THR(20), .SELL_RSI_THR(80)) conservative (...)</span>;

<span class="hljs-comment">// Aggressive strategy</span>
trading_decision <span class="hljs-variable">#(.BUY_RSI_THR(40), .SELL_RSI_THR(60)) aggressive (...)</span>;
</div></code></pre>
</li>
</ol>
<p>This flexibility enhances the system's applicability across different scenarios.</p>
<h4 id="parameter-propagation-methodology">Parameter Propagation Methodology</h4>
<p>The system implements consistent parameter propagation:</p>
<ol>
<li>
<p><strong>Top-Down Propagation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Top-level parameters</span>
<span class="hljs-keyword">module</span> trading_system #(
    <span class="hljs-keyword">parameter</span> WINDOW_SIZE = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DATA_WIDTH = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);

<span class="hljs-comment">// Parameter propagation to submodules</span>
moving_average_fsm #(
    <span class="hljs-variable">.WINDOW</span>(WINDOW_SIZE),
    <span class="hljs-variable">.DW</span>(DATA_WIDTH)
) ma_module (...);

price_memory #(
    <span class="hljs-variable">.DEPTH</span>(WINDOW_SIZE),
    <span class="hljs-variable">.DW</span>(DATA_WIDTH)
) mem_module (...);
</div></code></pre>
</li>
<li>
<p><strong>Consistent Naming</strong></p>
<ul>
<li>Related parameters use consistent naming</li>
<li>Clear mapping between levels</li>
<li>Intuitive parameter relationships</li>
<li>Reduced confusion or ambiguity</li>
</ul>
</li>
<li>
<p><strong>Documentation</strong></p>
<ul>
<li>Parameters clearly documented at each level</li>
<li>Relationship between parameters explained</li>
<li>Valid range and impact described</li>
<li>Usage examples provided</li>
</ul>
</li>
</ol>
<p>This methodology ensures clean parameter handling throughout the design hierarchy.</p>
<h2 id="8-performance-considerations">8. Performance Considerations</h2>
<h3 id="clock-domain-analysis">Clock Domain Analysis</h3>
<h4 id="single-domain-advantages">Single Domain Advantages</h4>
<p>The technical analysis system implements a single clock domain architecture, providing several significant advantages:</p>
<ol>
<li>
<p><strong>Simplified Timing Analysis</strong></p>
<ul>
<li>Single clock reference for all sequential elements</li>
<li>No clock domain crossing (CDC) complexity</li>
<li>Straightforward setup and hold analysis</li>
<li>Reduced timing closure challenges</li>
<li>Clear timing relationships throughout the system</li>
</ul>
</li>
<li>
<p><strong>Elimination of Synchronization Overhead</strong></p>
<ul>
<li>No need for multi-stage synchronizers</li>
<li>Avoidance of metastability issues</li>
<li>Zero synchronization latency</li>
<li>Reduced resource utilization</li>
<li>Simplified verification requirements</li>
</ul>
</li>
<li>
<p><strong>Deterministic Operation</strong></p>
<ul>
<li>Predictable cycle counts for all operations</li>
<li>Consistent latency for calculations</li>
<li>Reliable handshaking between modules</li>
<li>Well-defined control flow</li>
<li>Simpler debugging and verification</li>
</ul>
</li>
<li>
<p><strong>System Integration Simplicity</strong></p>
<ul>
<li>Single clock distribution network</li>
<li>Uniform timing constraints</li>
<li>Consistent design methodology</li>
<li>Straightforward interface timing</li>
<li>Reduced integration complexity</li>
</ul>
</li>
</ol>
<p>These advantages create a robust foundation for the trading system's implementation.</p>
<h4 id="clock-frequency-selection">Clock Frequency Selection</h4>
<p>The system targets a clock frequency of 100 MHz (10ns period), which provides:</p>
<ol>
<li>
<p><strong>Performance Adequacy</strong></p>
<ul>
<li>Sufficient for typical market data rates</li>
<li>Ample processing headroom for indicators</li>
<li>Support for multiple instrument processing</li>
<li>Margin for system scalability</li>
<li>Balance between performance and power</li>
</ul>
</li>
<li>
<p><strong>Implementation Feasibility</strong></p>
<ul>
<li>Achievable on typical FPGA platforms</li>
<li>Reasonable timing closure challenge</li>
<li>Margin for routing and logic delays</li>
<li>Compatible with standard interfaces</li>
<li>Realistic for the implemented algorithms</li>
</ul>
</li>
<li>
<p><strong>Power Efficiency</strong></p>
<ul>
<li>Moderate frequency for power considerations</li>
<li>Avoidance of excessive switching losses</li>
<li>Balance between performance and energy usage</li>
<li>Suitable for continuous operation</li>
<li>Compatible with low-power requirements</li>
</ul>
</li>
</ol>
<p>The frequency selection provides an optimal balance between performance and implementation considerations.</p>
<h4 id="fpga-clock-management">FPGA Clock Management</h4>
<p>The implementation leverages standard FPGA clock management techniques:</p>
<ol>
<li>
<p><strong>Global Clock Resources</strong></p>
<ul>
<li>Utilization of dedicated clock networks</li>
<li>Low-skew distribution across the device</li>
<li>Optimized routing for timing</li>
<li>Efficient resource utilization</li>
<li>Support for the selected frequency</li>
</ul>
</li>
<li>
<p><strong>Clock Tree Design</strong></p>
<ul>
<li>Single root clock for the entire system</li>
<li>Balanced distribution to all components</li>
<li>Minimal skew between destinations</li>
<li>Controlled insertion delay</li>
<li>Reliable clock delivery</li>
</ul>
</li>
<li>
<p><strong>FPGA-Specific Features</strong></p>
<ul>
<li>Potential use of clock management tiles (CMTs)</li>
<li>Phase-locked loops (PLLs) for clock generation</li>
<li>Clock buffers for distribution</li>
<li>Input/output clock resources</li>
<li>Platform-specific optimization</li>
</ul>
</li>
</ol>
<p>These techniques ensure reliable clock distribution throughout the design.</p>
<h4 id="timing-constraint-approach">Timing Constraint Approach</h4>
<p>The system employs a straightforward timing constraint approach:</p>
<ol>
<li>
<p><strong>Primary Clock Constraint</strong></p>
<pre class="hljs"><code><div>create_clock -period 10.000 -name clk [get_ports clk]
</div></code></pre>
<ul>
<li>10ns period (100 MHz)</li>
<li>Applied to the top-level clock input</li>
<li>Propagated throughout the hierarchy</li>
<li>Primary timing reference for the design</li>
</ul>
</li>
<li>
<p><strong>Input Delay Constraints</strong></p>
<pre class="hljs"><code><div>set_input_delay -clock clk 2.000 [get_ports {price_in* new_price start rst}]
</div></code></pre>
<ul>
<li>2ns input delay assumption</li>
<li>Applied to all external inputs</li>
<li>Models realistic input timing</li>
<li>Ensures proper setup/hold analysis</li>
</ul>
</li>
<li>
<p><strong>Output Delay Constraints</strong></p>
<pre class="hljs"><code><div>set_output_delay -clock clk 2.000 [get_ports {moving_avg* rsi* buy sell done}]
</div></code></pre>
<ul>
<li>2ns output delay requirement</li>
<li>Applied to all external outputs</li>
<li>Ensures proper driving strength</li>
<li>Models realistic output timing</li>
</ul>
</li>
<li>
<p><strong>False Path Identification</strong></p>
<pre class="hljs"><code><div>set_false_path -from [get_ports rst] -to [all_registers]
</div></code></pre>
<ul>
<li>Asynchronous reset handling</li>
<li>Prevents unrealistic timing requirements</li>
<li>Appropriate for reset distribution</li>
<li>Standard asynchronous reset pattern</li>
</ul>
</li>
</ol>
<p>These constraints provide a solid foundation for timing analysis and implementation.</p>
<h3 id="calculation-latency-details">Calculation Latency Details</h3>
<h4 id="moving-average-latency-analysis">Moving Average Latency Analysis</h4>
<p>The moving average implementation has well-defined latency characteristics:</p>
<ol>
<li>
<p><strong>Calculation Initiation</strong></p>
<ul>
<li>Triggered by <code>start</code> signal (derived from <code>memory_full</code>)</li>
<li>One cycle latency to state transition</li>
<li>Predictable initiation timing</li>
<li>Clear starting point for latency measurement</li>
</ul>
</li>
<li>
<p><strong>Computation Latency</strong></p>
<ul>
<li>State 1 (CALCULATE): 1 cycle
<ul>
<li>Sum update and division in single cycle</li>
<li>Registered output calculation</li>
<li>Assertion of done signal</li>
</ul>
</li>
<li>State 2 (DONE): 1 cycle
<ul>
<li>Completion signaling</li>
<li>Return to idle state</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>End-to-End Latency</strong></p>
<ul>
<li>From <code>start</code> assertion to <code>done</code> assertion: 2 cycles</li>
<li>From data availability to result availability: 3 cycles</li>
<li>Deterministic regardless of input values</li>
<li>Fixed cycle count for all calculations</li>
</ul>
</li>
<li>
<p><strong>Critical Path Analysis</strong></p>
<ul>
<li>Addition/subtraction for sum update</li>
<li>Division operation for average calculation</li>
<li>Division likely forms the critical path</li>
<li>Implementation-dependent timing characteristics</li>
<li>Potential optimization through pipelining</li>
</ul>
</li>
</ol>
<p>This analysis provides clear latency expectations for system integration.</p>
<h4 id="rsi-latency-analysis">RSI Latency Analysis</h4>
<p>The RSI calculation involves more complex latency characteristics:</p>
<ol>
<li>
<p><strong>FIFO Filling Latency</strong></p>
<ul>
<li>20 clock cycles minimum (one per price)</li>
<li>Dependent on price data arrival rate</li>
<li>Sequential filling of the FIFO buffer</li>
<li>Prerequisite for calculation initiation</li>
</ul>
</li>
<li>
<p><strong>Calculation Initiation</strong></p>
<ul>
<li>Triggered by <code>start</code> signal after FIFO is full</li>
<li>One cycle latency to state transition</li>
<li>Clear starting point for processing</li>
</ul>
</li>
<li>
<p><strong>State Transition Latency</strong></p>
<ul>
<li>IDLE  FILL_FIFO: 1 cycle</li>
<li>FILL_FIFO  READ_INIT: 1 cycle</li>
<li>READ_INIT  COMPARE: 1 cycle (plus FIFO read delay)</li>
<li>COMPARE  READ_WAIT: 1 cycle (19 iterations)</li>
<li>READ_WAIT  COMPARE: 1 cycle (19 iterations)</li>
<li>COMPARE  DONE: 1 cycle</li>
<li>DONE  IDLE: 1 cycle</li>
</ul>
</li>
<li>
<p><strong>Processing Latency</strong></p>
<ul>
<li>Sample processing: 2 cycles per sample</li>
<li>19 samples to process</li>
<li>Total processing: ~38 cycles</li>
<li>Final calculation: 1 cycle</li>
<li>Completion signaling: 1 cycle</li>
</ul>
</li>
<li>
<p><strong>End-to-End Latency</strong></p>
<ul>
<li>From <code>start</code> assertion to <code>done</code> assertion: ~43 cycles</li>
<li>Dominated by the sequential sample processing</li>
<li>Much higher than moving average latency</li>
<li>Less deterministic due to conditional execution</li>
</ul>
</li>
<li>
<p><strong>Critical Path Analysis</strong></p>
<ul>
<li>Comparison operations</li>
<li>Addition for accumulation</li>
<li>Division for final calculation</li>
<li>Division likely forms the critical path</li>
<li>Implementation-dependent timing characteristics</li>
</ul>
</li>
</ol>
<p>The RSI calculation has significantly higher latency than the moving average calculation.</p>
<h4 id="end-to-end-system-latency">End-to-End System Latency</h4>
<p>The complete system latency includes several components:</p>
<ol>
<li>
<p><strong>Initial Data Collection</strong></p>
<ul>
<li>14-20 price inputs (depending on indicator)</li>
<li>Dependent on market data arrival rate</li>
<li>Sequential filling of the price memory</li>
<li>Prerequisite for calculation initiation</li>
</ul>
</li>
<li>
<p><strong>Indicator Calculation</strong></p>
<ul>
<li>Moving Average: ~3 cycles</li>
<li>RSI: ~43 cycles</li>
<li>Parallel execution of both indicators</li>
<li>System latency dominated by slowest component (RSI)</li>
</ul>
</li>
<li>
<p><strong>Trading Decision Latency</strong></p>
<ul>
<li>Condition evaluation: 1 cycle</li>
<li>Signal generation: 1 cycle</li>
<li>Minimal impact on overall latency</li>
</ul>
</li>
<li>
<p><strong>Total System Latency</strong></p>
<ul>
<li>From first price to first signal: ~20 + 43 + 1 = ~64 cycles</li>
<li>At 100 MHz: ~640ns</li>
<li>Dominated by data collection and RSI calculation</li>
<li>Additional latency for external interfaces</li>
<li>Meets requirements for most trading applications</li>
</ul>
</li>
</ol>
<p>This analysis provides realistic expectations for system responsiveness.</p>
<h4 id="critical-path-identification">Critical Path Identification</h4>
<p>The system has several potential critical paths:</p>
<ol>
<li>
<p><strong>Moving Average Critical Path</strong></p>
<pre class="hljs"><code><div>sum register  addition/subtraction  division  moving_avg register
</div></code></pre>
<ul>
<li>Dominated by the division operation</li>
<li>Implementation-dependent timing characteristics</li>
<li>Potential target for optimization</li>
</ul>
</li>
<li>
<p><strong>RSI Critical Path</strong></p>
<pre class="hljs"><code><div>gain_sum/loss_sum registers  addition  division  rsi register
</div></code></pre>
<ul>
<li>Division for final RSI calculation</li>
<li>Complex operation with significant delay</li>
<li>Likely system-wide critical path</li>
</ul>
</li>
<li>
<p><strong>Trading Decision Critical Path</strong></p>
<pre class="hljs"><code><div>moving_avg/rsi/price registers  comparisons  AND operation  buy/sell registers
</div></code></pre>
<ul>
<li>Simpler operations with lower delay</li>
<li>Not likely to be system-limiting</li>
<li>Less critical for optimization</li>
</ul>
</li>
</ol>
<p>Critical path optimization should focus on the division operations in the indicator calculations.</p>
<h4 id="latency-optimization-strategies">Latency Optimization Strategies</h4>
<p>Several strategies could further optimize calculation latency:</p>
<ol>
<li>
<p><strong>Pipelined Division</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Multi-cycle division example</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] div_state = <span class="hljs-number">0</span>;

<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">case</span> (div_state)
        <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Initiate division</span>
            div_state &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span>
        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Complete division</span>
            moving_avg &lt;= sum / WINDOW;
            div_state &lt;= <span class="hljs-number">2</span>;
        <span class="hljs-keyword">end</span>
        <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Complete operation</span>
            done &lt;= <span class="hljs-number">1</span>;
            div_state &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endcase</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Breaks critical path through pipelining</li>
<li>Increases latency but improves clock frequency</li>
<li>More complex control logic</li>
<li>Better scaling to higher frequencies</li>
</ul>
</li>
<li>
<p><strong>Optimized Division Implementation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// For power-of-2 divisors (not directly applicable to WINDOW=10)</span>
moving_avg &lt;= sum &gt;&gt; <span class="hljs-number">4</span>;  <span class="hljs-comment">// Division by 16</span>

<span class="hljs-comment">// For specific divisors like 10</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] scaled_sum = (sum * <span class="hljs-number">32&#x27;h1999999A</span>) &gt;&gt; <span class="hljs-number">32</span>;  <span class="hljs-comment">// Multiplication by 1/10</span>
moving_avg &lt;= scaled_sum;
</div></code></pre>
<ul>
<li>Replaces division with more efficient operations</li>
<li>Reduces critical path delay</li>
<li>May involve approximation</li>
<li>Different optimization for different divisors</li>
</ul>
</li>
<li>
<p><strong>Parallel Sample Processing (RSI)</strong></p>
<ul>
<li>Process multiple samples simultaneously</li>
<li>Reduce iterative loop count</li>
<li>Increased resource usage</li>
<li>More complex control logic</li>
<li>Significant latency reduction potential</li>
</ul>
</li>
</ol>
<p>These strategies offer different tradeoffs between latency, resource utilization, and implementation complexity.</p>
<h3 id="throughput-analysis">Throughput Analysis</h3>
<h4 id="maximum-throughput-calculation">Maximum Throughput Calculation</h4>
<p>The system's throughput can be analyzed at different levels:</p>
<ol>
<li>
<p><strong>Moving Average Throughput</strong></p>
<ul>
<li>One update per clock cycle after initialization</li>
<li>State machine completes in 3 cycles</li>
<li>Maximum theoretical throughput: 1/3 * clock frequency</li>
<li>At 100 MHz: ~33 million updates per second</li>
<li>Far exceeds typical market data rates</li>
</ul>
</li>
<li>
<p><strong>RSI Throughput</strong></p>
<ul>
<li>One update per RSI calculation cycle</li>
<li>Calculation requires ~43 cycles</li>
<li>Maximum theoretical throughput: 1/43 * clock frequency</li>
<li>At 100 MHz: ~2.3 million updates per second</li>
<li>Still exceeds typical market data requirements</li>
</ul>
</li>
<li>
<p><strong>System Throughput</strong></p>
<ul>
<li>Dominated by the slowest component (RSI)</li>
<li>One complete update per ~43 cycles</li>
<li>Maximum theoretical throughput: ~2.3 million updates per second</li>
<li>Far exceeds typical market data rates (thousands per second)</li>
<li>Ample margin for system scalability</li>
</ul>
</li>
</ol>
<p>This analysis confirms that the system can easily handle typical market data rates.</p>
<h4 id="sustained-performance-evaluation">Sustained Performance Evaluation</h4>
<p>Sustained performance analysis considers continuous operation:</p>
<ol>
<li>
<p><strong>Indicator Independence</strong></p>
<ul>
<li>Moving average and RSI calculations operate independently</li>
<li>Parallel processing of both indicators</li>
<li>No resource contention between calculations</li>
<li>Sustained throughput equals maximum throughput</li>
<li>No degradation during continuous operation</li>
</ul>
</li>
<li>
<p><strong>Price Memory Behavior</strong></p>
<ul>
<li>Circular buffer provides constant-time operations</li>
<li>No performance degradation as buffer fills</li>
<li>Consistent throughput during steady-state operation</li>
<li>No memory management overhead</li>
<li>Efficient sustained operation</li>
</ul>
</li>
<li>
<p><strong>Control Overhead</strong></p>
<ul>
<li>Minimal overhead for state transitions</li>
<li>Clean handshaking between modules</li>
<li>No complex control sequences</li>
<li>Efficient steady-state operation</li>
<li>Negligible impact on sustained throughput</li>
</ul>
</li>
<li>
<p><strong>Long-Term Stability</strong></p>
<ul>
<li>No accumulated errors affecting performance</li>
<li>No resource leakage or degradation</li>
<li>Consistent timing during extended operation</li>
<li>Reliable long-term behavior</li>
<li>Suitable for continuous market monitoring</li>
</ul>
</li>
</ol>
<p>The system's design enables consistent performance during sustained operation.</p>
<h4 id="bottleneck-identification">Bottleneck Identification</h4>
<p>Potential system bottlenecks include:</p>
<ol>
<li>
<p><strong>RSI Calculation</strong></p>
<ul>
<li>Most complex calculation in the system</li>
<li>Highest latency component</li>
<li>Sequential sample processing</li>
<li>Primary throughput limiter</li>
<li>Most promising target for optimization</li>
</ul>
</li>
<li>
<p><strong>Division Operations</strong></p>
<ul>
<li>Complex operations with high latency</li>
<li>Present in both indicator calculations</li>
<li>Likely critical path elements</li>
<li>Implementation-dependent performance</li>
<li>Potential targets for optimization</li>
</ul>
</li>
<li>
<p><strong>External Interfaces</strong></p>
<ul>
<li>Price data input rate</li>
<li>Signal output handling</li>
<li>System integration overhead</li>
<li>Potential external bottlenecks</li>
<li>Not analyzed in the current implementation</li>
</ul>
</li>
<li>
<p><strong>Clock Frequency Limitations</strong></p>
<ul>
<li>Maximum achievable clock frequency</li>
<li>Implementation and device dependent</li>
<li>Affects all throughput calculations</li>
<li>Foundational performance parameter</li>
<li>Target for timing optimization</li>
</ul>
</li>
</ol>
<p>Addressing these bottlenecks would enhance system throughput capabilities.</p>
<h4 id="throughput-enhancement-techniques">Throughput Enhancement Techniques</h4>
<p>Several techniques could further enhance system throughput:</p>
<ol>
<li>
<p><strong>Pipelined RSI Calculation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Conceptual pipelined implementation</span>
<span class="hljs-keyword">module</span> rsi_pipeline (
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Multiple processing stages operating concurrently</span>
    <span class="hljs-comment">// Stage 1: Price comparison</span>
    <span class="hljs-comment">// Stage 2: Accumulation</span>
    <span class="hljs-comment">// Stage 3: Final calculation</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<ul>
<li>Parallel processing of multiple samples</li>
<li>Overlapped execution of calculation stages</li>
<li>Increased resource usage</li>
<li>More complex control logic</li>
<li>Potentially multiple outputs per clock cycle</li>
</ul>
</li>
<li>
<p><strong>Multiple Calculation Units</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Parallel instantiation for different instruments</span>
rsi_fsm rsi_instrument1 (...);
rsi_fsm rsi_instrument2 (...);
rsi_fsm rsi_instrument3 (...);
</div></code></pre>
<ul>
<li>Parallel processing of multiple instruments</li>
<li>Linear throughput scaling with instances</li>
<li>Proportional resource utilization</li>
<li>No modification to existing modules</li>
<li>Simple system-level enhancement</li>
</ul>
</li>
<li>
<p><strong>Higher Clock Frequency</strong></p>
<ul>
<li>Optimize critical paths for higher frequency</li>
<li>Proportional throughput enhancement</li>
<li>Increased power consumption</li>
<li>More challenging timing closure</li>
<li>Direct performance improvement</li>
</ul>
</li>
<li>
<p><strong>Optimized Division Implementation</strong></p>
<ul>
<li>Replace division with multiplication by reciprocal</li>
<li>Use DSP blocks for efficient implementation</li>
<li>Potential approximation tradeoffs</li>
<li>Improved critical path timing</li>
<li>Enhanced calculation throughput</li>
</ul>
</li>
</ol>
<p>These techniques provide options for scaling system performance to meet application requirements.</p>
<h3 id="synchronization-strategy">Synchronization Strategy</h3>
<h4 id="parallel-calculation-management">Parallel Calculation Management</h4>
<p>The system implements parallel calculation of multiple indicators, requiring effective synchronization:</p>
<ol>
<li>
<p><strong>Independent Operation</strong></p>
<ul>
<li>Moving average and RSI calculate independently</li>
<li>Separate control logic and datapaths</li>
<li>No resource sharing or contention</li>
<li>Maximum parallelism exploitation</li>
<li>Simplified synchronization requirements</li>
</ul>
</li>
<li>
<p><strong>Common Trigger Mechanism</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Derived from memory buffer status</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);

<span class="hljs-comment">// Distributed to both calculation modules</span>
moving_average_fsm ma14 (
    <span class="hljs-variable">.start</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);

rsi_inc rsi14 (
    <span class="hljs-variable">.new_price_strobe</span>(compute_enable),
    <span class="hljs-comment">// Other connections</span>
);
</div></code></pre>
<ul>
<li>Consistent triggering of both calculations</li>
<li>Single synchronization point for initiation</li>
<li>Clear timing relationship at start</li>
<li>Simple fanout distribution</li>
<li>No complex handshaking required</li>
</ul>
</li>
<li>
<p><strong>Independent Completion</strong></p>
<ul>
<li>Each module generates its own completion signal</li>
<li>No forced synchronization of completion timing</li>
<li>Natural timing based on calculation complexity</li>
<li>Accommodates different calculation latencies</li>
<li>Simplified control logic</li>
</ul>
</li>
</ol>
<p>This approach maximizes parallelism while maintaining appropriate synchronization.</p>
<h4 id="trigger-signal-distribution">Trigger Signal Distribution</h4>
<p>The system implements a clean trigger signal distribution strategy:</p>
<ol>
<li>
<p><strong>Central Trigger Generation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Generated from memory status</span>
<span class="hljs-keyword">wire</span> compute_enable = (mem_cnt == <span class="hljs-number">14</span>);
</div></code></pre>
<ul>
<li>Single source of trigger</li>
<li>Consistent timing for all components</li>
<li>Clear generation logic</li>
<li>Predictable activation timing</li>
<li>Simple distribution methodology</li>
</ul>
</li>
<li>
<p><strong>Trigger Qualification</strong></p>
<ul>
<li>Based on valid data availability</li>
<li>Ensures sufficient data for calculation</li>
<li>Prevents premature processing</li>
<li>Clean transition from initialization to operation</li>
<li>Robust against timing variations</li>
</ul>
</li>
<li>
<p><strong>Signal Propagation</strong></p>
<ul>
<li>Direct connection to calculation modules</li>
<li>Minimal distribution delay</li>
<li>No qualification or conditioning</li>
<li>Simple fanout implementation</li>
<li>Reliable delivery to all consumers</li>
</ul>
</li>
</ol>
<p>This distribution strategy ensures consistent triggering of parallel operations.</p>
<h4 id="handshaking-protocol-design">Handshaking Protocol Design</h4>
<p>The system implements a simple handshaking protocol:</p>
<ol>
<li>
<p><strong>Calculation Initiation</strong></p>
<ul>
<li><code>compute_enable</code> signal triggers calculation</li>
<li>Single-cycle pulse for clean edge detection</li>
<li>Recognized by state machines as operation trigger</li>
<li>No acknowledgment required</li>
<li>Simple unidirectional signaling</li>
</ul>
</li>
<li>
<p><strong>Calculation Completion</strong></p>
<ul>
<li><code>ma_done</code> and <code>rsi_done</code> signals indicate completion</li>
<li>Single-cycle pulses for clean timing</li>
<li>Independent timing based on calculation complexity</li>
<li>No central coordination required</li>
<li>Simple completion notification</li>
</ul>
</li>
<li>
<p><strong>Signal Consumption</strong></p>
<ul>
<li>Trading decision module uses indicator results</li>
<li>No explicit handshaking for result consumption</li>
<li>Continuous evaluation of conditions</li>
<li>Implicit synchronization through registered outputs</li>
<li>Simplified synchronization methodology</li>
</ul>
</li>
</ol>
<p>This streamlined protocol enhances system efficiency while maintaining proper synchronization.</p>
<h4 id="pipeline-balancing-approach">Pipeline Balancing Approach</h4>
<p>The system implements a &quot;natural&quot; pipeline balancing approach:</p>
<ol>
<li>
<p><strong>Independent Timing</strong></p>
<ul>
<li>Each module operates at its natural timing</li>
<li>No forced synchronization between stages</li>
<li>Different latencies for different calculations</li>
<li>Natural balancing based on computation complexity</li>
<li>Simplified control logic</li>
</ul>
</li>
<li>
<p><strong>Asynchronous Result Consumption</strong></p>
<ul>
<li>Trading decision continuously evaluates inputs</li>
<li>No explicit synchronization with indicator completion</li>
<li>Results used as they become available</li>
<li>Natural pipeline operation</li>
<li>Elimination of explicit synchronization overhead</li>
</ul>
</li>
<li>
<p><strong>Data Consistency</strong></p>
<ul>
<li>Registered outputs for all calculations</li>
<li>Stable values between updates</li>
<li>Clean transitions without glitches</li>
<li>Implicit timing synchronization</li>
<li>Reliable operation without complex protocols</li>
</ul>
</li>
</ol>
<p>This approach simplifies the system while maintaining proper pipeline operation.</p>
<h3 id="resource-utilization">Resource Utilization</h3>
<h4 id="fpga-resource-analysis">FPGA Resource Analysis</h4>
<p>The system's FPGA resource utilization can be analyzed by component:</p>
<ol>
<li>
<p><strong>Price Memory</strong></p>
<ul>
<li>Memory array: 14  16 bits = 224 bits</li>
<li>Pointers and counters: ~16 bits</li>
<li>Control logic: Minimal LUT usage</li>
<li>Likely implementation: Distributed RAM or registers</li>
<li>Estimated resource usage: ~35 LUTs, ~250 FFs</li>
</ul>
</li>
<li>
<p><strong>Moving Average FSM</strong></p>
<ul>
<li>Sum register: 64 bits</li>
<li>State register: 2 bits</li>
<li>Output register: 32 bits</li>
<li>Done flag: 1 bit</li>
<li>Control logic: ~10 LUTs</li>
<li>Division logic: Implementation-dependent</li>
<li>Estimated resource usage: ~30 LUTs, ~100 FFs, potential DSP usage</li>
</ul>
</li>
<li>
<p><strong>RSI Calculator</strong></p>
<ul>
<li>FIFO memory: 20  16 bits = 320 bits</li>
<li>Pointers and counters: ~16 bits</li>
<li>State register: 3 bits</li>
<li>Accumulators: 2  32 bits = 64 bits</li>
<li>Price registers: 2  16 bits = 32 bits</li>
<li>Output register: 8 bits</li>
<li>Control logic: ~40 LUTs</li>
<li>Division logic: Implementation-dependent</li>
<li>Estimated resource usage: ~80 LUTs, ~450 FFs, potential DSP usage</li>
</ul>
</li>
<li>
<p><strong>Trading Decision</strong></p>
<ul>
<li>Input registers: ~56 bits</li>
<li>Output registers: 2 bits</li>
<li>Comparison logic: ~10 LUTs</li>
<li>Estimated resource usage: ~10 LUTs, ~60 FFs</li>
</ul>
</li>
</ol>
<p>These estimates provide a basic understanding of resource requirements.</p>
<h4 id="logic-element-requirements">Logic Element Requirements</h4>
<p>The system's logic element requirements include:</p>
<ol>
<li>
<p><strong>State Machines</strong></p>
<ul>
<li>Moving Average: 3-state machine</li>
<li>RSI: 6-state machine</li>
<li>State encoding and next-state logic</li>
<li>Conditional transitions</li>
<li>Estimated LUTs: ~30</li>
</ul>
</li>
<li>
<p><strong>Arithmetic Operations</strong></p>
<ul>
<li>Addition and subtraction for accumulation</li>
<li>Comparison operations for decision logic</li>
<li>Division operations for final calculations</li>
<li>Estimated LUTs: ~50</li>
</ul>
</li>
<li>
<p><strong>Control Logic</strong></p>
<ul>
<li>Signal generation and qualification</li>
<li>Handshaking and synchronization</li>
<li>Status monitoring</li>
<li>Estimated LUTs: ~30</li>
</ul>
</li>
<li>
<p><strong>Miscellaneous Logic</strong></p>
<ul>
<li>Buffer management</li>
<li>Signal routing</li>
<li>System integration</li>
<li>Estimated LUTs: ~20</li>
</ul>
</li>
</ol>
<p>Total estimated LUT usage: ~130 LUTs
This is well within the capacity of even small FPGA devices.</p>
<h4 id="memory-utilization">Memory Utilization</h4>
<p>The system's memory requirements include:</p>
<ol>
<li>
<p><strong>Price History Storage</strong></p>
<ul>
<li>Moving Average: 10  32 bits = 320 bits</li>
<li>RSI: 20  16 bits = 320 bits</li>
<li>Total: ~640 bits</li>
<li>Implementation options:
<ul>
<li>Distributed RAM</li>
<li>Register arrays</li>
<li>Block RAM (for larger window sizes)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Accumulator Registers</strong></p>
<ul>
<li>Moving Average sum: 64 bits</li>
<li>RSI gain/loss accumulators: 2  32 bits = 64 bits</li>
<li>Total: ~128 bits</li>
<li>Implementation: Typically as registers</li>
</ul>
</li>
<li>
<p><strong>State and Control Registers</strong></p>
<ul>
<li>State machines: ~5 bits</li>
<li>Control flags: ~10 bits</li>
<li>Pointers and counters: ~30 bits</li>
<li>Total: ~45 bits</li>
<li>Implementation: Typically as registers</li>
</ul>
</li>
</ol>
<p>Total memory requirement: ~813 bits
This is minimal by FPGA standards and can be implemented using registers or distributed RAM.</p>
<h4 id="dsp-block-usage">DSP Block Usage</h4>
<p>The system may use DSP blocks for efficient implementation of arithmetic operations:</p>
<ol>
<li>
<p><strong>Division Operations</strong></p>
<ul>
<li>Moving Average: sum / WINDOW</li>
<li>RSI: (100 * gain_sum) / (gain_sum + loss_sum)</li>
<li>Potential DSP usage for efficient implementation</li>
<li>Alternative: LUT-based division</li>
</ul>
</li>
<li>
<p><strong>Multiplication Operations</strong></p>
<ul>
<li>RSI: 100 * gain_sum</li>
<li>Potential DSP usage for multiplication</li>
<li>Alternative: Shift and add for constant multiplication</li>
</ul>
</li>
<li>
<p><strong>Implementation Considerations</strong></p>
<ul>
<li>Synthesis tool optimization options</li>
<li>Target device DSP capabilities</li>
<li>Performance requirements</li>
<li>Resource allocation strategy</li>
</ul>
</li>
</ol>
<p>Estimated DSP usage: 0-2 DSP blocks
This is minimal and available in virtually all FPGA devices.</p>
<h4 id="scaling-considerations">Scaling Considerations</h4>
<p>The system's resource usage scales predictably with parameters:</p>
<ol>
<li>
<p><strong>Window Size Scaling</strong></p>
<ul>
<li>Memory usage scales linearly with window size</li>
<li>Logic remains relatively constant</li>
<li>Price Memory: O(n) scaling with window size</li>
<li>Calculation logic: O(1) with window size</li>
</ul>
</li>
<li>
<p><strong>Data Width Scaling</strong></p>
<ul>
<li>Register width scales linearly with data width</li>
<li>Logic complexity increases modestly</li>
<li>Price representation: O(n) with bit width</li>
<li>Arithmetic complexity: O(n) with bit width</li>
</ul>
</li>
<li>
<p><strong>Multi-Instrument Scaling</strong></p>
<ul>
<li>Resource usage scales linearly with instrument count</li>
<li>Independent instances for each instrument</li>
<li>No shared resources between instances</li>
<li>Linear resource scaling: O(n) with instrument count</li>
</ul>
</li>
<li>
<p><strong>Strategy Complexity Scaling</strong></p>
<ul>
<li>Additional indicators increase resource usage</li>
<li>More complex decision logic increases LUT usage</li>
<li>Linear scaling with indicator count</li>
<li>Polynomial scaling with decision complexity</li>
</ul>
</li>
</ol>
<p>These scaling characteristics enable predictable resource planning for system extensions.</p>
<h2 id="9-verification-and-testing">9. Verification and Testing</h2>
<h3 id="moving-average-testbench">Moving Average Testbench</h3>
<h4 id="testbench-architecture">Testbench Architecture</h4>
<p>The Moving Average testbench implements a comprehensive verification environment:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_system_tb;
    <span class="hljs-comment">// Signal declarations</span>
    <span class="hljs-keyword">reg</span> clk = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> rst = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">reg</span> write_enable = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] new_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg;
    <span class="hljs-comment">// Additional signals...</span>

    <span class="hljs-comment">// Module instantiations</span>
    memory memory_inst (...);
    moving_average_fsm ma_fsm (...);

    <span class="hljs-comment">// Clock generation</span>
    <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;  <span class="hljs-comment">// 10ns period (100 MHz)</span>

    <span class="hljs-comment">// Test sequence implementation</span>
    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Test setup and execution</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key architectural elements include:</p>
<ul>
<li>Clock generation with 10ns period</li>
<li>Asynchronous reset control</li>
<li>Test price data generation</li>
<li>Module instantiation and connection</li>
<li>Signal monitoring and verification</li>
<li>Comprehensive test sequence</li>
<li>Automated completion detection</li>
</ul>
<p>This architecture provides a robust verification environment.</p>
<h4 id="test-vector-generation">Test Vector Generation</h4>
<p>The testbench generates a specific test vector sequence:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Test data array</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] price_data [<span class="hljs-number">0</span>:<span class="hljs-number">9</span>];  <span class="hljs-comment">// 10 price points</span>

<span class="hljs-comment">// Initialize test data</span>
<span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Reset system</span>
    rst = <span class="hljs-number">1</span>;
    #<span class="hljs-number">50</span> rst = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Generate test prices (Example: 1000 to 1045)</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
        price_data[i] = <span class="hljs-number">1000</span> + (i * <span class="hljs-number">5</span>);
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// Feed prices into system</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
        #<span class="hljs-number">10</span>;  <span class="hljs-comment">// Small delay</span>
        new_price = price_data[i];
        write_enable = <span class="hljs-number">1</span>;
        #<span class="hljs-number">10</span>;  <span class="hljs-comment">// One clock cycle</span>
        write_enable = <span class="hljs-number">0</span>;
        #<span class="hljs-number">10</span>;  <span class="hljs-comment">// Delay between prices</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Wait for completion</span>
    <span class="hljs-keyword">wait</span>(fifo_data_count == <span class="hljs-number">10</span>);
    #<span class="hljs-number">200</span>;  <span class="hljs-comment">// Additional cycles for calculation</span>
    
    <span class="hljs-comment">// Display results</span>
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Final Check: Moving Avg = %d&quot;</span>, moving_avg);
    <span class="hljs-built_in">$finish</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>Key test vector features:</p>
<ul>
<li>Linear sequence of increasing prices</li>
<li>Predictable pattern for easy verification</li>
<li>Regular timing between price inputs</li>
<li>Complete buffer filling sequence</li>
<li>Controlled test execution</li>
<li>Clear test completion criteria</li>
<li>Result display for verification</li>
</ul>
<p>This approach provides a deterministic test scenario with predictable outcomes.</p>
<h4 id="assertion-strategy">Assertion Strategy</h4>
<p>The testbench implements several validation checks:</p>
<ol>
<li>
<p><strong>Buffer Fill Validation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Wait for buffer to fill</span>
<span class="hljs-keyword">wait</span>(fifo_data_count == <span class="hljs-number">10</span>);
<span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;SUCCESS: FIFO memory filled with 10 prices.&quot;</span>);
</div></code></pre>
<ul>
<li>Verifies proper buffer initialization</li>
<li>Confirms counter functionality</li>
<li>Validates basic system operation</li>
<li>Prerequisite for calculation validation</li>
</ul>
</li>
<li>
<p><strong>Visual Validation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Display final state</span>
<span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Final Check -&gt; Time: %0t | FIFO Count: %d | Memory Full: %b | Moving Avg: %d&quot;</span>,
          <span class="hljs-built_in">$time</span>, fifo_data_count, memory_full, moving_avg);
</div></code></pre>
<ul>
<li>Shows key system parameters</li>
<li>Enables manual result verification</li>
<li>Confirms system state at completion</li>
<li>Documents test outcomes</li>
</ul>
</li>
</ol>
<p>These checks provide basic validation of system functionality.</p>
<p>For a comprehensive production testbench, additional assertions would be beneficial:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Additional assertions (not in original code)</span>
<span class="hljs-keyword">property</span> reset_clears_sum;
    @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-built_in">$rose</span>(rst) |=&gt; (sum == <span class="hljs-number">0</span>);
<span class="hljs-keyword">endproperty</span>
<span class="hljs-keyword">assert</span> <span class="hljs-keyword">property</span>(reset_clears_sum);

<span class="hljs-keyword">property</span> valid_ma_range;
    @(<span class="hljs-keyword">posedge</span> clk) done |-&gt; (moving_avg &gt;= <span class="hljs-number">1000</span> &amp;&amp; moving_avg &lt;= <span class="hljs-number">1045</span>);
<span class="hljs-keyword">endproperty</span>
<span class="hljs-keyword">assert</span> <span class="hljs-keyword">property</span>(valid_ma_range);
</div></code></pre>
<p>Such assertions would enhance verification robustness.</p>
<h4 id="result-verification-methodology">Result Verification Methodology</h4>
<p>The testbench implements a basic result verification approach:</p>
<ol>
<li>
<p><strong>Expected Result Calculation</strong></p>
<ul>
<li>For prices [1000, 1005, 1010, 1015, 1020, 1025, 1030, 1035, 1040, 1045]</li>
<li>Sum = 10225</li>
<li>Expected average = 10225 / 10 = 1022.5</li>
<li>Integer result = 1022</li>
</ul>
</li>
<li>
<p><strong>Visual Inspection</strong></p>
<ul>
<li>Final result displayed at test completion</li>
<li>Manual comparison with expected value</li>
<li>Simple validation approach</li>
<li>Sufficient for basic verification</li>
</ul>
</li>
</ol>
<p>For production testing, automated verification would be preferable:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Automated verification (not in original code)</span>
<span class="hljs-keyword">localparam</span> EXPECTED_RESULT = <span class="hljs-number">1022</span>;

<span class="hljs-comment">// Validate result</span>
<span class="hljs-keyword">if</span> (moving_avg == EXPECTED_RESULT)
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST PASSED: Moving Avg = %d (Expected %d)&quot;</span>, moving_avg, EXPECTED_RESULT);
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST FAILED: Moving Avg = %d (Expected %d)&quot;</span>, moving_avg, EXPECTED_RESULT);
</div></code></pre>
<p>This would enable automated pass/fail determination.</p>
<h4 id="coverage-analysis">Coverage Analysis</h4>
<p>The testbench does not explicitly implement coverage analysis, but several coverage metrics would be valuable:</p>
<ol>
<li>
<p><strong>Code Coverage</strong></p>
<ul>
<li>Statement coverage: Ensure all code is executed</li>
<li>Branch coverage: Verify all conditional branches</li>
<li>Condition coverage: Test all boolean subconditions</li>
<li>Path coverage: Exercise different code paths</li>
</ul>
</li>
<li>
<p><strong>Functional Coverage</strong></p>
<ul>
<li>State coverage: Verify all FSM states are reached</li>
<li>Transition coverage: Test all state transitions</li>
<li>Signal coverage: Exercise the range of signal values</li>
<li>Protocol coverage: Verify handshaking protocols</li>
</ul>
</li>
<li>
<p><strong>Value Coverage</strong></p>
<ul>
<li>Test with minimum, maximum, and intermediate prices</li>
<li>Exercise corner cases (e.g., repeated values)</li>
<li>Verify behavior with extreme data patterns</li>
<li>Test calculation across value ranges</li>
</ul>
</li>
</ol>
<p>These coverage metrics would ensure comprehensive verification.</p>
<h4 id="corner-case-testing">Corner Case Testing</h4>
<p>The testbench does not explicitly test corner cases, but several scenarios should be verified:</p>
<ol>
<li>
<p><strong>Initialization Scenarios</strong></p>
<ul>
<li>System behavior immediately after reset</li>
<li>First calculation after buffer fills</li>
<li>Behavior during buffer filling phase</li>
</ul>
</li>
<li>
<p><strong>Data Pattern Corner Cases</strong></p>
<ul>
<li>All identical prices</li>
<li>Alternating high/low prices</li>
<li>Extreme price values (min, max)</li>
<li>Values causing arithmetic edge cases</li>
<li>Maximum representable sum values</li>
</ul>
</li>
<li>
<p><strong>Timing Corner Cases</strong></p>
<ul>
<li>Rapid consecutive price updates</li>
<li>Reset during calculation</li>
<li>Reset during buffer filling</li>
<li>Multiple start signals in succession</li>
<li>Variable timing between price inputs</li>
</ul>
</li>
</ol>
<p>Comprehensive testing would include these scenarios to verify robust operation under all conditions.</p>
<h3 id="rsi-testbench">RSI Testbench</h3>
<h4 id="test-pattern-design">Test Pattern Design</h4>
<p>The RSI testbench implements a specialized test pattern:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_array[<span class="hljs-number">0</span>:<span class="hljs-number">19</span>];

<span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Create pattern of rising and falling prices</span>
    price_array[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">20</span>; i = i + <span class="hljs-number">1</span>)
        price_array[i] = price_array[i - <span class="hljs-number">1</span>] + ((i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) ? <span class="hljs-number">3</span> : -<span class="hljs-number">2</span>);
</div></code></pre>
<p>This creates the sequence:
[100, 98, 101, 99, 102, 100, 103, 101, 104, 102, 105, 103, 106, 104, 107, 105, 108, 106, 109, 107]</p>
<p>Key pattern features:</p>
<ul>
<li>Initial price: 100</li>
<li>Even indices: Price increases by 3</li>
<li>Odd indices: Price decreases by 2</li>
<li>Alternating gains and losses</li>
<li>Predictable final RSI value</li>
<li>Controlled test scenario</li>
<li>Comprehensive functionality test</li>
</ul>
<p>This pattern exercises both gain and loss accumulation paths.</p>
<h4 id="rsi-calculation-verification">RSI Calculation Verification</h4>
<p>The testbench implements basic verification of the RSI calculation:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">wait</span> (done);
<span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;RSI Value = %d&quot;</span>, rsi);
<span class="hljs-built_in">$finish</span>;
</div></code></pre>
<p>The expected calculation for the test pattern:</p>
<ul>
<li>Total gain sum = 9  3 = 27</li>
<li>Total loss sum = 9  2 = 18</li>
<li>RSI = 100 * 27 / (27 + 18) = 100 * 27 / 45 = 60</li>
</ul>
<p>The testbench verifies that the calculated RSI matches this expected value through manual inspection of the output.</p>
<p>For production testing, automated verification would be preferable:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Automated verification (not in original code)</span>
<span class="hljs-keyword">localparam</span> EXPECTED_RSI = <span class="hljs-number">60</span>;

<span class="hljs-keyword">if</span> (rsi == EXPECTED_RSI)
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST PASSED: RSI = %d (Expected %d)&quot;</span>, rsi, EXPECTED_RSI);
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST FAILED: RSI = %d (Expected %d)&quot;</span>, rsi, EXPECTED_RSI);
</div></code></pre>
<p>This would enable automated pass/fail determination.</p>
<h4 id="state-machine-testing">State Machine Testing</h4>
<p>The testbench implicitly tests the RSI state machine through the complete calculation sequence:</p>
<ol>
<li>
<p><strong>Reset Testing</strong></p>
<pre class="hljs"><code><div>rst = <span class="hljs-number">1</span>;
#<span class="hljs-number">20</span> rst = <span class="hljs-number">0</span>;
</div></code></pre>
<ul>
<li>Initializes all state machine elements</li>
<li>Verifies proper reset behavior</li>
<li>Establishes known starting state</li>
<li>Tests reset path of the state machine</li>
</ul>
</li>
<li>
<p><strong>Start Signal Testing</strong></p>
<pre class="hljs"><code><div>#<span class="hljs-number">10</span> start = <span class="hljs-number">1</span>;
#<span class="hljs-number">10</span> start = <span class="hljs-number">0</span>;
</div></code></pre>
<ul>
<li>Tests IDLE  FILL_FIFO transition</li>
<li>Verifies proper start signal handling</li>
<li>Validates initial state transition</li>
<li>Confirms edge-triggered behavior</li>
</ul>
</li>
<li>
<p><strong>FIFO Filling Testing</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
    @(<span class="hljs-keyword">posedge</span> clk);
    price_in = price_array[i];
    new_price = <span class="hljs-number">1</span>;
    @(<span class="hljs-keyword">posedge</span> clk);
    new_price = <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Tests FILL_FIFO state behavior</li>
<li>Verifies price storage operations</li>
<li>Validates FIFO control</li>
<li>Tests transition to READ_INIT</li>
</ul>
</li>
<li>
<p><strong>Calculation Testing</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">wait</span> (done);
</div></code></pre>
<ul>
<li>Tests complete calculation sequence</li>
<li>Verifies all state transitions</li>
<li>Validates calculation result</li>
<li>Confirms proper completion</li>
</ul>
</li>
</ol>
<p>This test sequence implicitly exercises all states and transitions.</p>
<h4 id="comprehensive-test-cases">Comprehensive Test Cases</h4>
<p>The testbench implements a specific test case designed to verify RSI calculation. For comprehensive verification, additional test cases would be valuable:</p>
<ol>
<li>
<p><strong>All Rising Prices</strong></p>
<ul>
<li>Create a sequence of consistently increasing prices</li>
<li>Expected RSI = 100 (all gains, no losses)</li>
<li>Tests gain accumulation path</li>
<li>Verifies boundary condition handling</li>
</ul>
</li>
<li>
<p><strong>All Falling Prices</strong></p>
<ul>
<li>Create a sequence of consistently decreasing prices</li>
<li>Expected RSI = 0 (all losses, no gains)</li>
<li>Tests loss accumulation path</li>
<li>Verifies boundary condition handling</li>
</ul>
</li>
<li>
<p><strong>No Price Changes</strong></p>
<ul>
<li>Create a sequence of identical prices</li>
<li>Expected RSI = undefined (no gains or losses)</li>
<li>Tests division by zero protection</li>
<li>Verifies edge case handling</li>
</ul>
</li>
<li>
<p><strong>Mixed Pattern with Zeros</strong></p>
<ul>
<li>Create a sequence with zero and non-zero changes</li>
<li>Tests mixed accumulation paths</li>
<li>Verifies correct gain/loss discrimination</li>
<li>Tests arithmetic robustness</li>
</ul>
</li>
<li>
<p><strong>Extreme Values</strong></p>
<ul>
<li>Create a sequence with maximum/minimum values</li>
<li>Tests arithmetic range handling</li>
<li>Verifies overflow protection</li>
<li>Tests calculation accuracy under extreme conditions</li>
</ul>
</li>
</ol>
<p>These test cases would provide comprehensive verification of the RSI calculation.</p>
<h4 id="edge-case-handling-verification">Edge Case Handling Verification</h4>
<p>The testbench should verify proper edge case handling:</p>
<ol>
<li>
<p><strong>Division by Zero</strong></p>
<ul>
<li>Test scenario with no price changes</li>
<li>Verify handling of gain_sum + loss_sum = 0</li>
<li>Expected behavior: RSI = 0</li>
<li>Tests protection logic in DONE state</li>
</ul>
</li>
<li>
<p><strong>FIFO Edge Cases</strong></p>
<ul>
<li>Test behavior with empty FIFO</li>
<li>Test transition from not full to full</li>
<li>Verify proper pointer management</li>
<li>Test FIFO access timing</li>
</ul>
</li>
<li>
<p><strong>Reset During Operation</strong></p>
<ul>
<li>Apply reset during FIFO filling</li>
<li>Apply reset during calculation</li>
<li>Verify clean state clearing</li>
<li>Test recovery after reset</li>
</ul>
</li>
<li>
<p><strong>Timing Edge Cases</strong></p>
<ul>
<li>Variable timing between new prices</li>
<li>Rapid succession of new prices</li>
<li>Irregular price input timing</li>
<li>Verify robust timing behavior</li>
</ul>
</li>
<li>
<p><strong>Boundary Value Analysis</strong></p>
<ul>
<li>Test with minimum price values</li>
<li>Test with maximum price values</li>
<li>Test with adjacent price values</li>
<li>Verify calculation accuracy at boundaries</li>
</ul>
</li>
</ol>
<p>These edge case tests would enhance verification robustness.</p>
<h4 id="result-validation-approach">Result Validation Approach</h4>
<p>The testbench uses a simple result validation approach:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">wait</span> (done);
<span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;RSI Value = %d&quot;</span>, rsi);
</div></code></pre>
<p>This requires manual inspection of the output and comparison with the expected value.</p>
<p>For a more robust approach, automated validation and comprehensive result analysis would be preferable:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Automated validation (not in original code)</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rsi == <span class="hljs-number">60</span>) <span class="hljs-keyword">begin</span>
            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST PASSED: RSI = %d (Expected 60)&quot;</span>, rsi);
            test_passed = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST FAILED: RSI = %d (Expected 60)&quot;</span>, rsi);
            test_failed = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Test timeout and completion</span>
<span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    #<span class="hljs-number">10000</span>;  <span class="hljs-comment">// Maximum simulation time</span>
    <span class="hljs-keyword">if</span> (!test_passed &amp;&amp; !test_failed)
        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;TEST FAILED: Timeout - done signal not asserted&quot;</span>);
    <span class="hljs-built_in">$finish</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<p>This approach would provide automated pass/fail determination and timeout protection.</p>
<h3 id="trading-system-testbench">Trading System Testbench</h3>
<h4 id="end-to-end-testing-strategy">End-to-End Testing Strategy</h4>
<p>The Trading System testbench implements a comprehensive end-to-end testing strategy:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> tb_trading_system_singlemem;
    <span class="hljs-comment">// Signal declarations and module instantiation</span>
    
    <span class="hljs-comment">// Test price array</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] prices [<span class="hljs-number">0</span>:<span class="hljs-number">13</span>];
    
    <span class="hljs-comment">// Test sequence</span>
    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Initialize prices</span>
        prices[ <span class="hljs-number">0</span>] = <span class="hljs-number">16&#x27;d10234</span>; prices[ <span class="hljs-number">1</span>] = <span class="hljs-number">16&#x27;d10380</span>;
        prices[ <span class="hljs-number">2</span>] = <span class="hljs-number">16&#x27;d10125</span>; prices[ <span class="hljs-number">3</span>] = <span class="hljs-number">16&#x27;d10490</span>;
        <span class="hljs-comment">// Additional prices...</span>
        
        <span class="hljs-comment">// Reset system</span>
        rst = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">repeat</span> (<span class="hljs-number">5</span>) @(<span class="hljs-keyword">posedge</span> clk);
        rst = <span class="hljs-number">0</span>;
        
        <span class="hljs-comment">// Feed prices</span>
        index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (index &lt; <span class="hljs-number">14</span>) <span class="hljs-keyword">begin</span>
            price_in = prices[index];
            new_price = <span class="hljs-number">1</span>;
            index = index + <span class="hljs-number">1</span>;
            @(<span class="hljs-keyword">posedge</span> clk);
            new_price = <span class="hljs-number">0</span>;
            @(<span class="hljs-keyword">posedge</span> clk);
        <span class="hljs-keyword">end</span>
        
        <span class="hljs-comment">// Wait for completion</span>
        <span class="hljs-keyword">wait</span> (mem_cnt == <span class="hljs-number">14</span>);
        
        <span class="hljs-comment">// Run additional time for calculation</span>
        #<span class="hljs-number">2000</span>;
        
        <span class="hljs-comment">// End simulation</span>
        <span class="hljs-built_in">$finish</span>;
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Monitoring</span>
    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Time | Price | MA | RSI | BUY | SELL&quot;</span>);
        <span class="hljs-built_in">$monitor</span>(<span class="hljs-string">&quot;%4t | %d | %d | %d | %b | %b&quot;</span>,
                 <span class="hljs-built_in">$time</span>, price_in, moving_avg, rsi, buy, sell);
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This strategy provides:</p>
<ul>
<li>Complete system verification</li>
<li>End-to-end data flow testing</li>
<li>Component interaction validation</li>
<li>Realistic operational scenario</li>
<li>Comprehensive signal monitoring</li>
<li>Deterministic test sequence</li>
<li>Clear success criteria</li>
</ul>
<p>This approach verifies the entire system as an integrated unit.</p>
<h4 id="integration-test-methodology">Integration Test Methodology</h4>
<p>The testbench implements an integration-focused methodology:</p>
<ol>
<li>
<p><strong>Top-Down Integration</strong></p>
<ul>
<li>Tests the complete system</li>
<li>Verifies all module interactions</li>
<li>Validates end-to-end functionality</li>
<li>Ensures proper signal propagation</li>
<li>Tests realistic operational scenarios</li>
</ul>
</li>
<li>
<p><strong>Black-Box Testing</strong></p>
<ul>
<li>Treats the system as a whole</li>
<li>Focuses on input/output relationships</li>
<li>Validates external behavior</li>
<li>Simulates real-world usage</li>
<li>Verifies functional requirements</li>
</ul>
</li>
<li>
<p><strong>Data Flow Testing</strong></p>
<ul>
<li>Follows data through the complete system</li>
<li>Verifies proper transformation at each stage</li>
<li>Validates correct calculation results</li>
<li>Ensures appropriate signal generation</li>
<li>Tests end-to-end processing chain</li>
</ul>
</li>
</ol>
<p>This methodology provides comprehensive system validation.</p>
<h4 id="signal-validation-techniques">Signal Validation Techniques</h4>
<p>The testbench implements several signal validation techniques:</p>
<ol>
<li>
<p><strong>Waveform Generation</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-built_in">$dumpfile</span>(<span class="hljs-string">&quot;trading_system.vcd&quot;</span>);
    <span class="hljs-built_in">$dumpvars</span>(<span class="hljs-number">0</span>, tb_trading_system_singlemem);
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Creates waveform file for visual inspection</li>
<li>Captures all signal transitions</li>
<li>Enables detailed timing analysis</li>
<li>Provides comprehensive signal history</li>
<li>Facilitates debugging and verification</li>
</ul>
</li>
<li>
<p><strong>Console Output</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Time | Price | MA | RSI | BUY | SELL&quot;</span>);
    <span class="hljs-built_in">$monitor</span>(<span class="hljs-string">&quot;%4t | %d | %d | %d | %b | %b&quot;</span>,
             <span class="hljs-built_in">$time</span>, price_in, moving_avg, rsi, buy, sell);
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Shows key signals in tabular format</li>
<li>Updates on signal changes</li>
<li>Provides human-readable output</li>
<li>Enables quick result validation</li>
<li>Documents test progression</li>
</ul>
</li>
<li>
<p><strong>Status Checking</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">wait</span> (mem_cnt == <span class="hljs-number">14</span>);
<span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;SUCCESS: FIFO memory filled with 14 prices.&quot;</span>);
</div></code></pre>
<ul>
<li>Verifies system state transitions</li>
<li>Confirms operational milestones</li>
<li>Validates proper functionality</li>
<li>Provides progress indication</li>
<li>Confirms test progression</li>
</ul>
</li>
</ol>
<p>These techniques enable comprehensive signal validation.</p>
<h4 id="system-level-timing-verification">System-Level Timing Verification</h4>
<p>The testbench enables verification of system-level timing:</p>
<ol>
<li>
<p><strong>Clock Domain Verification</strong></p>
<ul>
<li>All modules operate on the same clock</li>
<li>Synchronized operation throughout the system</li>
<li>No clock domain crossing issues</li>
<li>Clean timing relationships</li>
<li>Predictable system behavior</li>
</ul>
</li>
<li>
<p><strong>Signal Propagation Timing</strong></p>
<ul>
<li>Input signals properly sampled</li>
<li>State transitions occur on clock edges</li>
<li>Output signals updated synchronously</li>
<li>Clean handshaking between modules</li>
<li>Deterministic end-to-end timing</li>
</ul>
</li>
<li>
<p><strong>Calculation Latency</strong></p>
<ul>
<li>Price inputs at regular intervals</li>
<li>Indicator calculation timing</li>
<li>Result propagation to decision logic</li>
<li>Signal generation timing</li>
<li>End-to-end system latency</li>
</ul>
</li>
<li>
<p><strong>Reset Timing</strong></p>
<ul>
<li>Asynchronous reset assertion</li>
<li>Synchronous reset deassertion</li>
<li>Clean system initialization</li>
<li>Proper state machine reset</li>
<li>Consistent initial conditions</li>
</ul>
</li>
</ol>
<p>These aspects ensure proper system timing behavior.</p>
<h4 id="output-analysis-and-reporting">Output Analysis and Reporting</h4>
<p>The testbench implements comprehensive output analysis:</p>
<ol>
<li>
<p><strong>Tabular Output</strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Time | Price | MA | RSI | BUY | SELL&quot;</span>);
<span class="hljs-built_in">$monitor</span>(<span class="hljs-string">&quot;%4t | %d | %d | %d | %b | %b&quot;</span>,
         <span class="hljs-built_in">$time</span>, price_in, moving_avg, rsi, buy, sell);
</div></code></pre>
<ul>
<li>Shows all key system values</li>
<li>Updates on any signal change</li>
<li>Provides clear correlation between signals</li>
<li>Enables trend analysis</li>
<li>Documents system behavior</li>
</ul>
</li>
<li>
<p><strong>Status Messages</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">wait</span> (mem_cnt == <span class="hljs-number">14</span>);
<span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;SUCCESS: FIFO memory filled with 14 prices.&quot;</span>);
</div></code></pre>
<ul>
<li>Indicates test progress</li>
<li>Confirms operational milestones</li>
<li>Provides clear success/failure indication</li>
<li>Documents test execution</li>
<li>Enables quick validation</li>
</ul>
</li>
<li>
<p><strong>Final State Analysis</strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Final Check -&gt; Time: %0t | FIFO Count: %d | Memory Full: %b&quot;</span>,
         <span class="hljs-built_in">$time</span>, mem_cnt, mem_full);
</div></code></pre>
<ul>
<li>Shows final system state</li>
<li>Confirms proper test completion</li>
<li>Provides summary information</li>
<li>Enables final validation</li>
<li>Documents test results</li>
</ul>
</li>
</ol>
<p>These reporting mechanisms enable comprehensive output analysis.</p>
<h4 id="regression-testing-framework">Regression Testing Framework</h4>
<p>The testbench provides a foundation for regression testing:</p>
<ol>
<li>
<p><strong>Test Sequence Automation</strong></p>
<ul>
<li>Deterministic test execution</li>
<li>Automatic price data generation</li>
<li>Predictable test flow</li>
<li>No manual intervention required</li>
<li>Suitable for automated regression</li>
</ul>
</li>
<li>
<p><strong>Clear Success Criteria</strong></p>
<ul>
<li>Buffer filling verification</li>
<li>Indicator calculation validation</li>
<li>Signal generation confirmation</li>
<li>System state validation</li>
<li>Explicit success indication</li>
</ul>
</li>
<li>
<p><strong>Standard Output Format</strong></p>
<ul>
<li>Consistent reporting structure</li>
<li>Machine-parsable output</li>
<li>Clear status messages</li>
<li>Standardized test reporting</li>
<li>Suitable for automated analysis</li>
</ul>
</li>
<li>
<p><strong>Extensible Framework</strong></p>
<ul>
<li>Easy addition of new test cases</li>
<li>Modifiable test parameters</li>
<li>Configurable test sequence</li>
<li>Adaptable verification method</li>
<li>Support for comprehensive test suites</li>
</ul>
</li>
</ol>
<p>With minor enhancements, this framework could support full regression testing capabilities.</p>
<h3 id="verification-methodology">Verification Methodology</h3>
<h4 id="unit-testing-approach">Unit Testing Approach</h4>
<p>The project implements unit testing through dedicated testbenches for key components:</p>
<ol>
<li>
<p><strong>Moving Average Unit Testing</strong></p>
<ul>
<li><code>trading_system_tb.v</code> tests the moving average calculation</li>
<li>Focuses on correct calculation results</li>
<li>Verifies buffer filling and management</li>
<li>Tests FSM operation and state transitions</li>
<li>Validates proper output generation</li>
</ul>
</li>
<li>
<p><strong>RSI Unit Testing</strong></p>
<ul>
<li><code>rsi_testbench.v</code> tests the RSI calculation</li>
<li>Verifies correct gain/loss accumulation</li>
<li>Tests final RSI formula implementation</li>
<li>Validates FSM state transitions</li>
<li>Confirms proper edge case handling</li>
</ul>
</li>
<li>
<p><strong>Trading Decision Unit Testing</strong></p>
<ul>
<li>Implicit testing through system-level tests</li>
<li>Verifies correct signal generation</li>
<li>Tests threshold comparison logic</li>
<li>Validates proper reset behavior</li>
<li>Confirms appropriate output timing</li>
</ul>
</li>
</ol>
<p>This approach ensures proper functionality of individual components before integration.</p>
<h4 id="directed-testing">Directed Testing</h4>
<p>The project employs directed testing with specific test vectors:</p>
<ol>
<li>
<p><strong>Moving Average Test Vector</strong></p>
<ul>
<li>Linear sequence of increasing prices (1000 to 1045)</li>
<li>Predictable average calculation</li>
<li>Clear expected results</li>
<li>Simple verification approach</li>
<li>Tests basic functionality</li>
</ul>
</li>
<li>
<p><strong>RSI Test Vector</strong></p>
<ul>
<li>Alternating gain/loss pattern</li>
<li>Known RSI calculation result (60)</li>
<li>Exercises both accumulation paths</li>
<li>Tests final formula calculation</li>
<li>Verifies correct implementation</li>
</ul>
</li>
<li>
<p><strong>System Test Vector</strong></p>
<ul>
<li>Mixed price sequence with realistic values</li>
<li>Tests end-to-end system operation</li>
<li>Exercises all system components</li>
<li>Validates component interaction</li>
<li>Verifies signal generation</li>
</ul>
</li>
</ol>
<p>These directed tests provide targeted verification of specific functionality.</p>
<h4 id="functional-verification">Functional Verification</h4>
<p>The project implements functional verification through system-level testing:</p>
<ol>
<li>
<p><strong>Requirement Verification</strong></p>
<ul>
<li>Moving average calculation accuracy</li>
<li>RSI calculation correctness</li>
<li>Trading signal generation based on conditions</li>
<li>Proper system initialization</li>
<li>Correct handling of price data</li>
</ul>
</li>
<li>
<p><strong>Feature Testing</strong></p>
<ul>
<li>Price memory management</li>
<li>Indicator calculation</li>
<li>Trading decision logic</li>
<li>System synchronization</li>
<li>End-to-end data flow</li>
</ul>
</li>
<li>
<p><strong>Protocol Verification</strong></p>
<ul>
<li>Proper signal timing</li>
<li>Correct handshaking</li>
<li>Valid state transitions</li>
<li>Proper reset behavior</li>
<li>Clean signal propagation</li>
</ul>
</li>
</ol>
<p>This approach ensures the system meets its functional requirements.</p>
<h4 id="assertion-based-verification">Assertion-Based Verification</h4>
<p>The project does not explicitly implement assertion-based verification, but such an approach would enhance testing robustness:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Potential assertions (not in original code)</span>

<span class="hljs-comment">// Memory management assertions</span>
<span class="hljs-keyword">property</span> valid_fifo_count;
    @(<span class="hljs-keyword">posedge</span> clk) (fifo_data_count &lt;= DEPTH);
<span class="hljs-keyword">endproperty</span>
<span class="hljs-keyword">assert</span> <span class="hljs-keyword">property</span>(valid_fifo_count);

<span class="hljs-comment">// Calculation assertions</span>
<span class="hljs-keyword">property</span> valid_rsi_range;
    @(<span class="hljs-keyword">posedge</span> clk) rsi_done |-&gt; (rsi &gt;= <span class="hljs-number">0</span> &amp;&amp; rsi &lt;= <span class="hljs-number">100</span>);
<span class="hljs-keyword">endproperty</span>
<span class="hljs-keyword">assert</span> <span class="hljs-keyword">property</span>(valid_rsi_range);

<span class="hljs-comment">// Signal integrity assertions</span>
<span class="hljs-keyword">property</span> mutually_exclusive_signals;
    @(<span class="hljs-keyword">posedge</span> clk) !(buy &amp;&amp; sell);
<span class="hljs-keyword">endproperty</span>
<span class="hljs-keyword">assert</span> <span class="hljs-keyword">property</span>(mutually_exclusive_signals);
</div></code></pre>
<p>These assertions would provide automatic verification of key properties.</p>
<h4 id="performance-verification">Performance Verification</h4>
<p>The project does not explicitly verify performance metrics, but several aspects could be measured:</p>
<ol>
<li>
<p><strong>Latency Measurement</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Not in original code</span>
<span class="hljs-keyword">integer</span> start_time, end_time;

<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (new_price &amp;&amp; !prev_new_price)
        start_time = <span class="hljs-built_in">$time</span>;
    
    <span class="hljs-keyword">if</span> (ma_done &amp;&amp; !prev_ma_done)
        end_time = <span class="hljs-built_in">$time</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Measures calculation latency</li>
<li>Verifies performance requirements</li>
<li>Validates timing expectations</li>
<li>Documents system responsiveness</li>
<li>Enables optimization evaluation</li>
</ul>
</li>
<li>
<p><strong>Throughput Analysis</strong></p>
<ul>
<li>Maximum price processing rate</li>
<li>Calculation completion rate</li>
<li>Signal generation frequency</li>
<li>System-level throughput</li>
<li>Performance under load</li>
</ul>
</li>
</ol>
<p>These measurements would validate performance characteristics.</p>
<h4 id="coverage-driven-verification">Coverage-Driven Verification</h4>
<p>The project does not implement coverage-driven verification, but such an approach would enhance testing completeness:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Coverage definitions (not in original code)</span>

<span class="hljs-comment">// State coverage</span>
<span class="hljs-keyword">covergroup</span> state_cov @(<span class="hljs-keyword">posedge</span> clk);
    ma_state: <span class="hljs-keyword">coverpoint</span> ma_fsm<span class="hljs-variable">.st</span> {
        <span class="hljs-keyword">bins</span> idle = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">bins</span> calculate = {<span class="hljs-number">1</span>};
        <span class="hljs-keyword">bins</span> done = {<span class="hljs-number">2</span>};
    }
    
    rsi_state: <span class="hljs-keyword">coverpoint</span> rsi_fsm<span class="hljs-variable">.state</span> {
        <span class="hljs-keyword">bins</span> idle = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">bins</span> fill_fifo = {<span class="hljs-number">1</span>};
        <span class="hljs-keyword">bins</span> read_init = {<span class="hljs-number">2</span>};
        <span class="hljs-keyword">bins</span> read_wait = {<span class="hljs-number">3</span>};
        <span class="hljs-keyword">bins</span> compare = {<span class="hljs-number">4</span>};
        <span class="hljs-keyword">bins</span> done = {<span class="hljs-number">5</span>};
    }
<span class="hljs-keyword">endgroup</span>

<span class="hljs-comment">// Value coverage</span>
<span class="hljs-keyword">covergroup</span> value_cov @(<span class="hljs-keyword">posedge</span> clk);
    price_range: <span class="hljs-keyword">coverpoint</span> price_in {
        <span class="hljs-keyword">bins</span> low = {[<span class="hljs-number">0</span>:<span class="hljs-number">10000</span>]};
        <span class="hljs-keyword">bins</span> mid = {[<span class="hljs-number">10001</span>:<span class="hljs-number">20000</span>]};
        <span class="hljs-keyword">bins</span> high = {[<span class="hljs-number">20001</span>:<span class="hljs-number">32767</span>]};
    }
    
    rsi_range: <span class="hljs-keyword">coverpoint</span> rsi {
        <span class="hljs-keyword">bins</span> oversold = {[<span class="hljs-number">0</span>:<span class="hljs-number">30</span>]};
        <span class="hljs-keyword">bins</span> neutral = {[<span class="hljs-number">31</span>:<span class="hljs-number">69</span>]};
        <span class="hljs-keyword">bins</span> overbought = {[<span class="hljs-number">70</span>:<span class="hljs-number">100</span>]};
    }
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<p>This approach would ensure comprehensive test coverage of all states and value ranges.</p>
<h2 id="10-usage-guide">10. Usage Guide</h2>
<h3 id="integration-with-larger-systems">Integration with Larger Systems</h3>
<h4 id="top-level-instantiation">Top-Level Instantiation</h4>
<p>To integrate the trading system into a larger design, use the following instantiation pattern:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// System clock and reset</span>
<span class="hljs-keyword">wire</span> system_clk;  <span class="hljs-comment">// From clock management</span>
<span class="hljs-keyword">wire</span> system_rst;  <span class="hljs-comment">// From reset controller</span>

<span class="hljs-comment">// Market data interface</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] market_price;  <span class="hljs-comment">// From data acquisition</span>
<span class="hljs-keyword">wire</span> market_data_valid;    <span class="hljs-comment">// Price validity signal</span>

<span class="hljs-comment">// Trading signal outputs</span>
<span class="hljs-keyword">wire</span> buy_signal;           <span class="hljs-comment">// To order management</span>
<span class="hljs-keyword">wire</span> sell_signal;          <span class="hljs-comment">// To order management</span>

<span class="hljs-comment">// Status and monitoring</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_value;      <span class="hljs-comment">// To monitoring system</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi_value;      <span class="hljs-comment">// To monitoring system</span>
<span class="hljs-keyword">wire</span> system_ready;         <span class="hljs-comment">// From memory_full</span>

<span class="hljs-comment">// Instantiate trading system</span>
trading_system_singlemem trading_module (
    <span class="hljs-variable">.clk</span>(system_clk),
    <span class="hljs-variable">.rst</span>(system_rst),
    <span class="hljs-variable">.price_in</span>(market_price),
    <span class="hljs-variable">.new_price</span>(market_data_valid),
    <span class="hljs-variable">.moving_avg</span>(ma_value),
    <span class="hljs-variable">.rsi</span>(rsi_value),
    <span class="hljs-variable">.buy</span>(buy_signal),
    <span class="hljs-variable">.sell</span>(sell_signal),
    <span class="hljs-variable">.mem_full</span>(system_ready),
    <span class="hljs-variable">.mem_cnt</span>(),              <span class="hljs-comment">// Optional monitoring</span>
    <span class="hljs-variable">.oldest_price</span>(),         <span class="hljs-comment">// Optional monitoring</span>
    <span class="hljs-variable">.ma_done</span>(),              <span class="hljs-comment">// Optional handshaking</span>
    <span class="hljs-variable">.rsi_done</span>()              <span class="hljs-comment">// Optional handshaking</span>
);
</div></code></pre>
<p>This pattern connects the trading system to the larger environment, providing:</p>
<ul>
<li>Clock and reset integration</li>
<li>Market data input connection</li>
<li>Trading signal output routing</li>
<li>Status and monitoring connections</li>
<li>Optional signal availability</li>
</ul>
<p>Unused outputs can be left unconnected if not needed.</p>
<h4 id="signal-connection-guidelines">Signal Connection Guidelines</h4>
<p>Follow these guidelines when connecting the system to external components:</p>
<ol>
<li>
<p><strong>Clock and Reset</strong></p>
<ul>
<li>Provide stable clock with controlled skew</li>
<li>Reset must be asynchronously asserted, synchronously deasserted</li>
<li>Hold reset active for multiple clock cycles during initialization</li>
<li>Ensure clean reset deassertion aligned with clock edge</li>
</ul>
</li>
<li>
<p><strong>Price Input</strong></p>
<ul>
<li>Connect to market data acquisition system</li>
<li>Ensure <code>price_in</code> is valid when <code>new_price</code> is asserted</li>
<li>Assert <code>new_price</code> for exactly one clock cycle per price</li>
<li>Maintain price stability during the entire assertion period</li>
<li>Provide sufficient spacing between price updates</li>
</ul>
</li>
<li>
<p><strong>Indicator Outputs</strong></p>
<ul>
<li>Connect to monitoring or visualization systems</li>
<li>Treat as valid only after appropriate <code>done</code> signals</li>
<li>Consider registering at destination for timing isolation</li>
<li>Monitor for expected value ranges</li>
<li>Use for system health verification</li>
</ul>
</li>
<li>
<p><strong>Trading Signals</strong></p>
<ul>
<li>Connect to order management system</li>
<li>Implement appropriate filtering if needed</li>
<li>Consider adding persistence requirements</li>
<li>Ensure proper reset handling</li>
<li>Add protection against rapid oscillation if required</li>
</ul>
</li>
<li>
<p><strong>Status Signals</strong></p>
<ul>
<li>Use <code>mem_full</code> as system ready indicator</li>
<li>Monitor <code>mem_cnt</code> for initialization tracking</li>
<li>Connect <code>ma_done</code> and <code>rsi_done</code> if synchronization needed</li>
<li>Consider adding external watchdog monitoring</li>
<li>Implement appropriate status logging</li>
</ul>
</li>
</ol>
<p>These connections establish clear interfaces between the trading system and external components.</p>
<h4 id="clocking-considerations">Clocking Considerations</h4>
<p>When integrating the system, consider these clocking aspects:</p>
<ol>
<li>
<p><strong>Clock Source</strong></p>
<ul>
<li>Provide stable, low-jitter clock source</li>
<li>Typical frequency: 100 MHz (10ns period)</li>
<li>Use global clock resources for distribution</li>
<li>Consider using dedicated PLL/MMCM for clock conditioning</li>
<li>Ensure sufficient margin in timing constraints</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Management</strong></p>
<ul>
<li>Keep all components in the same clock domain if possible</li>
<li>If crossing domains is necessary, implement proper synchronization:<pre class="hljs"><code><div><span class="hljs-comment">// Example synchronizer for crossing domains</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sync_new_price;
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> system_clk) <span class="hljs-keyword">begin</span>
    sync_new_price &lt;= {sync_new_price[<span class="hljs-number">0</span>], ext_new_price};
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Edge detection in destination domain</span>
<span class="hljs-keyword">wire</span> new_price_pulse = sync_new_price == <span class="hljs-number">2&#x27;b01</span>;
</div></code></pre>
</li>
<li>Use gray coding for multi-bit transfers across domains</li>
<li>Implement proper constraints for CDC paths</li>
<li>Document all clock domain crossings</li>
</ul>
</li>
<li>
<p><strong>Clock Distribution</strong></p>
<ul>
<li>Use dedicated clock networks</li>
<li>Maintain controlled skew</li>
<li>Implement appropriate buffering</li>
<li>Consider regional clock resources for larger designs</li>
<li>Document clock tree architecture</li>
</ul>
</li>
<li>
<p><strong>Timing Constraints</strong></p>
<ul>
<li>Define appropriate clock constraints:<pre class="hljs"><code><div>create_clock -period 10.000 -name system_clk [get_ports system_clk]
</div></code></pre>
</li>
<li>Set realistic input/output delays</li>
<li>Identify false paths where appropriate</li>
<li>Add appropriate clock uncertainty</li>
<li>Ensure proper timing analysis and closure</li>
</ul>
</li>
</ol>
<p>These considerations ensure reliable clocking throughout the system.</p>
<h4 id="reset-management">Reset Management</h4>
<p>Proper reset management is critical for system integration:</p>
<ol>
<li>
<p><strong>Reset Source</strong></p>
<ul>
<li>Connect to system-wide reset controller</li>
<li>Ensure proper power-on reset generation</li>
<li>Consider adding watchdog reset capability</li>
<li>Implement manual reset option if needed</li>
<li>Document reset dependencies</li>
</ul>
</li>
<li>
<p><strong>Reset Distribution</strong></p>
<ul>
<li>Use low-skew network for distribution</li>
<li>Buffer reset signal appropriately</li>
<li>Fan out properly to all components</li>
<li>Maintain synchronous deassertion</li>
<li>Consider reset tree hierarchy for large systems</li>
</ul>
</li>
<li>
<p><strong>Reset Timing</strong></p>
<ul>
<li>Assert reset asynchronously (active high)</li>
<li>Hold reset for multiple clock cycles (10+ recommended)</li>
<li>Deassertion synchronized to clock edge:<pre class="hljs"><code><div><span class="hljs-comment">// Synchronous reset deassertion</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] reset_sync;
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (raw_reset)
        reset_sync &lt;= <span class="hljs-number">3&#x27;b111</span>;
    <span class="hljs-keyword">else</span>
        reset_sync &lt;= {reset_sync[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>], <span class="hljs-number">1&#x27;b0</span>};
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">wire</span> synchronized_reset = reset_sync[<span class="hljs-number">2</span>];
</div></code></pre>
</li>
<li>Ensure all components see reset deassertion on same cycle</li>
<li>Document reset timing requirements</li>
</ul>
</li>
<li>
<p><strong>Post-Reset Sequence</strong></p>
<ul>
<li>Allow sufficient time for memory initialization</li>
<li>Monitor <code>mem_cnt</code> to track buffer filling progress</li>
<li>Wait for <code>mem_full</code> assertion before using results</li>
<li>Implement appropriate timeout monitoring</li>
<li>Document expected post-reset behavior</li>
</ul>
</li>
</ol>
<p>These guidelines ensure proper system initialization and recovery.</p>
<h4 id="interface-protocol">Interface Protocol</h4>
<p>The trading system uses a simple interface protocol:</p>
<ol>
<li>
<p><strong>Price Data Input Protocol</strong></p>
<ul>
<li><code>price_in</code>: Valid price data</li>
<li><code>new_price</code>: One-cycle pulse indicating valid data</li>
<li>No backpressure mechanism (always ready)</li>
<li>No handshaking required</li>
<li>Sequential price feeding</li>
</ul>
</li>
<li>
<p><strong>Indicator Output Protocol</strong></p>
<ul>
<li><code>moving_avg</code>, <code>rsi</code>: Calculation results</li>
<li><code>ma_done</code>, <code>rsi_done</code>: One-cycle pulses indicating completion</li>
<li>Results valid when done signals are asserted</li>
<li>Values stable between updates</li>
<li>Independent timing for each indicator</li>
</ul>
</li>
<li>
<p><strong>Signal Output Protocol</strong></p>
<ul>
<li><code>buy</code>, <code>sell</code>: Trading signals</li>
<li>Level-sensitive (remain active while conditions met)</li>
<li>Mutually exclusive by design</li>
<li>Update after indicator calculation</li>
<li>Reset clears both signals</li>
</ul>
</li>
<li>
<p><strong>Status Protocol</strong></p>
<ul>
<li><code>mem_full</code>: Level-sensitive ready indicator</li>
<li><code>mem_cnt</code>: Current buffer fill level</li>
<li>States reflect internal system status</li>
<li>Continuous status indication</li>
<li>No explicit acknowledgment required</li>
</ul>
</li>
</ol>
<p>This protocol design balances simplicity with clear timing relationships.</p>
<h4 id="data-formatting-requirements">Data Formatting Requirements</h4>
<p>The system expects specific data formats:</p>
<ol>
<li>
<p><strong>Price Format</strong></p>
<ul>
<li>16-bit unsigned integer</li>
<li>Represents price value directly</li>
<li>No decimal point (implied fixed-point)</li>
<li>Range: 0 to 65,535</li>
<li>Consider pre-scaling if required:<pre class="hljs"><code><div><span class="hljs-comment">// Example: Convert external price format to system format</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] system_price = external_price[<span class="hljs-number">23</span>:<span class="hljs-number">8</span>]; <span class="hljs-comment">// Extract upper bits</span>
<span class="hljs-comment">// OR</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] system_price = external_price &gt;&gt; <span class="hljs-number">8</span>; <span class="hljs-comment">// Shift 8 bits</span>
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Indicator Output Format</strong></p>
<ul>
<li>Moving Average: 32-bit unsigned integer
<ul>
<li>Integer representation</li>
<li>Same scale as input prices</li>
<li>Upper 16 bits typically zero (unless very large prices)</li>
</ul>
</li>
<li>RSI: 8-bit unsigned integer
<ul>
<li>Range: 0 to 100</li>
<li>Integer percentage representation</li>
<li>No decimal point</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Signal Format</strong></p>
<ul>
<li>Single-bit active high</li>
<li>1'b1: Signal active</li>
<li>1'b0: Signal inactive</li>
<li>Level-sensitive (not edge-triggered)</li>
<li>Held active while conditions remain met</li>
</ul>
</li>
<li>
<p><strong>Status Format</strong></p>
<ul>
<li><code>mem_full</code>: Single-bit active high</li>
<li><code>mem_cnt</code>: 5-bit unsigned counter (0-31)</li>
<li>Binary representation</li>
<li>Direct indicator of buffer state</li>
</ul>
</li>
</ol>
<p>These format specifications ensure proper data interpretation throughout the system.</p>
<h3 id="parameter-configuration">Parameter Configuration</h3>
<h4 id="moving-average-configuration">Moving Average Configuration</h4>
<p>The Moving Average module supports parameterized configuration:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> moving_average_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,  <span class="hljs-comment">// Window size for moving average</span>
    <span class="hljs-keyword">parameter</span> DW     = <span class="hljs-number">16</span>   <span class="hljs-comment">// Data width for prices</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<p>Key configuration parameters:</p>
<ol>
<li>
<p><strong>WINDOW Parameter</strong></p>
<ul>
<li>Default: 20 periods</li>
<li>Common alternatives:
<ul>
<li>5, 10: Very short-term trend</li>
<li>20, 21: Short-term trend (standard)</li>
<li>50: Medium-term trend</li>
<li>100, 200: Long-term trend</li>
</ul>
</li>
<li>Trading strategy considerations:
<ul>
<li>Smaller windows: More responsive, more noise</li>
<li>Larger windows: Smoother, more lag</li>
<li>Multiple windows: Crossover strategies</li>
</ul>
</li>
<li>Resource impact:
<ul>
<li>Minimal effect on resource utilization</li>
<li>Primarily affects price memory size</li>
<li>No impact on calculation complexity (O(1))</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>DW Parameter (Data Width)</strong></p>
<ul>
<li>Default: 16 bits</li>
<li>Common alternatives:
<ul>
<li>8-bit: Limited price range, minimal resources</li>
<li>16-bit: Standard for most applications</li>
<li>24-bit: High-precision or high-value instruments</li>
<li>32-bit: Maximum precision, higher resource usage</li>
</ul>
</li>
<li>Representation considerations:
<ul>
<li>Implied fixed-point positioning</li>
<li>Scale factor must match across modules</li>
<li>Potential overflow in extreme cases</li>
</ul>
</li>
<li>Resource impact:
<ul>
<li>Linear scaling with width</li>
<li>Affects memory and register usage</li>
<li>Influences arithmetic complexity</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Configuration Examples</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Short-term trend detection</span>
moving_average_fsm #(
    <span class="hljs-variable">.WINDOW</span>(<span class="hljs-number">10</span>),
    <span class="hljs-variable">.DW</span>(<span class="hljs-number">16</span>)
) ma_short (
    <span class="hljs-comment">// Port connections...</span>
);

<span class="hljs-comment">// Long-term trend detection</span>
moving_average_fsm #(
    <span class="hljs-variable">.WINDOW</span>(<span class="hljs-number">200</span>),
    <span class="hljs-variable">.DW</span>(<span class="hljs-number">16</span>)
) ma_long (
    <span class="hljs-comment">// Port connections...</span>
);
</div></code></pre>
</li>
</ol>
<p>These parameters enable customization for different trading strategies and market conditions.</p>
<h4 id="rsi-configuration">RSI Configuration</h4>
<p>The RSI module also supports parameterized configuration:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> rsi_inc #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">14</span>,  <span class="hljs-comment">// Period for RSI calculation</span>
    <span class="hljs-keyword">parameter</span> DW     = <span class="hljs-number">16</span>   <span class="hljs-comment">// Data width for prices</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<p>Key configuration parameters:</p>
<ol>
<li>
<p><strong>WINDOW Parameter</strong></p>
<ul>
<li>Default: 14 periods (standard Wilder parameter)</li>
<li>Common alternatives:
<ul>
<li>9: More responsive, used for short-term strategies</li>
<li>14: Standard setting (Wilder's original)</li>
<li>21, 25: Smoother oscillation, less noise</li>
</ul>
</li>
<li>Trading strategy considerations:
<ul>
<li>Smaller windows: More signals, higher false positive rate</li>
<li>Larger windows: Fewer signals, may miss opportunities</li>
<li>Multiple RSIs: Confirmation across timeframes</li>
</ul>
</li>
<li>Resource impact:
<ul>
<li>Affects FIFO depth and sample count</li>
<li>Minimal effect on calculation logic</li>
<li>Influences overall latency</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>DW Parameter (Data Width)</strong></p>
<ul>
<li>Default: 16 bits</li>
<li>Same considerations as Moving Average</li>
<li>Must match across system for consistency</li>
<li>Affects price storage and comparison precision</li>
</ul>
</li>
<li>
<p><strong>Implementation Note</strong>:</p>
<ul>
<li>The actual calculation period is (WINDOW-1)</li>
<li>This accounts for price differences calculation</li>
<li>e.g., WINDOW=14 means 13 price differences</li>
<li>Consistent with standard RSI implementation</li>
<li>Documentation should reflect this behavior</li>
</ul>
</li>
<li>
<p><strong>Configuration Examples</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Responsive RSI for short-term trading</span>
rsi_inc #(
    <span class="hljs-variable">.WINDOW</span>(<span class="hljs-number">9</span>),
    <span class="hljs-variable">.DW</span>(<span class="hljs-number">16</span>)
) rsi_short (
    <span class="hljs-comment">// Port connections...</span>
);

<span class="hljs-comment">// Standard RSI configuration</span>
rsi_inc #(
    <span class="hljs-variable">.WINDOW</span>(<span class="hljs-number">14</span>),
    <span class="hljs-variable">.DW</span>(<span class="hljs-number">16</span>)
) rsi_standard (
    <span class="hljs-comment">// Port connections...</span>
);
</div></code></pre>
</li>
</ol>
<p>These parameters enable RSI customization for different trading approaches.</p>
<h4 id="trading-threshold-configuration">Trading Threshold Configuration</h4>
<p>The Trading Decision module supports customizable thresholds:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_decision #(
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR  = <span class="hljs-number">8&#x27;d30</span>,  <span class="hljs-comment">// RSI threshold for buy signals</span>
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">8&#x27;d70</span>   <span class="hljs-comment">// RSI threshold for sell signals</span>
)(
    <span class="hljs-comment">// Port list...</span>
);
</div></code></pre>
<p>Key configuration parameters:</p>
<ol>
<li>
<p><strong>BUY_RSI_THR Parameter</strong></p>
<ul>
<li>Default: 30 (standard oversold level)</li>
<li>Common alternatives:
<ul>
<li>20-25: More aggressive buying (stronger oversold condition)</li>
<li>30-35: Standard range for most markets</li>
<li>40-45: Conservative buying (weaker oversold condition)</li>
</ul>
</li>
<li>Trading strategy considerations:
<ul>
<li>Lower values: Fewer but stronger signals</li>
<li>Higher values: More frequent but weaker signals</li>
<li>Market-specific optimization recommended</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>SELL_RSI_THR Parameter</strong></p>
<ul>
<li>Default: 70 (standard overbought level)</li>
<li>Common alternatives:
<ul>
<li>75-80: More aggressive selling (stronger overbought)</li>
<li>65-70: Standard range for most markets</li>
<li>55-60: Conservative selling (weaker overbought)</li>
</ul>
</li>
<li>Trading strategy considerations:
<ul>
<li>Higher values: Fewer but stronger signals</li>
<li>Lower values: More frequent but weaker signals</li>
<li>Should balance with BUY_RSI_THR</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Strategy Configuration Examples</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Conservative strategy (fewer signals, stronger conditions)</span>
trading_decision #(
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">20</span>),
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">80</span>)
) conservative_strategy (
    <span class="hljs-comment">// Port connections...</span>
);

<span class="hljs-comment">// Aggressive strategy (more signals, weaker conditions)</span>
trading_decision #(
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">40</span>),
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">60</span>)
) aggressive_strategy (
    <span class="hljs-comment">// Port connections...</span>
);

<span class="hljs-comment">// Asymmetric strategy (buy/sell bias)</span>
trading_decision #(
    <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">35</span>),  <span class="hljs-comment">// More conservative buying</span>
    <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">75</span>)  <span class="hljs-comment">// More conservative selling</span>
) asymmetric_strategy (
    <span class="hljs-comment">// Port connections...</span>
);
</div></code></pre>
</li>
</ol>
<p>These parameters enable fine-tuning of the trading strategy for different market conditions.</p>
<h4 id="parameter-selection-guidelines">Parameter Selection Guidelines</h4>
<p>Follow these guidelines when selecting parameters:</p>
<ol>
<li>
<p><strong>Market-Based Selection</strong></p>
<ul>
<li>
<p><strong>Volatility Considerations</strong>:</p>
<ul>
<li>High volatility markets: Longer MA windows, wider RSI thresholds</li>
<li>Low volatility markets: Shorter MA windows, narrower RSI thresholds</li>
</ul>
</li>
<li>
<p><strong>Instrument Characteristics</strong>:</p>
<ul>
<li>Trending instruments: Favor MA-based signals</li>
<li>Mean-reverting instruments: Favor RSI-based signals</li>
<li>High-value instruments: Consider wider data widths</li>
</ul>
</li>
<li>
<p><strong>Timeframe Matching</strong>:</p>
<ul>
<li>Match parameters to analysis timeframe</li>
<li>Short-term trading: Shorter windows</li>
<li>Long-term trading: Longer windows</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Strategy-Based Selection</strong></p>
<ul>
<li>
<p><strong>Trend Following</strong>:</p>
<ul>
<li>Longer MA windows (50-200)</li>
<li>Extreme RSI thresholds (20/80)</li>
<li>Focus on trend confirmation</li>
</ul>
</li>
<li>
<p><strong>Mean Reversion</strong>:</p>
<ul>
<li>Shorter MA windows (10-20)</li>
<li>Standard RSI thresholds (30/70)</li>
<li>Focus on oscillator extremes</li>
</ul>
</li>
<li>
<p><strong>Momentum Trading</strong>:</p>
<ul>
<li>Medium MA windows (20-50)</li>
<li>Modified RSI thresholds (40/60)</li>
<li>Focus on trend strength</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Resource-Based Selection</strong></p>
<ul>
<li>
<p><strong>Limited Resources</strong>:</p>
<ul>
<li>Narrower data widths</li>
<li>Shorter window sizes</li>
<li>Fewer parallel instances</li>
</ul>
</li>
<li>
<p><strong>Performance Priority</strong>:</p>
<ul>
<li>Optimize for critical path reduction</li>
<li>Select power-of-2 window sizes where possible</li>
<li>Consider calculation complexity</li>
</ul>
</li>
<li>
<p><strong>Latency Considerations</strong>:</p>
<ul>
<li>Shorter windows reduce buffer filling time</li>
<li>Simpler calculations improve throughput</li>
<li>Balance with strategy requirements</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Multiple Parameter Sets</strong></p>
<ul>
<li>Consider implementing multiple parameter configurations</li>
<li>Test performance across different settings</li>
<li>Enable runtime selection where appropriate</li>
<li>Document expected behavior for each configuration</li>
<li>Provide guidelines for optimal selection</li>
</ul>
</li>
</ol>
<p>These guidelines help identify the most appropriate parameters for specific applications.</p>
<h4 id="parameter-impact-analysis">Parameter Impact Analysis</h4>
<p>Understanding parameter impact helps optimize system configuration:</p>
<ol>
<li>
<p><strong>Window Size Impact</strong></p>
<ul>
<li>
<p><strong>Calculation Impact</strong>:</p>
<ul>
<li>Larger windows require more initialization time</li>
<li>Signal generation delayed until buffer filled</li>
<li>No impact on computational complexity</li>
<li>Affects overall system latency</li>
<li>Influences trading signal frequency</li>
</ul>
</li>
<li>
<p><strong>Technical Analysis Impact</strong>:</p>
<ul>
<li>Larger MA windows: Smoother curve, more lag</li>
<li>Smaller MA windows: More responsive, more noise</li>
<li>Larger RSI windows: Fewer extremes, less trading</li>
<li>Smaller RSI windows: More signals, higher false positive rate</li>
</ul>
</li>
<li>
<p><strong>Resource Impact</strong>:</p>
<ul>
<li>Linear relationship with memory usage</li>
<li>No impact on computational resources</li>
<li>Minimal effect on overall system size</li>
<li>Easily scalable within reasonable ranges</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Data Width Impact</strong></p>
<ul>
<li>
<p><strong>Precision Impact</strong>:</p>
<ul>
<li>Wider data: Higher precision calculation</li>
<li>Narrower data: Limited value range</li>
<li>Affects calculation accuracy</li>
<li>Influences signal quality</li>
<li>Critical for high-value instruments</li>
</ul>
</li>
<li>
<p><strong>Resource Impact</strong>:</p>
<ul>
<li>Linear relationship with register width</li>
<li>Affects memory usage</li>
<li>Influences arithmetic complexity</li>
<li>Impacts critical path timing</li>
<li>Scales predictably with width</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Threshold Impact</strong></p>
<ul>
<li>
<p><strong>Signal Generation Impact</strong>:</p>
<ul>
<li>Wider thresholds (e.g., 20/80): Fewer, stronger signals</li>
<li>Narrower thresholds (e.g., 40/60): More frequent, weaker signals</li>
<li>Asymmetric thresholds: Directional bias</li>
<li>Directly affects trading frequency</li>
<li>Influences risk/reward profile</li>
</ul>
</li>
<li>
<p><strong>Performance Impact</strong>:</p>
<ul>
<li>No resource utilization impact</li>
<li>No computational complexity impact</li>
<li>Purely strategic parameter</li>
<li>Runtime configurable if needed</li>
<li>Easily modified for optimization</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>This analysis provides insights for parameter tuning based on specific requirements.</p>
<h4 id="configuration-management-approach">Configuration Management Approach</h4>
<p>Implement a structured approach to configuration management:</p>
<ol>
<li>
<p><strong>Static Configuration</strong></p>
<ul>
<li>Parameter setting at instantiation:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> top_level (
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Module instantiation with static parameters</span>
    trading_system_singlemem #(
        <span class="hljs-variable">.MA_WINDOW</span>(<span class="hljs-number">50</span>),
        <span class="hljs-variable">.RSI_WINDOW</span>(<span class="hljs-number">14</span>),
        <span class="hljs-variable">.BUY_RSI_THR</span>(<span class="hljs-number">25</span>),
        <span class="hljs-variable">.SELL_RSI_THR</span>(<span class="hljs-number">75</span>)
    ) trading_system (
        <span class="hljs-comment">// Port connections...</span>
    );
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>Compile-time configuration</li>
<li>No runtime overhead</li>
<li>Fixed operational parameters</li>
<li>Clear documentation required</li>
</ul>
</li>
<li>
<p><strong>Dynamic Configuration</strong></p>
<ul>
<li>Register-based parameter selection:<pre class="hljs"><code><div><span class="hljs-comment">// Configuration register examples</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] buy_threshold_reg = <span class="hljs-number">30</span>;
<span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] sell_threshold_reg = <span class="hljs-number">70</span>;

<span class="hljs-comment">// Dynamic threshold selection</span>
<span class="hljs-keyword">assign</span> buy_threshold = (config_select) ? buy_threshold_reg : <span class="hljs-number">8&#x27;d30</span>;
<span class="hljs-keyword">assign</span> sell_threshold = (config_select) ? sell_threshold_reg : <span class="hljs-number">8&#x27;d70</span>;
</div></code></pre>
</li>
<li>Runtime adjustable parameters</li>
<li>Requires additional control logic</li>
<li>Suitable for experimentation</li>
<li>May impact timing or resources</li>
</ul>
</li>
<li>
<p><strong>Configuration Management System</strong></p>
<ul>
<li>Parameter storage in configuration registers</li>
<li>Control interface for parameter updates</li>
<li>Status reporting of current configuration</li>
<li>Version tracking and documentation</li>
<li>Verification of parameter validity</li>
</ul>
</li>
<li>
<p><strong>Documentation Requirements</strong></p>
<ul>
<li>Document all parameter settings</li>
<li>Provide rationale for selected values</li>
<li>Include expected behavior notes</li>
<li>Reference testing results</li>
<li>Maintain change history</li>
</ul>
</li>
</ol>
<p>This approach ensures proper management of system configuration parameters.</p>
<h3 id="example-applications">Example Applications</h3>
<h4 id="basic-trading-system">Basic Trading System</h4>
<p>A basic implementation of the trading system might include:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> basic_trading_system (
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_in,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        new_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        sell
);
    <span class="hljs-comment">// Internal signals</span>
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  rsi;
    <span class="hljs-keyword">wire</span>        mem_full;
    
    <span class="hljs-comment">// Trading system instantiation with default parameters</span>
    trading_system_singlemem trading_core (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.price_in</span>(price_in),
        <span class="hljs-variable">.new_price</span>(new_price),
        <span class="hljs-variable">.moving_avg</span>(moving_avg),
        <span class="hljs-variable">.rsi</span>(rsi),
        <span class="hljs-variable">.buy</span>(buy),
        <span class="hljs-variable">.sell</span>(sell),
        <span class="hljs-variable">.mem_full</span>(mem_full)
    );
    
    <span class="hljs-comment">// Optional: Status LED outputs</span>
    <span class="hljs-keyword">assign</span> led_ready = mem_full;
    <span class="hljs-keyword">assign</span> led_buy = buy;
    <span class="hljs-keyword">assign</span> led_sell = sell;
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This basic system:</p>
<ul>
<li>Uses default parameters for all components</li>
<li>Provides simple buy/sell signal outputs</li>
<li>Includes status indication</li>
<li>Requires minimal external components</li>
<li>Serves as starting point for customization</li>
</ul>
<p>Usage scenarios include:</p>
<ul>
<li>Educational demonstration</li>
<li>Simple trading strategy validation</li>
<li>Basic market analysis</li>
<li>Prototype development</li>
<li>Initial FPGA implementation</li>
</ul>
<p>This implementation provides the foundation for more complex trading applications.</p>
<h4 id="multi-instrument-implementation">Multi-Instrument Implementation</h4>
<p>A multi-instrument trading system enables analysis of multiple financial instruments simultaneously:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> multi_instrument_system #(
    <span class="hljs-keyword">parameter</span> NUM_INSTRUMENTS = <span class="hljs-number">4</span>
)(
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>                      clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>                      rst,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>]               prices_in [NUM_INSTRUMENTS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [NUM_INSTRUMENTS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_prices,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [NUM_INSTRUMENTS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] buy_signals,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [NUM_INSTRUMENTS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sell_signals
);
    <span class="hljs-comment">// Per-instrument signals</span>
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avgs [NUM_INSTRUMENTS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  rsis [NUM_INSTRUMENTS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">wire</span>        mem_fulls [NUM_INSTRUMENTS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    
    <span class="hljs-comment">// Generate multiple trading systems</span>
    <span class="hljs-keyword">genvar</span> i;
    <span class="hljs-keyword">generate</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_INSTRUMENTS; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>: inst
            trading_system_singlemem trading_inst (
                <span class="hljs-variable">.clk</span>(clk),
                <span class="hljs-variable">.rst</span>(rst),
                <span class="hljs-variable">.price_in</span>(prices_in[i]),
                <span class="hljs-variable">.new_price</span>(new_prices[i]),
                <span class="hljs-variable">.moving_avg</span>(moving_avgs[i]),
                <span class="hljs-variable">.rsi</span>(rsis[i]),
                <span class="hljs-variable">.buy</span>(buy_signals[i]),
                <span class="hljs-variable">.sell</span>(sell_signals[i]),
                <span class="hljs-variable">.mem_full</span>(mem_fulls[i])
            );
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endgenerate</span>
    
    <span class="hljs-comment">// Optional: System-wide status</span>
    <span class="hljs-keyword">wire</span> system_ready = &amp;mem_fulls;  <span class="hljs-comment">// All systems initialized</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This implementation provides:</p>
<ul>
<li>Parallel analysis of multiple instruments</li>
<li>Independent signals for each instrument</li>
<li>Scalable design through generation</li>
<li>Common clock and reset</li>
<li>Efficient resource utilization</li>
</ul>
<p>Application scenarios include:</p>
<ul>
<li>Portfolio-wide analysis</li>
<li>Correlated instrument trading</li>
<li>Market sector monitoring</li>
<li>Basket trading strategies</li>
<li>Exchange-wide analysis</li>
</ul>
<p>The design scales linearly with instrument count, limited only by FPGA resources.</p>
<h4 id="market-data-integration">Market Data Integration</h4>
<p>Integrating the system with market data sources requires appropriate interfaces:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> market_data_system (
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        sys_clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        sys_rst,
    
    <span class="hljs-comment">// Market data interface (example)</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        md_clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        md_valid,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] md_data,   <span class="hljs-comment">// Format: [15:0] price, [31:16] symbol_id</span>
    
    <span class="hljs-comment">// Trading interface</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]  buy_signals,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]  sell_signals
);
    <span class="hljs-comment">// Clock domain crossing</span>
    <span class="hljs-keyword">wire</span>        md_valid_sync;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] md_data_sync;
    
    cdc_synchronizer md_sync (
        <span class="hljs-variable">.src_clk</span>(md_clk),
        <span class="hljs-variable">.dst_clk</span>(sys_clk),
        <span class="hljs-variable">.src_data</span>({md_valid, md_data}),
        <span class="hljs-variable">.dst_data</span>({md_valid_sync, md_data_sync})
    );
    
    <span class="hljs-comment">// Symbol demultiplexer</span>
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] symbol_id = md_data_sync[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>];
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price = md_data_sync[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];
    
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] price_valid;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] prices [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> sys_clk) <span class="hljs-keyword">begin</span>
        price_valid &lt;= <span class="hljs-number">4&#x27;b0000</span>;  <span class="hljs-comment">// Default: no valid prices</span>
        
        <span class="hljs-keyword">if</span> (md_valid_sync) <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (symbol_id[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>])  <span class="hljs-comment">// Example: use 2 bits for routing</span>
                <span class="hljs-number">2&#x27;b00</span>: <span class="hljs-keyword">begin</span> prices[<span class="hljs-number">0</span>] &lt;= price; price_valid[<span class="hljs-number">0</span>] &lt;= <span class="hljs-number">1&#x27;b1</span>; <span class="hljs-keyword">end</span>
                <span class="hljs-number">2&#x27;b01</span>: <span class="hljs-keyword">begin</span> prices[<span class="hljs-number">1</span>] &lt;= price; price_valid[<span class="hljs-number">1</span>] &lt;= <span class="hljs-number">1&#x27;b1</span>; <span class="hljs-keyword">end</span>
                <span class="hljs-number">2&#x27;b10</span>: <span class="hljs-keyword">begin</span> prices[<span class="hljs-number">2</span>] &lt;= price; price_valid[<span class="hljs-number">2</span>] &lt;= <span class="hljs-number">1&#x27;b1</span>; <span class="hljs-keyword">end</span>
                <span class="hljs-number">2&#x27;b11</span>: <span class="hljs-keyword">begin</span> prices[<span class="hljs-number">3</span>] &lt;= price; price_valid[<span class="hljs-number">3</span>] &lt;= <span class="hljs-number">1&#x27;b1</span>; <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Multi-instrument system</span>
    multi_instrument_system #(
        <span class="hljs-variable">.NUM_INSTRUMENTS</span>(<span class="hljs-number">4</span>)
    ) trading_system (
        <span class="hljs-variable">.clk</span>(sys_clk),
        <span class="hljs-variable">.rst</span>(sys_rst),
        <span class="hljs-variable">.prices_in</span>(prices),
        <span class="hljs-variable">.new_prices</span>(price_valid),
        <span class="hljs-variable">.buy_signals</span>(buy_signals),
        <span class="hljs-variable">.sell_signals</span>(sell_signals)
    );
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This implementation provides:</p>
<ul>
<li>Clock domain crossing for market data</li>
<li>Demultiplexing by instrument/symbol</li>
<li>Appropriate synchronization</li>
<li>Integration with multi-instrument system</li>
<li>Clean interface separation</li>
</ul>
<p>Integration scenarios include:</p>
<ul>
<li>Exchange data feed connection</li>
<li>Market simulator interface</li>
<li>Multi-source aggregation</li>
<li>Time-series database interface</li>
<li>Real-time trading systems</li>
</ul>
<p>This design pattern enables connection to various market data sources.</p>
<h4 id="backtesting-platform">Backtesting Platform</h4>
<p>A backtesting platform enables historical strategy evaluation:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> backtesting_platform (
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,
    
    <span class="hljs-comment">// Historical data interface</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        data_valid,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] timestamp,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        data_ready,
    
    <span class="hljs-comment">// Result capture interface</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        signal_valid,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] signal_timestamp,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        buy_signal,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        sell_signal,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  rsi
);
    <span class="hljs-comment">// Flow control</span>
    <span class="hljs-keyword">wire</span> mem_full;
    <span class="hljs-keyword">assign</span> data_ready = <span class="hljs-number">1&#x27;b1</span>;  <span class="hljs-comment">// Always ready for data</span>
    
    <span class="hljs-comment">// Trading system</span>
    <span class="hljs-keyword">wire</span> buy, sell;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_value;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  rsi_value;
    
    trading_system_singlemem trading_core (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.price_in</span>(price),
        <span class="hljs-variable">.new_price</span>(data_valid),
        <span class="hljs-variable">.moving_avg</span>(ma_value),
        <span class="hljs-variable">.rsi</span>(rsi_value),
        <span class="hljs-variable">.buy</span>(buy),
        <span class="hljs-variable">.sell</span>(sell),
        <span class="hljs-variable">.mem_full</span>(mem_full)
    );
    
    <span class="hljs-comment">// Signal timestamp capture</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] last_timestamp;
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (data_valid)
            last_timestamp &lt;= timestamp;
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Result output with timestamp</span>
    <span class="hljs-keyword">assign</span> signal_valid = buy || sell;
    <span class="hljs-keyword">assign</span> signal_timestamp = last_timestamp;
    <span class="hljs-keyword">assign</span> buy_signal = buy;
    <span class="hljs-keyword">assign</span> sell_signal = sell;
    <span class="hljs-keyword">assign</span> moving_avg = ma_value;
    <span class="hljs-keyword">assign</span> rsi = rsi_value;
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This implementation provides:</p>
<ul>
<li>Historical data processing</li>
<li>Time-stamped signal generation</li>
<li>Complete indicator output</li>
<li>Result capture for analysis</li>
<li>Efficient backtesting execution</li>
</ul>
<p>Application scenarios include:</p>
<ul>
<li>Strategy optimization</li>
<li>Parameter tuning</li>
<li>Historical performance analysis</li>
<li>Comparative strategy evaluation</li>
<li>Trading system validation</li>
</ul>
<p>This design enables comprehensive backtesting for strategy development.</p>
<h4 id="real-time-trading-system">Real-Time Trading System</h4>
<p>A real-time trading system connects technical analysis with order execution:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> realtime_trading_system (
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,
    
    <span class="hljs-comment">// Market data interface</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        price_valid,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price,
    
    <span class="hljs-comment">// Position management interface</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        have_position,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        can_buy,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        can_sell,
    
    <span class="hljs-comment">// Order execution interface</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         exec_buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>         exec_sell
);
    <span class="hljs-comment">// Trading signals</span>
    <span class="hljs-keyword">wire</span> buy_signal, sell_signal;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_value;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  rsi_value;
    <span class="hljs-keyword">wire</span> mem_full;
    
    <span class="hljs-comment">// Technical analysis system</span>
    trading_system_singlemem trading_core (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.price_in</span>(price),
        <span class="hljs-variable">.new_price</span>(price_valid),
        <span class="hljs-variable">.moving_avg</span>(ma_value),
        <span class="hljs-variable">.rsi</span>(rsi_value),
        <span class="hljs-variable">.buy</span>(buy_signal),
        <span class="hljs-variable">.sell</span>(sell_signal),
        <span class="hljs-variable">.mem_full</span>(mem_full)
    );
    
    <span class="hljs-comment">// Order execution logic</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            exec_buy &lt;= <span class="hljs-number">1&#x27;b0</span>;
            exec_sell &lt;= <span class="hljs-number">1&#x27;b0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Default: no execution</span>
            exec_buy &lt;= <span class="hljs-number">1&#x27;b0</span>;
            exec_sell &lt;= <span class="hljs-number">1&#x27;b0</span>;
            
            <span class="hljs-comment">// Execute buy only when:</span>
            <span class="hljs-comment">// 1. Buy signal is active</span>
            <span class="hljs-comment">// 2. System is ready (memory full)</span>
            <span class="hljs-comment">// 3. No current position</span>
            <span class="hljs-comment">// 4. Trading allowed (can_buy)</span>
            <span class="hljs-keyword">if</span> (buy_signal &amp;&amp; mem_full &amp;&amp; !have_position &amp;&amp; can_buy)
                exec_buy &lt;= <span class="hljs-number">1&#x27;b1</span>;
                
            <span class="hljs-comment">// Execute sell only when:</span>
            <span class="hljs-comment">// 1. Sell signal is active</span>
            <span class="hljs-comment">// 2. System is ready (memory full)</span>
            <span class="hljs-comment">// 3. Have existing position</span>
            <span class="hljs-comment">// 4. Trading allowed (can_sell)</span>
            <span class="hljs-keyword">if</span> (sell_signal &amp;&amp; mem_full &amp;&amp; have_position &amp;&amp; can_sell)
                exec_sell &lt;= <span class="hljs-number">1&#x27;b1</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This implementation provides:</p>
<ul>
<li>Real-time signal generation</li>
<li>Position status integration</li>
<li>Trading permission checks</li>
<li>Order execution interface</li>
<li>Safe trading logic</li>
</ul>
<p>Application scenarios include:</p>
<ul>
<li>Algorithmic trading systems</li>
<li>Automated trading platforms</li>
<li>High-frequency trading</li>
<li>Market making systems</li>
<li>Agency trading algorithms</li>
</ul>
<p>This design creates a complete trading system with appropriate safeguards.</p>
<h4 id="research-and-development-platform">Research and Development Platform</h4>
<p>A research platform enables experimentation with different trading strategies:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_research_platform (
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        clk,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        rst,
    
    <span class="hljs-comment">// Market data interface</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>        price_valid,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price,
    
    <span class="hljs-comment">// Configuration interface</span>
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  ma_window,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  rsi_window,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  buy_threshold,
    <span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  sell_threshold,
    
    <span class="hljs-comment">// Multi-strategy output interface</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        standard_buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        standard_sell,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        custom_buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>        custom_sell,
    
    <span class="hljs-comment">// Indicator outputs</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_standard,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_custom,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  rsi_standard,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  rsi_custom
);
    <span class="hljs-comment">// Standard trading system (default parameters)</span>
    trading_system_singlemem standard_system (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.price_in</span>(price),
        <span class="hljs-variable">.new_price</span>(price_valid),
        <span class="hljs-variable">.moving_avg</span>(ma_standard),
        <span class="hljs-variable">.rsi</span>(rsi_standard),
        <span class="hljs-variable">.buy</span>(standard_buy),
        <span class="hljs-variable">.sell</span>(standard_sell)
    );
    
    <span class="hljs-comment">// Custom parameter trading system</span>
    <span class="hljs-keyword">wire</span> price_memory_full;
    
    <span class="hljs-comment">// Custom price memory</span>
    price_memory #(
        <span class="hljs-variable">.DEPTH</span>(rsi_window),
        <span class="hljs-variable">.DW</span>(<span class="hljs-number">16</span>)
    ) custom_memory (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.wr_en</span>(price_valid),
        <span class="hljs-variable">.new_price</span>(price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price_custom),
        <span class="hljs-variable">.full</span>(price_memory_full),
        <span class="hljs-variable">.count</span>(memory_count)
    );
    
    <span class="hljs-comment">// Custom MA with configurable window</span>
    moving_average_fsm #(
        <span class="hljs-variable">.WINDOW</span>(ma_window)
    ) custom_ma (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.start</span>(price_memory_full),
        <span class="hljs-variable">.new_price</span>(price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price_custom),
        <span class="hljs-variable">.moving_avg</span>(ma_custom),
        <span class="hljs-variable">.done</span>(ma_done_custom)
    );
    
    <span class="hljs-comment">// Custom RSI with configurable window</span>
    rsi_inc #(
        <span class="hljs-variable">.WINDOW</span>(rsi_window)
    ) custom_rsi (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_price_strobe</span>(price_memory_full),
        <span class="hljs-variable">.new_price</span>(price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price_custom),
        <span class="hljs-variable">.mem_full</span>(price_memory_full),
        <span class="hljs-variable">.mem_count</span>(memory_count),
        <span class="hljs-variable">.rsi</span>(rsi_custom),
        <span class="hljs-variable">.done</span>(rsi_done_custom)
    );
    
    <span class="hljs-comment">// Custom trading decision with configurable thresholds</span>
    trading_decision #(
        <span class="hljs-variable">.BUY_RSI_THR</span>(buy_threshold),
        <span class="hljs-variable">.SELL_RSI_THR</span>(sell_threshold)
    ) custom_decision (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.price_now</span>(price),
        <span class="hljs-variable">.moving_avg</span>(ma_custom),
        <span class="hljs-variable">.rsi</span>(rsi_custom),
        <span class="hljs-variable">.buy</span>(custom_buy),
        <span class="hljs-variable">.sell</span>(custom_sell)
    );
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This implementation provides:</p>
<ul>
<li>Side-by-side strategy comparison</li>
<li>Configurable parameters</li>
<li>Multiple indicator outputs</li>
<li>Simultaneous signal generation</li>
<li>Research capabilities</li>
</ul>
<p>Application scenarios include:</p>
<ul>
<li>Strategy development</li>
<li>Parameter optimization</li>
<li>Comparative analysis</li>
<li>Trading algorithm research</li>
<li>Educational platforms</li>
</ul>
<p>This design enables comprehensive research and development of trading strategies.</p>
<h3 id="implementation-workflow">Implementation Workflow</h3>
<h4 id="development-environment-setup">Development Environment Setup</h4>
<p>Setting up an appropriate development environment is critical for successful implementation:</p>
<ol>
<li>
<p><strong>Hardware Development Tools</strong></p>
<ul>
<li>FPGA vendor development suite:
<ul>
<li>Intel Quartus Prime</li>
<li>Xilinx Vivado</li>
<li>Lattice Diamond/Radiant</li>
</ul>
</li>
<li>Version control system (Git, SVN)</li>
<li>Waveform viewer (integrated or standalone)</li>
<li>HDL text editor with syntax highlighting</li>
<li>Documentation tools</li>
</ul>
</li>
<li>
<p><strong>Verification Environment</strong></p>
<ul>
<li>HDL simulator:
<ul>
<li>ModelSim/QuestaSim</li>
<li>VCS</li>
<li>Xcelium</li>
<li>Verilator (open source)</li>
</ul>
</li>
<li>Testbench framework</li>
<li>Waveform analysis tools</li>
<li>Automated testing scripts</li>
<li>Coverage analysis tools</li>
</ul>
</li>
<li>
<p><strong>Project Structure Setup</strong></p>
<pre class="hljs"><code><div>project/
 rtl/                  # RTL source files
    price_memory.v
    moving_average_fsm.v
    rsi_inc.v
    trading_decision.v
    trading_system_singlemem.v
 tb/                   # Testbench files
    tb_price_memory.v
    tb_moving_average.v
    tb_rsi.v
    tb_trading_system.v
 sim/                  # Simulation files
    scripts/
    waves/
    results/
 syn/                  # Synthesis files
    constraints/
    reports/
 imp/                  # Implementation files
    constraints/
    reports/
 doc/                  # Documentation
     specs/
     reports/
</div></code></pre>
</li>
<li>
<p><strong>Project Configuration</strong></p>
<ul>
<li>Create modular project structure</li>
<li>Set up proper file organization</li>
<li>Configure include paths</li>
<li>Establish build scripts</li>
<li>Define simulation configurations</li>
<li>Document setup process</li>
</ul>
</li>
</ol>
<p>This environment ensures efficient development, testing, and implementation.</p>
<h4 id="simulation-flow">Simulation Flow</h4>
<p>Follow a structured simulation workflow:</p>
<ol>
<li>
<p><strong>Simulation Setup</strong></p>
<ul>
<li>Create appropriate testbench for each module</li>
<li>Prepare test vectors and scenarios</li>
<li>Configure simulation tool settings</li>
<li>Set up waveform capture</li>
<li>Define simulation parameters</li>
</ul>
</li>
<li>
<p><strong>Simulation Script Example</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># ModelSim example simulation script</span>

<span class="hljs-comment"># Create work library</span>
vlib work

<span class="hljs-comment"># Compile RTL</span>
vlog -work work ../rtl/price_memory.v
vlog -work work ../rtl/moving_average_fsm.v
vlog -work work ../rtl/rsi_inc.v
vlog -work work ../rtl/trading_decision.v
vlog -work work ../rtl/trading_system_singlemem.v

<span class="hljs-comment"># Compile testbench</span>
vlog -work work ../tb/tb_trading_system.v

<span class="hljs-comment"># Start simulation</span>
vsim -t ns work.tb_trading_system

<span class="hljs-comment"># Add waves</span>
add wave -divider <span class="hljs-string">&quot;Inputs&quot;</span>
add wave /tb_trading_system/clk
add wave /tb_trading_system/rst
add wave /tb_trading_system/price_in
add wave /tb_trading_system/new_price

add wave -divider <span class="hljs-string">&quot;Indicators&quot;</span>
add wave /tb_trading_system/moving_avg
add wave /tb_trading_system/rsi

add wave -divider <span class="hljs-string">&quot;Outputs&quot;</span>
add wave /tb_trading_system/buy
add wave /tb_trading_system/sell

<span class="hljs-comment"># Run simulation</span>
run <span class="hljs-number">10</span> us
</div></code></pre>
</li>
<li>
<p><strong>Simulation Execution</strong></p>
<ul>
<li>Run unit-level simulations first</li>
<li>Proceed to integration testing</li>
<li>Verify all functional requirements</li>
<li>Capture and analyze waveforms</li>
<li>Record simulation results</li>
</ul>
</li>
<li>
<p><strong>Simulation Iteration</strong></p>
<ul>
<li>Fix identified issues</li>
<li>Update test cases as needed</li>
<li>Run regression tests</li>
<li>Verify bug fixes</li>
<li>Document simulation results</li>
</ul>
</li>
<li>
<p><strong>Regression Testing</strong></p>
<ul>
<li>Create automated regression suite</li>
<li>Include all test cases</li>
<li>Run after any significant changes</li>
<li>Generate comprehensive reports</li>
<li>Maintain test coverage</li>
</ul>
</li>
</ol>
<p>This workflow ensures thorough functional verification before synthesis.</p>
<h4 id="synthesis-process">Synthesis Process</h4>
<p>Follow a structured synthesis approach:</p>
<ol>
<li>
<p><strong>Synthesis Setup</strong></p>
<ul>
<li>Create synthesis project</li>
<li>Add RTL source files</li>
<li>Configure target device</li>
<li>Set up synthesis constraints</li>
<li>Define synthesis options</li>
</ul>
</li>
<li>
<p><strong>Constraint Example</strong></p>
<pre class="hljs"><code><div># Timing constraints for synthesis

# Define clock
create_clock -period 10.000 -name clk [get_ports clk]

# Input/output delays
set_input_delay -clock clk 2.000 [get_ports {price_in* new_price rst}]
set_output_delay -clock clk 2.000 [get_ports {moving_avg* rsi* buy sell}]

# False paths
set_false_path -from [get_ports rst] -to [all_registers]
</div></code></pre>
</li>
<li>
<p><strong>Synthesis Execution</strong></p>
<ul>
<li>Run initial synthesis</li>
<li>Analyze timing reports</li>
<li>Check resource utilization</li>
<li>Identify critical paths</li>
<li>Address any synthesis errors</li>
</ul>
</li>
<li>
<p><strong>Design Optimization</strong></p>
<ul>
<li>Improve critical paths</li>
<li>Adjust resource allocation</li>
<li>Apply synthesis directives</li>
<li>Refine constraints</li>
<li>Re-synthesize and verify</li>
</ul>
</li>
<li>
<p><strong>Synthesis Reporting</strong></p>
<ul>
<li>Generate detailed timing reports</li>
<li>Document resource utilization</li>
<li>Analyze synthesis results</li>
<li>Record optimization steps</li>
<li>Maintain synthesis history</li>
</ul>
</li>
</ol>
<p>This process ensures efficient translation of RTL to gate-level representation.</p>
<h4 id="implementation-strategy">Implementation Strategy</h4>
<p>Follow a comprehensive implementation strategy:</p>
<ol>
<li>
<p><strong>Translation to Target Device</strong></p>
<ul>
<li>Map synthesis results to target architecture</li>
<li>Assign logic to specific device resources</li>
<li>Allocate memory elements</li>
<li>Map arithmetic operations to DSP blocks</li>
<li>Generate initial placement</li>
</ul>
</li>
<li>
<p><strong>Placement Optimization</strong></p>
<ul>
<li>Optimize critical path placement</li>
<li>Minimize routing delays</li>
<li>Balance resource utilization</li>
<li>Consider clock domain organization</li>
<li>Apply placement constraints where needed</li>
</ul>
</li>
<li>
<p><strong>Routing</strong></p>
<ul>
<li>Complete signal routing</li>
<li>Minimize congestion</li>
<li>Address timing violations</li>
<li>Optimize clock distribution</li>
<li>Apply routing directives if needed</li>
</ul>
</li>
<li>
<p><strong>Bitstream Generation</strong></p>
<ul>
<li>Generate final implementation</li>
<li>Create programming file</li>
<li>Verify bitstream integrity</li>
<li>Document generation process</li>
<li>Archive final files</li>
</ul>
</li>
<li>
<p><strong>Implementation Reports</strong></p>
<ul>
<li>Analyze timing results</li>
<li>Review resource utilization</li>
<li>Verify constraint satisfaction</li>
<li>Document implementation details</li>
<li>Record optimization decisions</li>
</ul>
</li>
</ol>
<p>This strategy ensures optimal implementation on the target FPGA device.</p>
<h4 id="timing-closure-methodology">Timing Closure Methodology</h4>
<p>Implement a structured timing closure approach:</p>
<ol>
<li>
<p><strong>Initial Timing Analysis</strong></p>
<ul>
<li>Review timing reports</li>
<li>Identify failing paths</li>
<li>Categorize violations by type:
<ul>
<li>Setup violations</li>
<li>Hold violations</li>
<li>Multi-cycle paths</li>
<li>Clock domain crossings</li>
</ul>
</li>
<li>Prioritize critical issues</li>
</ul>
</li>
<li>
<p><strong>Constraint Refinement</strong></p>
<ul>
<li>Adjust timing constraints</li>
<li>Define appropriate clock relationships</li>
<li>Add multi-cycle paths where appropriate</li>
<li>Identify false paths</li>
<li>Document constraint changes</li>
</ul>
</li>
<li>
<p><strong>RTL Optimization</strong></p>
<ul>
<li>Pipeline critical paths</li>
<li>Reduce logic depth</li>
<li>Balance combinational logic</li>
<li>Optimize resource utilization</li>
<li>Refine state machine encoding</li>
</ul>
</li>
<li>
<p><strong>Implementation Adjustments</strong></p>
<ul>
<li>Apply placement constraints</li>
<li>Use physical optimization directives</li>
<li>Adjust timing-driven placement</li>
<li>Optimize clock tree synthesis</li>
<li>Address routing congestion</li>
</ul>
</li>
<li>
<p><strong>Verification After Changes</strong></p>
<ul>
<li>Re-simulate after RTL changes</li>
<li>Verify functional correctness</li>
<li>Run regression tests</li>
<li>Document change impact</li>
<li>Maintain optimization history</li>
</ul>
</li>
</ol>
<p>This methodology ensures reliable operation at the target clock frequency.</p>
<h4 id="deployment-guidelines">Deployment Guidelines</h4>
<p>Follow these guidelines for system deployment:</p>
<ol>
<li>
<p><strong>Configuration Management</strong></p>
<ul>
<li>Maintain version control</li>
<li>Document all parameter settings</li>
<li>Track configuration changes</li>
<li>Validate configurations</li>
<li>Archive deployment versions</li>
</ul>
</li>
<li>
<p><strong>Programming Setup</strong></p>
<ul>
<li>Configure programming interface</li>
<li>Set up JTAG or other programming method</li>
<li>Prepare programming files</li>
<li>Verify device connectivity</li>
<li>Document programming process</li>
</ul>
</li>
<li>
<p><strong>Testing on Hardware</strong></p>
<ul>
<li>Implement basic connectivity tests</li>
<li>Verify clock and reset</li>
<li>Test data input path</li>
<li>Confirm signal generation</li>
<li>Validate indicator calculation</li>
</ul>
</li>
<li>
<p><strong>Integration Testing</strong></p>
<ul>
<li>Connect to external systems</li>
<li>Test data flow end-to-end</li>
<li>Verify interface timing</li>
<li>Validate system operation</li>
<li>Document integration results</li>
</ul>
</li>
<li>
<p><strong>Deployment Documentation</strong></p>
<ul>
<li>Record deployment configuration</li>
<li>Document known limitations</li>
<li>Provide operational guidelines</li>
<li>Include troubleshooting information</li>
<li>Maintain deployment history</li>
</ul>
</li>
</ol>
<p>These guidelines ensure successful deployment and operation of the trading system.</p>
<h2 id="11-extension-possibilities">11. Extension Possibilities</h2>
<h3 id="additional-technical-indicators">Additional Technical Indicators</h3>
<p>The system can be extended with various technical indicators to enhance trading strategy capabilities:</p>
<h4 id="exponential-moving-average">Exponential Moving Average</h4>
<p>An Exponential Moving Average (EMA) assigns more weight to recent prices:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> ema_calculator #(
    <span class="hljs-keyword">parameter</span> PERIOD = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ema,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Smoothing factor: 2/(PERIOD+1)</span>
    <span class="hljs-comment">// For PERIOD=20, alpha = 2/21  0.0952</span>
    <span class="hljs-comment">// Fixed-point representation (8-bit fractional)</span>
    <span class="hljs-keyword">localparam</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] ALPHA_FP = (<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">8</span>) / (PERIOD + <span class="hljs-number">1</span>);
    
    <span class="hljs-comment">// Implementation state</span>
    <span class="hljs-keyword">reg</span> initialized = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            ema &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            initialized &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">if</span> (!initialized) <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// First value is just the price</span>
                ema &lt;= price;
                initialized &lt;= <span class="hljs-number">1</span>;
                done &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// EMA = price * alpha + EMA * (1-alpha)</span>
                <span class="hljs-comment">// Fixed-point implementation</span>
                ema &lt;= ((price * ALPHA_FP) + 
                       (ema * (<span class="hljs-number">16&#x27;hFF</span> - ALPHA_FP))) &gt;&gt; <span class="hljs-number">8</span>;
                done &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key implementation features:</p>
<ul>
<li>Fixed-point smoothing factor</li>
<li>Efficient recursive calculation</li>
<li>Initialization handling</li>
<li>Completion signaling</li>
<li>Minimal resource requirements</li>
</ul>
<p>The EMA provides a more responsive trend indicator than the SMA, with reduced lag but potentially more noise sensitivity.</p>
<h4 id="bollinger-bands">Bollinger Bands</h4>
<p>Bollinger Bands combine a moving average with standard deviation-based bands:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> bollinger_bands #(
    <span class="hljs-keyword">parameter</span> PERIOD = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> STDEV_MULT = <span class="hljs-number">2</span>,  <span class="hljs-comment">// Typically 2 standard deviations</span>
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] middle_band,  <span class="hljs-comment">// Moving average</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] upper_band,   <span class="hljs-comment">// Upper Bollinger Band</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] lower_band,   <span class="hljs-comment">// Lower Bollinger Band</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Internal signals</span>
    <span class="hljs-keyword">reg</span> [DW*<span class="hljs-number">2</span>-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;         <span class="hljs-comment">// Price sum</span>
    <span class="hljs-keyword">reg</span> [DW*<span class="hljs-number">2</span>-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sum_squares = <span class="hljs-number">0</span>; <span class="hljs-comment">// Sum of squared prices</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] count = <span class="hljs-number">0</span>;            <span class="hljs-comment">// Sample count</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] prices [PERIOD-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]; <span class="hljs-comment">// Price history</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] variance;            <span class="hljs-comment">// Price variance</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] stdev;               <span class="hljs-comment">// Standard deviation</span>
    
    <span class="hljs-comment">// State machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, COLLECT = <span class="hljs-number">1</span>, CALCULATE = <span class="hljs-number">2</span>, COMPLETE = <span class="hljs-number">3</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset logic</span>
            state &lt;= IDLE;
            sum &lt;= <span class="hljs-number">0</span>;
            sum_squares &lt;= <span class="hljs-number">0</span>;
            count &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        state &lt;= COLLECT;
                        count &lt;= (count &lt; PERIOD) ? count + <span class="hljs-number">1</span> : PERIOD;
                        
                        <span class="hljs-comment">// Update sums (add new, remove oldest if full)</span>
                        <span class="hljs-keyword">if</span> (count == PERIOD) <span class="hljs-keyword">begin</span>
                            sum &lt;= sum + price - oldest_price;
                            sum_squares &lt;= sum_squares + (price * price) - 
                                          (oldest_price * oldest_price);
                        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                            sum &lt;= sum + price;
                            sum_squares &lt;= sum_squares + (price * price);
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-comment">// Store price in history array</span>
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = PERIOD-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>)
                            prices[i] &lt;= prices[i-<span class="hljs-number">1</span>];
                        prices[<span class="hljs-number">0</span>] &lt;= price;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                COLLECT: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (count == PERIOD) <span class="hljs-keyword">begin</span>
                        state &lt;= CALCULATE;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        state &lt;= IDLE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculate moving average</span>
                    middle_band &lt;= sum / PERIOD;
                    
                    <span class="hljs-comment">// Calculate variance: (sum_squares - (sum/n))/n</span>
                    variance &lt;= (sum_squares - ((sum * sum) / PERIOD)) / PERIOD;
                    
                    <span class="hljs-comment">// Calculate standard deviation (sqrt of variance)</span>
                    <span class="hljs-comment">// Approximate using a simple algorithm</span>
                    <span class="hljs-comment">// For production, use a proper CORDIC implementation</span>
                    stdev &lt;= approximate_sqrt(variance);
                    
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculate bands</span>
                    upper_band &lt;= middle_band + (stdev * STDEV_MULT);
                    lower_band &lt;= (middle_band &gt; (stdev * STDEV_MULT)) ? 
                                  (middle_band - (stdev * STDEV_MULT)) : <span class="hljs-number">0</span>;
                    
                    <span class="hljs-comment">// Signal completion</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key implementation features:</p>
<ul>
<li>Combined calculation of mean and standard deviation</li>
<li>Square root approximation (simplified here)</li>
<li>Configurable standard deviation multiplier</li>
<li>Upper and lower band calculation</li>
<li>Complete state machine implementation</li>
</ul>
<p>Bollinger Bands are useful for:</p>
<ul>
<li>Volatility measurement</li>
<li>Potential breakout identification</li>
<li>Mean reversion strategies</li>
<li>Trend strength assessment</li>
<li>Channel trading approaches</li>
</ul>
<p>The implementation can be optimized further with specialized square root circuits.</p>
<h4 id="macd-implementation">MACD Implementation</h4>
<p>The Moving Average Convergence Divergence (MACD) indicator combines multiple EMAs:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> macd_calculator #(
    <span class="hljs-keyword">parameter</span> FAST_PERIOD = <span class="hljs-number">12</span>,
    <span class="hljs-keyword">parameter</span> SLOW_PERIOD = <span class="hljs-number">26</span>,
    <span class="hljs-keyword">parameter</span> SIGNAL_PERIOD = <span class="hljs-number">9</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] macd_line,    <span class="hljs-comment">// MACD Line (Fast EMA - Slow EMA)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] signal_line,  <span class="hljs-comment">// Signal Line (EMA of MACD Line)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] histogram,    <span class="hljs-comment">// Histogram (MACD Line - Signal Line)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Internal signals</span>
    <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] fast_ema;
    <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] slow_ema;
    <span class="hljs-keyword">wire</span> fast_done, slow_done, signal_done;
    <span class="hljs-keyword">reg</span> macd_valid = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] macd_value;
    
    <span class="hljs-comment">// Fast EMA calculator</span>
    ema_calculator #(
        <span class="hljs-variable">.PERIOD</span>(FAST_PERIOD),
        <span class="hljs-variable">.DW</span>(DW)
    ) fast_ema_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_data</span>(new_data),
        <span class="hljs-variable">.price</span>(price),
        <span class="hljs-variable">.ema</span>(fast_ema),
        <span class="hljs-variable">.done</span>(fast_done)
    );
    
    <span class="hljs-comment">// Slow EMA calculator</span>
    ema_calculator #(
        <span class="hljs-variable">.PERIOD</span>(SLOW_PERIOD),
        <span class="hljs-variable">.DW</span>(DW)
    ) slow_ema_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_data</span>(new_data),
        <span class="hljs-variable">.price</span>(price),
        <span class="hljs-variable">.ema</span>(slow_ema),
        <span class="hljs-variable">.done</span>(slow_done)
    );
    
    <span class="hljs-comment">// MACD Line calculation</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (fast_done &amp;&amp; slow_done) <span class="hljs-keyword">begin</span>
            macd_value &lt;= (fast_ema &gt; slow_ema) ? 
                          (fast_ema - slow_ema) : <span class="hljs-number">0</span>;
            macd_valid &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            macd_valid &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Signal Line calculator (EMA of MACD Line)</span>
    ema_calculator #(
        <span class="hljs-variable">.PERIOD</span>(SIGNAL_PERIOD),
        <span class="hljs-variable">.DW</span>(DW)
    ) signal_ema_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_data</span>(macd_valid),
        <span class="hljs-variable">.price</span>(macd_value),
        <span class="hljs-variable">.ema</span>(signal_line),
        <span class="hljs-variable">.done</span>(signal_done)
    );
    
    <span class="hljs-comment">// Final MACD outputs</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            macd_line &lt;= <span class="hljs-number">0</span>;
            histogram &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (signal_done) <span class="hljs-keyword">begin</span>
            macd_line &lt;= macd_value;
            histogram &lt;= (macd_value &gt; signal_line) ? 
                        (macd_value - signal_line) : 
                        (signal_line - macd_value);
            done &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key implementation features:</p>
<ul>
<li>Multiple EMA components</li>
<li>Cascaded calculation approach</li>
<li>Component interconnection</li>
<li>Signal validity tracking</li>
<li>Complete indicator output</li>
</ul>
<p>The MACD indicator is useful for:</p>
<ul>
<li>Trend direction identification</li>
<li>Momentum assessment</li>
<li>Signal crossover strategies</li>
<li>Divergence detection</li>
<li>Entry and exit timing</li>
</ul>
<p>This modular implementation reuses the EMA component for efficient design.</p>
<h4 id="stochastic-oscillator">Stochastic Oscillator</h4>
<p>The Stochastic Oscillator compares current price to high/low range:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> stochastic_oscillator #(
    <span class="hljs-keyword">parameter</span> K_PERIOD = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> D_PERIOD = <span class="hljs-number">3</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] high,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] low,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] k_percent,  <span class="hljs-comment">// %K: Current value (0-100)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d_percent,  <span class="hljs-comment">// %D: 3-period SMA of %K (0-100)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Internal storage</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] highs [K_PERIOD-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] lows [K_PERIOD-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] k_values [D_PERIOD-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d_count = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Calculation variables</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] highest_high;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] lowest_low;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] k_sum = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// State machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, COLLECT = <span class="hljs-number">1</span>, FIND_HL = <span class="hljs-number">2</span>, CALC_K = <span class="hljs-number">3</span>, 
               CALC_D = <span class="hljs-number">4</span>, COMPLETE = <span class="hljs-number">5</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset logic</span>
            state &lt;= IDLE;
            count &lt;= <span class="hljs-number">0</span>;
            d_count &lt;= <span class="hljs-number">0</span>;
            k_sum &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Shift data in price arrays</span>
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = K_PERIOD-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                            highs[i] &lt;= highs[i-<span class="hljs-number">1</span>];
                            lows[i] &lt;= lows[i-<span class="hljs-number">1</span>];
                        <span class="hljs-keyword">end</span>
                        highs[<span class="hljs-number">0</span>] &lt;= high;
                        lows[<span class="hljs-number">0</span>] &lt;= low;
                        
                        count &lt;= (count &lt; K_PERIOD) ? count + <span class="hljs-number">1</span> : K_PERIOD;
                        state &lt;= COLLECT;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                COLLECT: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (count == K_PERIOD) <span class="hljs-keyword">begin</span>
                        state &lt;= FIND_HL;
                        <span class="hljs-comment">// Initialize with first values</span>
                        highest_high &lt;= highs[<span class="hljs-number">0</span>];
                        lowest_low &lt;= lows[<span class="hljs-number">0</span>];
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        state &lt;= IDLE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                FIND_HL: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Find highest high and lowest low</span>
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; K_PERIOD; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (highs[i] &gt; highest_high)
                            highest_high &lt;= highs[i];
                        <span class="hljs-keyword">if</span> (lows[i] &lt; lowest_low)
                            lowest_low &lt;= lows[i];
                    <span class="hljs-keyword">end</span>
                    state &lt;= CALC_K;
                <span class="hljs-keyword">end</span>
                
                CALC_K: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculate %K: 100 * (close - lowest) / (highest - lowest)</span>
                    <span class="hljs-keyword">if</span> (highest_high &gt; lowest_low) <span class="hljs-keyword">begin</span>
                        k_percent &lt;= (<span class="hljs-number">100</span> * (price - lowest_low)) / 
                                    (highest_high - lowest_low);
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        k_percent &lt;= <span class="hljs-number">50</span>; <span class="hljs-comment">// Default if range is zero</span>
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-comment">// Shift K values for %D calculation</span>
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = D_PERIOD-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        k_values[i] &lt;= k_values[i-<span class="hljs-number">1</span>];
                    <span class="hljs-keyword">end</span>
                    k_values[<span class="hljs-number">0</span>] &lt;= k_percent;
                    
                    d_count &lt;= (d_count &lt; D_PERIOD) ? d_count + <span class="hljs-number">1</span> : D_PERIOD;
                    state &lt;= CALC_D;
                <span class="hljs-keyword">end</span>
                
                CALC_D: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculate %D (simple moving average of %K)</span>
                    <span class="hljs-keyword">if</span> (d_count == D_PERIOD) <span class="hljs-keyword">begin</span>
                        k_sum &lt;= <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; D_PERIOD; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                            k_sum &lt;= k_sum + k_values[i];
                        <span class="hljs-keyword">end</span>
                        d_percent &lt;= k_sum / D_PERIOD;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        d_percent &lt;= k_percent; <span class="hljs-comment">// Default if not enough data</span>
                    <span class="hljs-keyword">end</span>
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key implementation features:</p>
<ul>
<li>Sliding window for high/low tracking</li>
<li>Multi-stage calculation process</li>
<li>Percentage-based output values</li>
<li>%K and %D line calculation</li>
<li>Complete state machine implementation</li>
</ul>
<p>The Stochastic Oscillator is useful for:</p>
<ul>
<li>Overbought/oversold conditions</li>
<li>Price momentum analysis</li>
<li>Reversal identification</li>
<li>Divergence detection</li>
<li>Range-bound market strategies</li>
</ul>
<p>This implementation offers a comprehensive solution for stochastic calculation.</p>
<h4 id="volume-indicators">Volume Indicators</h4>
<p>Volume-based indicators provide additional market insight:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> volume_indicators #(
    <span class="hljs-keyword">parameter</span> PERIOD = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> VOL_DW = <span class="hljs-number">32</span>  <span class="hljs-comment">// Volume typically larger than price</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [VOL_DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] volume,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [VOL_DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] volume_ma,  <span class="hljs-comment">// Volume moving average</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pvi,              <span class="hljs-comment">// Positive Volume Index</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] nvi,              <span class="hljs-comment">// Negative Volume Index</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] obv,              <span class="hljs-comment">// On-Balance Volume</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Internal signals</span>
    <span class="hljs-keyword">reg</span> [VOL_DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] vol_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [VOL_DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] vol_history [PERIOD-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] prev_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [VOL_DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] prev_volume = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> initialized = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// OBV starting value</span>
    <span class="hljs-keyword">localparam</span> OBV_START = <span class="hljs-number">32&#x27;d1000</span>;
    
    <span class="hljs-comment">// PVI/NVI calculation variables</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pvi_internal = <span class="hljs-number">32&#x27;d1000</span>;  <span class="hljs-comment">// Starting values</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] nvi_internal = <span class="hljs-number">32&#x27;d1000</span>;
    
    <span class="hljs-comment">// State machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, INIT = <span class="hljs-number">1</span>, CALCULATE = <span class="hljs-number">2</span>, UPDATE = <span class="hljs-number">3</span>, COMPLETE = <span class="hljs-number">4</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset logic</span>
            state &lt;= IDLE;
            vol_sum &lt;= <span class="hljs-number">0</span>;
            count &lt;= <span class="hljs-number">0</span>;
            initialized &lt;= <span class="hljs-number">0</span>;
            obv &lt;= OBV_START;
            pvi_internal &lt;= <span class="hljs-number">32&#x27;d1000</span>;
            nvi_internal &lt;= <span class="hljs-number">32&#x27;d1000</span>;
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Shift volume history</span>
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = PERIOD-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                            vol_history[i] &lt;= vol_history[i-<span class="hljs-number">1</span>];
                        <span class="hljs-keyword">end</span>
                        vol_history[<span class="hljs-number">0</span>] &lt;= volume;
                        
                        <span class="hljs-keyword">if</span> (!initialized) <span class="hljs-keyword">begin</span>
                            state &lt;= INIT;
                        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                            state &lt;= CALCULATE;
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                INIT: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Initialize values</span>
                    prev_price &lt;= price;
                    prev_volume &lt;= volume;
                    initialized &lt;= <span class="hljs-number">1</span>;
                    count &lt;= <span class="hljs-number">1</span>;
                    vol_sum &lt;= volume;
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculate volume indicators</span>
                    
                    <span class="hljs-comment">// Update OBV</span>
                    <span class="hljs-keyword">if</span> (price &gt; prev_price)
                        obv &lt;= obv + volume;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; prev_price)
                        obv &lt;= obv - volume;
                    <span class="hljs-comment">// else: OBV unchanged if price unchanged</span>
                    
                    <span class="hljs-comment">// Update PVI &amp; NVI</span>
                    <span class="hljs-keyword">if</span> (volume &gt; prev_volume) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// PVI update, NVI unchanged</span>
                        pvi_internal &lt;= pvi_internal * (<span class="hljs-number">32&#x27;d1000</span> + 
                                      ((price - prev_price) * <span class="hljs-number">32&#x27;d1000</span> / prev_price)) / <span class="hljs-number">32&#x27;d1000</span>;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// NVI update, PVI unchanged</span>
                        nvi_internal &lt;= nvi_internal * (<span class="hljs-number">32&#x27;d1000</span> + 
                                      ((price - prev_price) * <span class="hljs-number">32&#x27;d1000</span> / prev_price)) / <span class="hljs-number">32&#x27;d1000</span>;
                    <span class="hljs-keyword">end</span>
                    
                    state &lt;= UPDATE;
                <span class="hljs-keyword">end</span>
                
                UPDATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Update volume MA</span>
                    <span class="hljs-keyword">if</span> (count &lt; PERIOD) <span class="hljs-keyword">begin</span>
                        count &lt;= count + <span class="hljs-number">1</span>;
                        vol_sum &lt;= vol_sum + volume;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        vol_sum &lt;= vol_sum + volume - vol_history[PERIOD-<span class="hljs-number">1</span>];
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-comment">// Update previous values</span>
                    prev_price &lt;= price;
                    prev_volume &lt;= volume;
                    
                    <span class="hljs-comment">// Calculate volume moving average</span>
                    volume_ma &lt;= vol_sum / count;
                    
                    <span class="hljs-comment">// Set indices</span>
                    pvi &lt;= pvi_internal;
                    nvi &lt;= nvi_internal;
                    
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key implementation features:</p>
<ul>
<li>Multiple volume indicator calculation</li>
<li>On-Balance Volume (OBV) tracking</li>
<li>Positive/Negative Volume Index calculation</li>
<li>Volume moving average</li>
<li>Efficient state machine implementation</li>
</ul>
<p>Volume indicators provide:</p>
<ul>
<li>Volume trend analysis</li>
<li>Price/volume relationship assessment</li>
<li>Potential divergence identification</li>
<li>Market strength measurement</li>
<li>Trade confirmation signals</li>
</ul>
<p>These indicators enhance the trading system with volume-based insights.</p>
<h4 id="custom-indicator-framework">Custom Indicator Framework</h4>
<p>A flexible framework for custom indicator development:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> custom_indicator_framework #(
    <span class="hljs-keyword">parameter</span> PERIOD = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> INDICATOR_COUNT = <span class="hljs-number">4</span>,
    <span class="hljs-keyword">parameter</span> FUNCTION_SELECT = <span class="hljs-number">0</span>  <span class="hljs-comment">// 0=SMA, 1=EMA, 2=RSI, 3=Custom</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] config_data,  <span class="hljs-comment">// Custom configuration</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] indicator_value,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Internal signals for different indicators</span>
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sma_value;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ema_value;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi_value;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] custom_value;
    <span class="hljs-keyword">wire</span> sma_done, ema_done, rsi_done, custom_done;
    
    <span class="hljs-comment">// SMA calculation</span>
    moving_average_fsm #(
        <span class="hljs-variable">.WINDOW</span>(PERIOD),
        <span class="hljs-variable">.DW</span>(DW)
    ) sma_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.start</span>(new_data),
        <span class="hljs-variable">.new_price</span>(price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.moving_avg</span>(sma_value),
        <span class="hljs-variable">.done</span>(sma_done)
    );
    
    <span class="hljs-comment">// EMA calculation</span>
    ema_calculator #(
        <span class="hljs-variable">.PERIOD</span>(PERIOD),
        <span class="hljs-variable">.DW</span>(DW)
    ) ema_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_data</span>(new_data),
        <span class="hljs-variable">.price</span>(price),
        <span class="hljs-variable">.ema</span>(ema_value),
        <span class="hljs-variable">.done</span>(ema_done)
    );
    
    <span class="hljs-comment">// RSI calculation</span>
    rsi_inc #(
        <span class="hljs-variable">.WINDOW</span>(PERIOD),
        <span class="hljs-variable">.DW</span>(DW)
    ) rsi_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_price_strobe</span>(new_data),
        <span class="hljs-variable">.new_price</span>(price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.mem_full</span>(<span class="hljs-number">1&#x27;b1</span>),  <span class="hljs-comment">// Assume memory is managed externally</span>
        <span class="hljs-variable">.mem_count</span>(<span class="hljs-number">8&#x27;h14</span>),
        <span class="hljs-variable">.rsi</span>(rsi_value),
        <span class="hljs-variable">.done</span>(rsi_done)
    );
    
    <span class="hljs-comment">// Custom calculation (placeholder)</span>
    custom_calculation #(
        <span class="hljs-variable">.PERIOD</span>(PERIOD),
        <span class="hljs-variable">.DW</span>(DW),
        <span class="hljs-variable">.CONFIG</span>(config_data)
    ) custom_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_data</span>(new_data),
        <span class="hljs-variable">.price</span>(price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.result</span>(custom_value),
        <span class="hljs-variable">.done</span>(custom_done)
    );
    
    <span class="hljs-comment">// Indicator selection multiplexer</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            indicator_value &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (FUNCTION_SELECT)
                <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// SMA</span>
                    indicator_value &lt;= sma_value;
                    done &lt;= sma_done;
                <span class="hljs-keyword">end</span>
                <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// EMA</span>
                    indicator_value &lt;= ema_value;
                    done &lt;= ema_done;
                <span class="hljs-keyword">end</span>
                <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// RSI</span>
                    indicator_value &lt;= {<span class="hljs-number">24&#x27;d0</span>, rsi_value};  <span class="hljs-comment">// Extend to 32 bits</span>
                    done &lt;= rsi_done;
                <span class="hljs-keyword">end</span>
                <span class="hljs-number">3</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Custom</span>
                    indicator_value &lt;= custom_value;
                    done &lt;= custom_done;
                <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>
                    indicator_value &lt;= sma_value;  <span class="hljs-comment">// Default to SMA</span>
                    done &lt;= sma_done;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key framework features:</p>
<ul>
<li>Multiple indicator implementation</li>
<li>Selectable indicator function</li>
<li>Common interface</li>
<li>Parameterized configuration</li>
<li>Expandable architecture</li>
</ul>
<p>A custom indicator framework enables:</p>
<ul>
<li>Rapid prototyping of new indicators</li>
<li>Consistent interface across indicators</li>
<li>Simplified system integration</li>
<li>Reuse of common components</li>
<li>Efficient experimentation</li>
</ul>
<p>This extensible approach supports continued development of trading strategies.</p>
<h3 id="multiple-timeframes">Multiple Timeframes</h3>
<h4 id="timeframe-management-architecture">Timeframe Management Architecture</h4>
<p>A multiple timeframe system enables analysis across different time scales:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> multi_timeframe_system #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> TF_COUNT = <span class="hljs-number">3</span>  <span class="hljs-comment">// Number of timeframes</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Market data input</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    
    <span class="hljs-comment">// Timeframe configuration</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] tf_periods [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],  <span class="hljs-comment">// Downsampling periods</span>
    
    <span class="hljs-comment">// Indicator outputs</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_values [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi_values [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    
    <span class="hljs-comment">// Signal outputs</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> buy_signals [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> sell_signals [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    
    <span class="hljs-comment">// Status outputs</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> systems_ready [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]
);
    <span class="hljs-comment">// Timeframe generation signals</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] counters [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> tf_triggers [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] tf_prices [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    
    <span class="hljs-comment">// Timeframe counters and triggers</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                counters[i] &lt;= <span class="hljs-number">0</span>;
                tf_triggers[i] &lt;= <span class="hljs-number">0</span>;
                tf_prices[i] &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Always process first timeframe (original data)</span>
            tf_triggers[<span class="hljs-number">0</span>] &lt;= <span class="hljs-number">1</span>;
            tf_prices[<span class="hljs-number">0</span>] &lt;= price;
            
            <span class="hljs-comment">// Process higher timeframes with downsampling</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (counters[i] &gt;= tf_periods[i] - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Trigger this timeframe</span>
                    counters[i] &lt;= <span class="hljs-number">0</span>;
                    tf_triggers[i] &lt;= <span class="hljs-number">1</span>;
                    tf_prices[i] &lt;= price;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    counters[i] &lt;= counters[i] + <span class="hljs-number">1</span>;
                    tf_triggers[i] &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Clear triggers after one cycle</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                tf_triggers[i] &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Generate trading systems for each timeframe</span>
    <span class="hljs-keyword">genvar</span> i;
    <span class="hljs-keyword">generate</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>: tf_systems
            trading_system_singlemem tf_system (
                <span class="hljs-variable">.clk</span>(clk),
                <span class="hljs-variable">.rst</span>(rst),
                <span class="hljs-variable">.price_in</span>(tf_prices[i]),
                <span class="hljs-variable">.new_price</span>(tf_triggers[i]),
                <span class="hljs-variable">.moving_avg</span>(ma_values[i]),
                <span class="hljs-variable">.rsi</span>(rsi_values[i]),
                <span class="hljs-variable">.buy</span>(buy_signals[i]),
                <span class="hljs-variable">.sell</span>(sell_signals[i]),
                <span class="hljs-variable">.mem_full</span>(systems_ready[i])
            );
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endgenerate</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key architecture features:</p>
<ul>
<li>Configurable multiple timeframe support</li>
<li>Downsampling for higher timeframes</li>
<li>Parallel indicator calculation</li>
<li>Independent signal generation</li>
<li>Scalable implementation</li>
</ul>
<p>The multi-timeframe approach enables:</p>
<ul>
<li>Cross-timeframe analysis</li>
<li>Trend confirmation across scales</li>
<li>Nested trading strategies</li>
<li>Hierarchical market analysis</li>
<li>Comprehensive market view</li>
</ul>
<p>This architecture provides a foundation for sophisticated trading strategies.</p>
<h4 id="multi-timeframe-data-organization">Multi-Timeframe Data Organization</h4>
<p>A robust data organization strategy is essential for multi-timeframe systems:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> timeframe_data_manager #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> TF_COUNT = <span class="hljs-number">3</span>,
    <span class="hljs-keyword">parameter</span> MAX_TF_PERIOD = <span class="hljs-number">60</span>  <span class="hljs-comment">// Maximum timeframe period</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Market data input</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] high,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] low,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] volume,
    
    <span class="hljs-comment">// Timeframe configuration</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] tf_periods [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    
    <span class="hljs-comment">// Timeframe data outputs</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> tf_data_valid [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] tf_price [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] tf_high [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] tf_low [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] tf_volume [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]
);
    <span class="hljs-comment">// Timeframe accumulators</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] bar_counters [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bar_high [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bar_low [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bar_open [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] bar_volume [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> bar_initialized [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    
    <span class="hljs-comment">// Timeframe management</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset all counters and accumulators</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                bar_counters[i] &lt;= <span class="hljs-number">0</span>;
                bar_high[i] &lt;= <span class="hljs-number">0</span>;
                bar_low[i] &lt;= <span class="hljs-number">0</span>;
                bar_open[i] &lt;= <span class="hljs-number">0</span>;
                bar_volume[i] &lt;= <span class="hljs-number">0</span>;
                bar_initialized[i] &lt;= <span class="hljs-number">0</span>;
                tf_data_valid[i] &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Process first timeframe directly (raw data)</span>
            tf_data_valid[<span class="hljs-number">0</span>] &lt;= <span class="hljs-number">1</span>;
            tf_price[<span class="hljs-number">0</span>] &lt;= price;
            tf_high[<span class="hljs-number">0</span>] &lt;= high;
            tf_low[<span class="hljs-number">0</span>] &lt;= low;
            tf_volume[<span class="hljs-number">0</span>] &lt;= volume;
            
            <span class="hljs-comment">// Process higher timeframes</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Default: not valid</span>
                tf_data_valid[i] &lt;= <span class="hljs-number">0</span>;
                
                <span class="hljs-comment">// Initialize bar data if needed</span>
                <span class="hljs-keyword">if</span> (!bar_initialized[i]) <span class="hljs-keyword">begin</span>
                    bar_open[i] &lt;= price;
                    bar_high[i] &lt;= high;
                    bar_low[i] &lt;= low;
                    bar_volume[i] &lt;= volume;
                    bar_initialized[i] &lt;= <span class="hljs-number">1</span>;
                    bar_counters[i] &lt;= <span class="hljs-number">1</span>;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Update high/low/volume</span>
                    bar_high[i] &lt;= (high &gt; bar_high[i]) ? high : bar_high[i];
                    bar_low[i] &lt;= (low &lt; bar_low[i]) ? low : bar_low[i];
                    bar_volume[i] &lt;= bar_volume[i] + volume;
                    
                    <span class="hljs-comment">// Check if timeframe is complete</span>
                    <span class="hljs-keyword">if</span> (bar_counters[i] &gt;= tf_periods[i] - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Complete bar, output data</span>
                        tf_data_valid[i] &lt;= <span class="hljs-number">1</span>;
                        tf_price[i] &lt;= price;  <span class="hljs-comment">// Close price</span>
                        tf_high[i] &lt;= bar_high[i];
                        tf_low[i] &lt;= bar_low[i];
                        tf_volume[i] &lt;= bar_volume[i];
                        
                        <span class="hljs-comment">// Reset for next bar</span>
                        bar_counters[i] &lt;= <span class="hljs-number">0</span>;
                        bar_initialized[i] &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Increment counter</span>
                        bar_counters[i] &lt;= bar_counters[i] + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Clear valid signals after one cycle</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                tf_data_valid[i] &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key features of this data organization:</p>
<ul>
<li>OHLC (Open, High, Low, Close) bar construction</li>
<li>Volume aggregation across timeframes</li>
<li>Proper bar boundary handling</li>
<li>Synchronized data output</li>
<li>Configurable timeframe periods</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Comprehensive market data analysis</li>
<li>Precise timeframe boundary management</li>
<li>Complete market information across scales</li>
<li>Consistent data organization</li>
<li>Support for various indicator types</li>
</ul>
<p>The implementation efficiently manages data for multi-timeframe analysis.</p>
<h4 id="downsampling-implementation">Downsampling Implementation</h4>
<p>Effective downsampling is critical for multi-timeframe systems:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> price_downsampler #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> SAMPLE_PERIOD = <span class="hljs-number">5</span>,  <span class="hljs-comment">// Downsampling ratio</span>
    <span class="hljs-keyword">parameter</span> METHOD = <span class="hljs-number">0</span>           <span class="hljs-comment">// 0=Close, 1=OHLC, 2=VWAP</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Input data stream</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> data_valid,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] high,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] low,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] volume,
    
    <span class="hljs-comment">// Output data stream</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> out_valid,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] out_price
);
    <span class="hljs-comment">// Downsampling state</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] open_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] high_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] low_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] volume_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] volume_price_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> initialized = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            counter &lt;= <span class="hljs-number">0</span>;
            out_valid &lt;= <span class="hljs-number">0</span>;
            out_price &lt;= <span class="hljs-number">0</span>;
            initialized &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data_valid) <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">if</span> (!initialized) <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// First data point in period</span>
                counter &lt;= <span class="hljs-number">1</span>;
                open_price &lt;= price;
                high_price &lt;= high;
                low_price &lt;= low;
                volume_sum &lt;= volume;
                volume_price_sum &lt;= price * volume;
                initialized &lt;= <span class="hljs-number">1</span>;
                out_valid &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Update accumulators</span>
                high_price &lt;= (high &gt; high_price) ? high : high_price;
                low_price &lt;= (low &lt; low_price) ? low : low_price;
                volume_sum &lt;= volume_sum + volume;
                volume_price_sum &lt;= volume_price_sum + (price * volume);
                
                <span class="hljs-comment">// Check if period is complete</span>
                <span class="hljs-keyword">if</span> (counter &gt;= SAMPLE_PERIOD - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Output downsampled data based on method</span>
                    out_valid &lt;= <span class="hljs-number">1</span>;
                    
                    <span class="hljs-keyword">case</span> (METHOD)
                        <span class="hljs-number">0</span>: out_price &lt;= price;  <span class="hljs-comment">// Use closing price</span>
                        
                        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Use average of OHLC</span>
                            out_price &lt;= (open_price + high_price + 
                                        low_price + price) / <span class="hljs-number">4</span>;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Use Volume Weighted Average Price (VWAP)</span>
                            <span class="hljs-keyword">if</span> (volume_sum &gt; <span class="hljs-number">0</span>)
                                out_price &lt;= volume_price_sum / volume_sum;
                            <span class="hljs-keyword">else</span>
                                out_price &lt;= price;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: out_price &lt;= price;  <span class="hljs-comment">// Default to close</span>
                    <span class="hljs-keyword">endcase</span>
                    
                    <span class="hljs-comment">// Reset for next period</span>
                    counter &lt;= <span class="hljs-number">0</span>;
                    initialized &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Increment counter</span>
                    counter &lt;= counter + <span class="hljs-number">1</span>;
                    out_valid &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            out_valid &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">// Clear valid signal after one cycle</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key downsampling features:</p>
<ul>
<li>Multiple downsampling methods:
<ul>
<li>Close price: Most common, uses last price</li>
<li>OHLC average: Balanced representation</li>
<li>VWAP: Volume-weighted average price</li>
</ul>
</li>
<li>Proper period boundary management</li>
<li>Accumulator-based implementation</li>
<li>Clean output signaling</li>
<li>Configurable downsampling ratio</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Flexible timeframe creation</li>
<li>Method-specific downsampling</li>
<li>Accurate representation of higher timeframes</li>
<li>Efficient data reduction</li>
<li>Support for various analysis techniques</li>
</ul>
<p>Proper downsampling creates meaningful higher timeframe data.</p>
<h4 id="signal-combination-strategy">Signal Combination Strategy</h4>
<p>Combining signals across timeframes enhances strategy robustness:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> timeframe_signal_combiner #(
    <span class="hljs-keyword">parameter</span> TF_COUNT = <span class="hljs-number">3</span>,
    <span class="hljs-keyword">parameter</span> STRATEGY = <span class="hljs-number">0</span>  <span class="hljs-comment">// 0=Consensus, 1=Hierarchical, 2=Weighted</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Signals from different timeframes</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] buy_signals,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sell_signals,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] systems_ready,
    
    <span class="hljs-comment">// Optional signal strength/confidence (0-100)</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] signal_strength [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    
    <span class="hljs-comment">// Combined output signals</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] confidence
);
    <span class="hljs-comment">// Signal counts and strengths</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] buy_count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] sell_count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] buy_strength_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] sell_strength_sum = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            buy &lt;= <span class="hljs-number">0</span>;
            sell &lt;= <span class="hljs-number">0</span>;
            confidence &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Count active signals and sum strengths</span>
            buy_count = <span class="hljs-number">0</span>;
            sell_count = <span class="hljs-number">0</span>;
            buy_strength_sum = <span class="hljs-number">0</span>;
            sell_strength_sum = <span class="hljs-number">0</span>;
            
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (systems_ready[i]) <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (buy_signals[i]) <span class="hljs-keyword">begin</span>
                        buy_count = buy_count + <span class="hljs-number">1</span>;
                        buy_strength_sum = buy_strength_sum + signal_strength[i];
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-keyword">if</span> (sell_signals[i]) <span class="hljs-keyword">begin</span>
                        sell_count = sell_count + <span class="hljs-number">1</span>;
                        sell_strength_sum = sell_strength_sum + signal_strength[i];
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-comment">// Apply combination strategy</span>
            <span class="hljs-keyword">case</span> (STRATEGY)
                <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Consensus strategy - majority rule</span>
                    <span class="hljs-comment">// Require majority of ready systems to agree</span>
                    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] ready_count = <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (systems_ready[i])
                            ready_count = ready_count + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] majority = (ready_count / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;
                    
                    buy &lt;= (buy_count &gt;= majority);
                    sell &lt;= (sell_count &gt;= majority);
                    
                    <span class="hljs-comment">// Calculate confidence (0-100)</span>
                    <span class="hljs-keyword">if</span> (buy_count &gt;= majority)
                        confidence &lt;= (buy_count * <span class="hljs-number">100</span>) / ready_count;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sell_count &gt;= majority)
                        confidence &lt;= (sell_count * <span class="hljs-number">100</span>) / ready_count;
                    <span class="hljs-keyword">else</span>
                        confidence &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Hierarchical strategy - higher TFs override lower</span>
                    <span class="hljs-comment">// Start with lowest timeframe</span>
                    buy &lt;= buy_signals[<span class="hljs-number">0</span>];
                    sell &lt;= sell_signals[<span class="hljs-number">0</span>];
                    
                    <span class="hljs-comment">// Override with higher timeframes if contradicting</span>
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (systems_ready[i]) <span class="hljs-keyword">begin</span>
                            <span class="hljs-keyword">if</span> (buy_signals[i] &amp;&amp; sell_signals[i-<span class="hljs-number">1</span>])
                                sell &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">// Higher timeframe buy overrides lower TF sell</span>
                            
                            <span class="hljs-keyword">if</span> (sell_signals[i] &amp;&amp; buy_signals[i-<span class="hljs-number">1</span>])
                                buy &lt;= <span class="hljs-number">0</span>;   <span class="hljs-comment">// Higher timeframe sell overrides lower TF buy</span>
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-comment">// Confidence based on highest agreeing timeframe</span>
                    confidence &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = TF_COUNT-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (systems_ready[i] &amp;&amp; 
                           (buy_signals[i] || sell_signals[i])) <span class="hljs-keyword">begin</span>
                            confidence &lt;= <span class="hljs-number">50</span> + ((i * <span class="hljs-number">50</span>) / (TF_COUNT - <span class="hljs-number">1</span>));
                            <span class="hljs-keyword">break</span>;
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Weighted strategy - based on signal strength</span>
                    <span class="hljs-comment">// Compare total signal strength</span>
                    <span class="hljs-keyword">if</span> (buy_strength_sum &gt; sell_strength_sum) <span class="hljs-keyword">begin</span>
                        buy &lt;= <span class="hljs-number">1</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        confidence &lt;= (buy_strength_sum * <span class="hljs-number">100</span>) / 
                                     (buy_strength_sum + sell_strength_sum);
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sell_strength_sum &gt; buy_strength_sum) <span class="hljs-keyword">begin</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">1</span>;
                        confidence &lt;= (sell_strength_sum * <span class="hljs-number">100</span>) / 
                                     (buy_strength_sum + sell_strength_sum);
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        confidence &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Default to consensus</span>
                    buy &lt;= (buy_count &gt; sell_count);
                    sell &lt;= (sell_count &gt; buy_count);
                    confidence &lt;= <span class="hljs-number">50</span>;  <span class="hljs-comment">// Neutral confidence</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
            
            <span class="hljs-comment">// Never allow both buy and sell</span>
            <span class="hljs-keyword">if</span> (buy &amp;&amp; sell) <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (buy_strength_sum &gt;= sell_strength_sum) <span class="hljs-keyword">begin</span>
                    sell &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    buy &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key signal combination features:</p>
<ul>
<li>Multiple combination strategies:
<ul>
<li>Consensus: Majority of timeframes agree</li>
<li>Hierarchical: Higher timeframes override lower</li>
<li>Weighted: Signal strength determines outcome</li>
</ul>
</li>
<li>Signal confidence calculation</li>
<li>Conflict resolution</li>
<li>System readiness tracking</li>
<li>Flexible strategy selection</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Robust cross-timeframe analysis</li>
<li>Reduced false signals</li>
<li>Increased trading confidence</li>
<li>Strategy customization</li>
<li>Comprehensive market perspective</li>
</ul>
<p>Effective signal combination improves trading strategy reliability.</p>
<h4 id="resource-sharing-approach">Resource Sharing Approach</h4>
<p>Optimizing resource usage in multi-timeframe systems:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> shared_resource_timeframe_system #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> TF_COUNT = <span class="hljs-number">3</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Market data input</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    
    <span class="hljs-comment">// Timeframe configuration</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] tf_periods [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    
    <span class="hljs-comment">// Output signals</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_values [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi_values [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy_signals [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell_signals [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]
);
    <span class="hljs-comment">// Shared calculation resources</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] calc_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] calc_oldest_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> calc_trigger = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] calc_ma;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] calc_rsi;
    <span class="hljs-keyword">wire</span> calc_done;
    
    <span class="hljs-comment">// Timeframe memory</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price_history [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>][<span class="hljs-number">63</span>:<span class="hljs-number">0</span>];  <span class="hljs-comment">// Up to 64 prices per TF</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] write_ptrs [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] read_ptrs [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] item_counts [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    
    <span class="hljs-comment">// Timeframe control</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] tf_counters [TF_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] current_tf = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] calc_state = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Configuration for shared calculator</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] calc_window = <span class="hljs-number">20</span>;
    
    <span class="hljs-comment">// State machine states</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, STORE_DATA = <span class="hljs-number">1</span>, PREPARE_CALC = <span class="hljs-number">2</span>, 
               CALCULATE = <span class="hljs-number">3</span>, STORE_RESULT = <span class="hljs-number">4</span>;
    
    <span class="hljs-comment">// Shared calculator instance</span>
    shared_indicator_calculator calculator (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.start</span>(calc_trigger),
        <span class="hljs-variable">.window_size</span>(calc_window),
        <span class="hljs-variable">.price</span>(calc_price),
        <span class="hljs-variable">.oldest_price</span>(calc_oldest_price),
        <span class="hljs-variable">.moving_avg</span>(calc_ma),
        <span class="hljs-variable">.rsi</span>(calc_rsi),
        <span class="hljs-variable">.done</span>(calc_done)
    );
    
    <span class="hljs-comment">// Main control logic</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset all counters and pointers</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TF_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                tf_counters[i] &lt;= <span class="hljs-number">0</span>;
                write_ptrs[i] &lt;= <span class="hljs-number">0</span>;
                read_ptrs[i] &lt;= <span class="hljs-number">0</span>;
                item_counts[i] &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
            
            current_tf &lt;= <span class="hljs-number">0</span>;
            calc_state &lt;= IDLE;
            calc_trigger &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Default: no calculation trigger</span>
            calc_trigger &lt;= <span class="hljs-number">0</span>;
            
            <span class="hljs-keyword">case</span> (calc_state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        calc_state &lt;= STORE_DATA;
                        current_tf &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                STORE_DATA: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Check if this timeframe should process data</span>
                    <span class="hljs-keyword">if</span> (current_tf == <span class="hljs-number">0</span> || 
                        tf_counters[current_tf] &gt;= tf_periods[current_tf] - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        
                        <span class="hljs-comment">// Reset counter if needed</span>
                        <span class="hljs-keyword">if</span> (current_tf &gt; <span class="hljs-number">0</span> &amp;&amp; 
                            tf_counters[current_tf] &gt;= tf_periods[current_tf] - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                            tf_counters[current_tf] &lt;= <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current_tf &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                            tf_counters[current_tf] &lt;= tf_counters[current_tf] + <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-comment">// Store price in circular buffer</span>
                        price_history[current_tf][write_ptrs[current_tf]] &lt;= price;
                        
                        <span class="hljs-comment">// Update write pointer</span>
                        write_ptrs[current_tf] &lt;= (write_ptrs[current_tf] + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                        
                        <span class="hljs-comment">// Update item count</span>
                        <span class="hljs-keyword">if</span> (item_counts[current_tf] &lt; <span class="hljs-number">64</span>)
                            item_counts[current_tf] &lt;= item_counts[current_tf] + <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">else</span>
                            <span class="hljs-comment">// Also update read pointer if buffer is full</span>
                            read_ptrs[current_tf] &lt;= (read_ptrs[current_tf] + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                        
                        <span class="hljs-comment">// Move to calculation if ready</span>
                        <span class="hljs-keyword">if</span> (item_counts[current_tf] &gt;= <span class="hljs-number">14</span>) <span class="hljs-keyword">begin</span>
                            calc_state &lt;= PREPARE_CALC;
                        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Move to next timeframe</span>
                            <span class="hljs-keyword">if</span> (current_tf &lt; TF_COUNT - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                                current_tf &lt;= current_tf + <span class="hljs-number">1</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                calc_state &lt;= IDLE;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Increment counter for this timeframe</span>
                        tf_counters[current_tf] &lt;= tf_counters[current_tf] + <span class="hljs-number">1</span>;
                        
                        <span class="hljs-comment">// Move to next timeframe</span>
                        <span class="hljs-keyword">if</span> (current_tf &lt; TF_COUNT - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                            current_tf &lt;= current_tf + <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                            calc_state &lt;= IDLE;
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                PREPARE_CALC: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Set up calculation parameters</span>
                    calc_price &lt;= price;
                    calc_oldest_price &lt;= price_history[current_tf][read_ptrs[current_tf]];
                    calc_window &lt;= (current_tf == <span class="hljs-number">0</span>) ? <span class="hljs-number">20</span> : <span class="hljs-number">14</span>;  <span class="hljs-comment">// Example window sizes</span>
                    
                    <span class="hljs-comment">// Trigger calculation</span>
                    calc_trigger &lt;= <span class="hljs-number">1</span>;
                    calc_state &lt;= CALCULATE;
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Wait for calculation to complete</span>
                    <span class="hljs-keyword">if</span> (calc_done) <span class="hljs-keyword">begin</span>
                        calc_state &lt;= STORE_RESULT;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                STORE_RESULT: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Store results for this timeframe</span>
                    ma_values[current_tf] &lt;= calc_ma;
                    rsi_values[current_tf] &lt;= calc_rsi;
                    
                    <span class="hljs-comment">// Generate signals (simple example)</span>
                    buy_signals[current_tf] &lt;= (price &gt; calc_ma) &amp;&amp; (calc_rsi &lt; <span class="hljs-number">30</span>);
                    sell_signals[current_tf] &lt;= (price &lt; calc_ma) &amp;&amp; (calc_rsi &gt; <span class="hljs-number">70</span>);
                    
                    <span class="hljs-comment">// Move to next timeframe</span>
                    <span class="hljs-keyword">if</span> (current_tf &lt; TF_COUNT - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        current_tf &lt;= current_tf + <span class="hljs-number">1</span>;
                        calc_state &lt;= PREPARE_CALC;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        calc_state &lt;= IDLE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key resource sharing features:</p>
<ul>
<li>Single calculation engine shared across timeframes</li>
<li>Time-multiplexed operation</li>
<li>Separate memory for each timeframe</li>
<li>Sequential processing of timeframes</li>
<li>Configurable calculation parameters</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Reduced resource utilization</li>
<li>Simplified hardware implementation</li>
<li>Flexible timeframe configuration</li>
<li>Efficient resource allocation</li>
<li>Scalable multi-timeframe support</li>
</ul>
<p>Resource sharing offers a balance between functionality and efficiency.</p>
<h4 id="system-scalability-considerations">System Scalability Considerations</h4>
<p>Designing scalable multi-timeframe systems requires careful consideration:</p>
<ol>
<li>
<p><strong>Resource Scaling Analysis</strong></p>
<ul>
<li>
<p><strong>Linear Scaling Approach</strong>:</p>
<ul>
<li>Independent systems for each timeframe</li>
<li>Resource usage scales linearly with timeframe count</li>
<li>Provides maximum performance and parallelism</li>
<li>Higher resource requirements</li>
<li>Simplest implementation</li>
<li></li>
</ul>
</li>
<li>
<p><strong>Shared Resource Approach</strong>:</p>
<ul>
<li>Common calculation engine</li>
<li>Time-multiplexed operation</li>
<li>Reduced resource usage</li>
<li>Sequential processing with increased latency</li>
<li>More complex control logic</li>
</ul>
</li>
<li>
<p><strong>Hybrid Approach</strong>:</p>
<ul>
<li>Critical components duplicated</li>
<li>Shared secondary resources</li>
<li>Balanced performance and resource usage</li>
<li>Selective parallelism</li>
<li>Optimized for specific application needs</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Timeframe Count Scaling</strong></p>
<ul>
<li>
<p><strong>Performance Impact</strong>:</p>
<ul>
<li>Linear increase in calculation time for shared resources</li>
<li>Memory requirements scale directly with timeframe count</li>
<li>Control complexity increases with timeframe count</li>
<li>Signal combination logic grows quadratically</li>
<li>System latency affected by processing approach</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Impact</strong>:</p>
<ul>
<li>Independent systems: Linear scaling of all resources</li>
<li>Shared calculation: Linear scaling of memory only</li>
<li>Memory requirements dominant in high timeframe count</li>
<li>DSP usage critical for calculation-heavy designs</li>
<li>Control logic overhead increases with timeframe count</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Implementation Strategies</strong></p>
<ul>
<li>
<p><strong>Low Timeframe Count (2-3)</strong>:</p>
<ul>
<li>Full parallelism practical</li>
<li>Independent systems for each timeframe</li>
<li>Direct signal combination</li>
<li>Minimal control complexity</li>
<li>Maximum performance achievable</li>
</ul>
</li>
<li>
<p><strong>Medium Timeframe Count (4-8)</strong>:</p>
<ul>
<li>Hybrid approach recommended</li>
<li>Parallel primary indicators</li>
<li>Shared secondary indicators</li>
<li>Hierarchical control structure</li>
<li>Balanced performance and resources</li>
</ul>
</li>
<li>
<p><strong>High Timeframe Count (8+)</strong>:</p>
<ul>
<li>Shared resource approach necessary</li>
<li>Time-multiplexed calculation</li>
<li>Optimized memory structure</li>
<li>Priority-based processing</li>
<li>Sequential operation with critical path optimization</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Scalability Limits</strong></p>
<ul>
<li>
<p><strong>Memory Constraints</strong>:</p>
<ul>
<li>BRAM capacity may limit history depth</li>
<li>Consider external memory for highest timeframes</li>
<li>Implement efficient compression for historical data</li>
<li>Use sparse representation for higher timeframes</li>
<li>Balance precision and storage requirements</li>
</ul>
</li>
<li>
<p><strong>Processing Constraints</strong>:</p>
<ul>
<li>Time-multiplexing limits throughput</li>
<li>Market data rate establishes minimum processing speed</li>
<li>Critical path in calculation engine</li>
<li>Complex signal combination logic</li>
<li>Control state growth with timeframe count</li>
</ul>
</li>
<li>
<p><strong>Practical Limits</strong>:</p>
<ul>
<li>8-12 timeframes typical maximum for mid-range FPGAs</li>
<li>Trade-off between timeframe count and indicator complexity</li>
<li>Consider multiple FPGA solution for highest scale</li>
<li>Hierarchical processing for extreme scalability</li>
<li>Balance timeframe coverage with implementation complexity</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>These scalability considerations enable the development of multi-timeframe systems tailored to specific trading requirements and hardware constraints.</p>
<h3 id="advanced-trading-strategies">Advanced Trading Strategies</h3>
<h4 id="moving-average-crossover-implementation">Moving Average Crossover Implementation</h4>
<p>A moving average crossover strategy identifies trend changes through MA interactions:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> ma_crossover_strategy #(
    <span class="hljs-keyword">parameter</span> FAST_MA_PERIOD = <span class="hljs-number">10</span>,
    <span class="hljs-keyword">parameter</span> SLOW_MA_PERIOD = <span class="hljs-number">50</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price_fast,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price_slow,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] fast_ma,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] slow_ma,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> trend,  <span class="hljs-comment">// 1 = uptrend, 0 = downtrend</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Internal signals</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] fast_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] slow_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> prev_cross_state = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 1 = fast above slow</span>
    <span class="hljs-keyword">reg</span> cross_state = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// State machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, CALCULATE = <span class="hljs-number">1</span>, DETECT_CROSS = <span class="hljs-number">2</span>, COMPLETE = <span class="hljs-number">3</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            fast_sum &lt;= <span class="hljs-number">0</span>;
            slow_sum &lt;= <span class="hljs-number">0</span>;
            fast_ma &lt;= <span class="hljs-number">0</span>;
            slow_ma &lt;= <span class="hljs-number">0</span>;
            buy &lt;= <span class="hljs-number">0</span>;
            sell &lt;= <span class="hljs-number">0</span>;
            trend &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            state &lt;= IDLE;
            prev_cross_state &lt;= <span class="hljs-number">0</span>;
            cross_state &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        state &lt;= CALCULATE;
                        <span class="hljs-comment">// Clear signals</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        done &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Update fast MA</span>
                    fast_sum &lt;= fast_sum + price - oldest_price_fast;
                    fast_ma &lt;= fast_sum / FAST_MA_PERIOD;
                    
                    <span class="hljs-comment">// Update slow MA</span>
                    slow_sum &lt;= slow_sum + price - oldest_price_slow;
                    slow_ma &lt;= slow_sum / SLOW_MA_PERIOD;
                    
                    state &lt;= DETECT_CROSS;
                <span class="hljs-keyword">end</span>
                
                DETECT_CROSS: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Determine current crossover state</span>
                    prev_cross_state &lt;= cross_state;
                    cross_state &lt;= (fast_ma &gt;= slow_ma) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;
                    
                    <span class="hljs-comment">// Current trend direction</span>
                    trend &lt;= cross_state;
                    
                    <span class="hljs-comment">// Check for crossover</span>
                    <span class="hljs-keyword">if</span> (cross_state != prev_cross_state) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (cross_state == <span class="hljs-number">1&#x27;b1</span>) <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Fast crossed above slow = Buy signal</span>
                            buy &lt;= <span class="hljs-number">1&#x27;b1</span>;
                            sell &lt;= <span class="hljs-number">1&#x27;b0</span>;
                        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Fast crossed below slow = Sell signal</span>
                            buy &lt;= <span class="hljs-number">1&#x27;b0</span>;
                            sell &lt;= <span class="hljs-number">1&#x27;b1</span>;
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// No crossover</span>
                        buy &lt;= <span class="hljs-number">1&#x27;b0</span>;
                        sell &lt;= <span class="hljs-number">1&#x27;b0</span>;
                    <span class="hljs-keyword">end</span>
                    
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1&#x27;b1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: state &lt;= IDLE;
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key implementation features:</p>
<ul>
<li>Dual moving average calculation</li>
<li>Crossover detection logic</li>
<li>Signal generation on MA crossovers</li>
<li>Trend direction tracking</li>
<li>Efficient state machine implementation</li>
</ul>
<p>This strategy offers:</p>
<ul>
<li>Trend direction identification</li>
<li>Entry and exit signal generation</li>
<li>Reduced whipsaw in trending markets</li>
<li>Clear trend visualization</li>
<li>Foundation for more complex strategies</li>
</ul>
<p>Moving average crossovers provide reliable trend-following signals across various markets and timeframes.</p>
<h4 id="multi-indicator-strategies">Multi-Indicator Strategies</h4>
<p>Complex strategies combining multiple indicators enhance trading effectiveness:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> multi_indicator_strategy #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> MA_PERIOD = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> RSI_PERIOD = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> RSI_OVERSOLD = <span class="hljs-number">30</span>,
    <span class="hljs-keyword">parameter</span> RSI_OVERBOUGHT = <span class="hljs-number">70</span>,
    <span class="hljs-keyword">parameter</span> BB_STDEV = <span class="hljs-number">2</span>     <span class="hljs-comment">// Bollinger Band standard deviation multiplier</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] signal_strength,  <span class="hljs-comment">// 0-15 scale</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Indicator outputs</span>
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_value;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi_value;
    <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bb_upper, bb_middle, bb_lower;
    <span class="hljs-keyword">wire</span> ma_done, rsi_done, bb_done;
    
    <span class="hljs-comment">// Moving Average calculator</span>
    moving_average_fsm #(
        <span class="hljs-variable">.WINDOW</span>(MA_PERIOD),
        <span class="hljs-variable">.DW</span>(DW)
    ) ma_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.start</span>(new_data),
        <span class="hljs-variable">.new_price</span>(price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.moving_avg</span>(ma_value),
        <span class="hljs-variable">.done</span>(ma_done)
    );
    
    <span class="hljs-comment">// RSI calculator</span>
    rsi_inc #(
        <span class="hljs-variable">.WINDOW</span>(RSI_PERIOD),
        <span class="hljs-variable">.DW</span>(DW)
    ) rsi_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_price_strobe</span>(new_data),
        <span class="hljs-variable">.new_price</span>(price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.mem_full</span>(<span class="hljs-number">1&#x27;b1</span>),
        <span class="hljs-variable">.mem_count</span>(<span class="hljs-number">8&#x27;h14</span>),
        <span class="hljs-variable">.rsi</span>(rsi_value),
        <span class="hljs-variable">.done</span>(rsi_done)
    );
    
    <span class="hljs-comment">// Bollinger Bands calculator</span>
    bollinger_bands #(
        <span class="hljs-variable">.PERIOD</span>(MA_PERIOD),
        <span class="hljs-variable">.STDEV_MULT</span>(BB_STDEV),
        <span class="hljs-variable">.DW</span>(DW)
    ) bb_calc (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.new_data</span>(new_data),
        <span class="hljs-variable">.price</span>(price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.middle_band</span>(bb_middle),
        <span class="hljs-variable">.upper_band</span>(bb_upper),
        <span class="hljs-variable">.lower_band</span>(bb_lower),
        <span class="hljs-variable">.done</span>(bb_done)
    );
    
    <span class="hljs-comment">// Strategy state machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, WAIT_RESULTS = <span class="hljs-number">1</span>, EVALUATE = <span class="hljs-number">2</span>, SIGNAL = <span class="hljs-number">3</span>, COMPLETE = <span class="hljs-number">4</span>;
    
    <span class="hljs-comment">// Signal contribution counters</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] buy_count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sell_count = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            buy &lt;= <span class="hljs-number">0</span>;
            sell &lt;= <span class="hljs-number">0</span>;
            signal_strength &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            state &lt;= IDLE;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        state &lt;= WAIT_RESULTS;
                        <span class="hljs-comment">// Reset signals</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        done &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                WAIT_RESULTS: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Wait for all indicators to complete</span>
                    <span class="hljs-keyword">if</span> (ma_done &amp;&amp; rsi_done &amp;&amp; bb_done) <span class="hljs-keyword">begin</span>
                        state &lt;= EVALUATE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                EVALUATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Reset counters</span>
                    buy_count &lt;= <span class="hljs-number">0</span>;
                    sell_count &lt;= <span class="hljs-number">0</span>;
                    
                    <span class="hljs-comment">// Evaluate MA trend</span>
                    <span class="hljs-keyword">if</span> (price &gt; ma_value)
                        buy_count &lt;= buy_count + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; ma_value)
                        sell_count &lt;= sell_count + <span class="hljs-number">1</span>;
                    
                    <span class="hljs-comment">// Evaluate RSI conditions</span>
                    <span class="hljs-keyword">if</span> (rsi_value &lt; RSI_OVERSOLD)
                        buy_count &lt;= buy_count + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rsi_value &gt; RSI_OVERBOUGHT)
                        sell_count &lt;= sell_count + <span class="hljs-number">1</span>;
                    
                    <span class="hljs-comment">// Evaluate Bollinger Bands</span>
                    <span class="hljs-keyword">if</span> (price &lt; bb_lower)
                        buy_count &lt;= buy_count + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &gt; bb_upper)
                        sell_count &lt;= sell_count + <span class="hljs-number">1</span>;
                    
                    state &lt;= SIGNAL;
                <span class="hljs-keyword">end</span>
                
                SIGNAL: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Generate signals based on indicator agreement</span>
                    <span class="hljs-keyword">if</span> (buy_count &gt; sell_count &amp;&amp; buy_count &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">begin</span>
                        buy &lt;= <span class="hljs-number">1</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        signal_strength &lt;= buy_count * <span class="hljs-number">5</span>;  <span class="hljs-comment">// Scale 0-15</span>
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sell_count &gt; buy_count &amp;&amp; sell_count &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">begin</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">1</span>;
                        signal_strength &lt;= sell_count * <span class="hljs-number">5</span>;  <span class="hljs-comment">// Scale 0-15</span>
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        signal_strength &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                    
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: state &lt;= IDLE;
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key multi-indicator features:</p>
<ul>
<li>Integration of three complementary indicators</li>
<li>Weighted agreement system</li>
<li>Signal strength indication</li>
<li>Efficient parallel calculation</li>
<li>Comprehensive market perspective</li>
</ul>
<p>This approach provides:</p>
<ul>
<li>Reduced false signals through confirmation</li>
<li>Multi-factor decision making</li>
<li>Balanced trend and momentum analysis</li>
<li>Adaptive market condition response</li>
<li>Enhanced signal quality</li>
</ul>
<p>Multi-indicator strategies create robust trading systems with improved risk management.</p>
<h4 id="volatility-based-position-sizing">Volatility-Based Position Sizing</h4>
<p>Adaptive position sizing based on market volatility enhances risk management:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> volatility_position_sizing #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> VOLATILITY_PERIOD = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> BASE_POSITION = <span class="hljs-number">100</span>,    <span class="hljs-comment">// Base position size (%)</span>
    <span class="hljs-keyword">parameter</span> MAX_POSITION = <span class="hljs-number">200</span>,     <span class="hljs-comment">// Maximum position size (%)</span>
    <span class="hljs-keyword">parameter</span> MIN_POSITION = <span class="hljs-number">25</span>       <span class="hljs-comment">// Minimum position size (%)</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> buy_signal,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> sell_signal,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] position_size,   <span class="hljs-comment">// Percentage of maximum position</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] volatility,     <span class="hljs-comment">// Current volatility measure</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Internal signals</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] prices [VOLATILITY_PERIOD-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] avg_price;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] sum_deviation;
    
    <span class="hljs-comment">// State machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, STORE_PRICE = <span class="hljs-number">1</span>, CALC_AVG = <span class="hljs-number">2</span>, 
               CALC_VOLATILITY = <span class="hljs-number">3</span>, SIZE_POSITION = <span class="hljs-number">4</span>, COMPLETE = <span class="hljs-number">5</span>;
    
    <span class="hljs-comment">// Calculation variables</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] price_sum;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] count;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset all registers</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; VOLATILITY_PERIOD; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                prices[i] &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
            avg_price &lt;= <span class="hljs-number">0</span>;
            sum_deviation &lt;= <span class="hljs-number">0</span>;
            volatility &lt;= <span class="hljs-number">0</span>;
            position_size &lt;= BASE_POSITION;
            buy &lt;= <span class="hljs-number">0</span>;
            sell &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            state &lt;= IDLE;
            price_sum &lt;= <span class="hljs-number">0</span>;
            count &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        state &lt;= STORE_PRICE;
                        <span class="hljs-comment">// Clear signals</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        done &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                STORE_PRICE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Shift prices and add new one</span>
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = VOLATILITY_PERIOD-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        prices[i] &lt;= prices[i-<span class="hljs-number">1</span>];
                    <span class="hljs-keyword">end</span>
                    prices[<span class="hljs-number">0</span>] &lt;= price;
                    
                    <span class="hljs-comment">// Update counter</span>
                    <span class="hljs-keyword">if</span> (count &lt; VOLATILITY_PERIOD)
                        count &lt;= count + <span class="hljs-number">1</span>;
                    
                    state &lt;= CALC_AVG;
                <span class="hljs-keyword">end</span>
                
                CALC_AVG: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculate average price</span>
                    price_sum &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; VOLATILITY_PERIOD; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (i &lt; count)
                            price_sum &lt;= price_sum + prices[i];
                    <span class="hljs-keyword">end</span>
                    
                    avg_price &lt;= price_sum / count;
                    state &lt;= CALC_VOLATILITY;
                <span class="hljs-keyword">end</span>
                
                CALC_VOLATILITY: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculate average deviation (simplified volatility)</span>
                    sum_deviation &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; VOLATILITY_PERIOD; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (i &lt; count) <span class="hljs-keyword">begin</span>
                            <span class="hljs-keyword">if</span> (prices[i] &gt; avg_price)
                                sum_deviation &lt;= sum_deviation + (prices[i] - avg_price);
                            <span class="hljs-keyword">else</span>
                                sum_deviation &lt;= sum_deviation + (avg_price - prices[i]);
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-comment">// Calculate volatility as percentage of average price</span>
                    volatility &lt;= (sum_deviation * <span class="hljs-number">100</span>) / (avg_price * count);
                    
                    state &lt;= SIZE_POSITION;
                <span class="hljs-keyword">end</span>
                
                SIZE_POSITION: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Inverse relationship between volatility and position size</span>
                    <span class="hljs-keyword">if</span> (volatility &lt;= <span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Low volatility - maximum position</span>
                        position_size &lt;= MAX_POSITION;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (volatility &gt;= <span class="hljs-number">20</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// High volatility - minimum position</span>
                        position_size &lt;= MIN_POSITION;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Linear scale between min and max</span>
                        position_size &lt;= MAX_POSITION - 
                                        ((volatility - <span class="hljs-number">5</span>) * (MAX_POSITION - MIN_POSITION)) / <span class="hljs-number">15</span>;
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-comment">// Pass through signals with position sizing</span>
                    buy &lt;= buy_signal;
                    sell &lt;= sell_signal;
                    
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: state &lt;= IDLE;
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key position sizing features:</p>
<ul>
<li>Average deviation volatility calculation</li>
<li>Inverse volatility-position relationship</li>
<li>Configurable position size limits</li>
<li>Signal pass-through with sizing</li>
<li>Adaptive risk management</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Reduced exposure during high volatility</li>
<li>Increased position size in stable markets</li>
<li>Systematic risk management</li>
<li>Adaptive capital allocation</li>
<li>Enhanced risk-adjusted returns</li>
</ul>
<p>Volatility-based position sizing creates more robust trading systems with improved risk control.</p>
<h4 id="custom-strategy-framework">Custom Strategy Framework</h4>
<p>A flexible framework enables rapid development of custom strategies:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> custom_strategy_framework #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> INDICATOR_COUNT = <span class="hljs-number">4</span>,
    <span class="hljs-keyword">parameter</span> STRATEGY_ID = <span class="hljs-number">0</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] indicator_values [INDICATOR_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> indicators_ready [INDICATOR_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] param1,  <span class="hljs-comment">// Custom strategy parameters</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] param2,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] param3,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] confidence,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Strategy ID definitions</span>
    <span class="hljs-keyword">localparam</span> TREND_FOLLOW = <span class="hljs-number">0</span>, MEAN_REVERSION = <span class="hljs-number">1</span>, 
               BREAKOUT = <span class="hljs-number">2</span>, MULTI_TIMEFRAME = <span class="hljs-number">3</span>;
    
    <span class="hljs-comment">// Strategy state</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, WAIT_INDICATORS = <span class="hljs-number">1</span>, EVALUATE = <span class="hljs-number">2</span>, SIGNAL = <span class="hljs-number">3</span>, COMPLETE = <span class="hljs-number">4</span>;
    
    <span class="hljs-comment">// Internal signals</span>
    <span class="hljs-keyword">reg</span> all_indicators_ready;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            buy &lt;= <span class="hljs-number">0</span>;
            sell &lt;= <span class="hljs-number">0</span>;
            confidence &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            state &lt;= IDLE;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        state &lt;= WAIT_INDICATORS;
                        <span class="hljs-comment">// Clear signals</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        done &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                WAIT_INDICATORS: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Check if all indicators are ready</span>
                    all_indicators_ready = <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; INDICATOR_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (!indicators_ready[i])
                            all_indicators_ready = <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-keyword">if</span> (all_indicators_ready)
                        state &lt;= EVALUATE;
                <span class="hljs-keyword">end</span>
                
                EVALUATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Implement strategy-specific logic</span>
                    <span class="hljs-keyword">case</span> (STRATEGY_ID)
                        TREND_FOLLOW: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Trend following strategy</span>
                            <span class="hljs-comment">// Assuming indicator_values[0] = MA, indicator_values[1] = RSI</span>
                            
                            <span class="hljs-keyword">if</span> (price &gt; indicator_values[<span class="hljs-number">0</span>] &amp;&amp; indicator_values[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">50</span>) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Uptrend with momentum</span>
                                buy &lt;= <span class="hljs-number">1</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">70</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; indicator_values[<span class="hljs-number">0</span>] &amp;&amp; indicator_values[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">50</span>) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Downtrend with momentum</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">1</span>;
                                confidence &lt;= <span class="hljs-number">70</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// No clear signal</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        MEAN_REVERSION: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Mean reversion strategy</span>
                            <span class="hljs-comment">// Assuming indicator_values[0] = MA, indicator_values[1] = RSI,</span>
                            <span class="hljs-comment">// indicator_values[2] = BB_upper, indicator_values[3] = BB_lower</span>
                            
                            <span class="hljs-keyword">if</span> (indicator_values[<span class="hljs-number">1</span>] &lt; param1 &amp;&amp; price &lt; indicator_values[<span class="hljs-number">3</span>]) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Oversold below lower band</span>
                                buy &lt;= <span class="hljs-number">1</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">80</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (indicator_values[<span class="hljs-number">1</span>] &gt; param2 &amp;&amp; price &gt; indicator_values[<span class="hljs-number">2</span>]) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Overbought above upper band</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">1</span>;
                                confidence &lt;= <span class="hljs-number">80</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// No clear signal</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        BREAKOUT: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Breakout strategy</span>
                            <span class="hljs-comment">// Assuming indicator_values[2] = highest_high, indicator_values[3] = lowest_low</span>
                            
                            <span class="hljs-keyword">if</span> (price &gt; indicator_values[<span class="hljs-number">2</span>] &amp;&amp; price &gt; indicator_values[<span class="hljs-number">0</span>]) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Bullish breakout above resistance</span>
                                buy &lt;= <span class="hljs-number">1</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">60</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; indicator_values[<span class="hljs-number">3</span>] &amp;&amp; price &lt; indicator_values[<span class="hljs-number">0</span>]) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Bearish breakout below support</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">1</span>;
                                confidence &lt;= <span class="hljs-number">60</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// No breakout</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        MULTI_TIMEFRAME: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Multi-timeframe strategy</span>
                            <span class="hljs-comment">// Assuming values from different timeframes</span>
                            
                            <span class="hljs-keyword">if</span> (indicator_values[<span class="hljs-number">0</span>] &gt; indicator_values[<span class="hljs-number">1</span>] &amp;&amp; 
                                indicator_values[<span class="hljs-number">2</span>] &lt; param1) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Short-term MA above medium-term, RSI oversold</span>
                                buy &lt;= <span class="hljs-number">1</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">65</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (indicator_values[<span class="hljs-number">0</span>] &lt; indicator_values[<span class="hljs-number">1</span>] &amp;&amp; 
                                       indicator_values[<span class="hljs-number">2</span>] &gt; param2) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Short-term MA below medium-term, RSI overbought</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">1</span>;
                                confidence &lt;= <span class="hljs-number">65</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// No signal</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Default strategy (simple MA crossover)</span>
                            <span class="hljs-keyword">if</span> (price &gt; indicator_values[<span class="hljs-number">0</span>]) <span class="hljs-keyword">begin</span>
                                buy &lt;= <span class="hljs-number">1</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">50</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; indicator_values[<span class="hljs-number">0</span>]) <span class="hljs-keyword">begin</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">1</span>;
                                confidence &lt;= <span class="hljs-number">50</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                buy &lt;= <span class="hljs-number">0</span>;
                                sell &lt;= <span class="hljs-number">0</span>;
                                confidence &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">endcase</span>
                    
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: state &lt;= IDLE;
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key framework features:</p>
<ul>
<li>Multiple predefined strategy types</li>
<li>Configurable parameters</li>
<li>Indicator independence</li>
<li>Signal confidence indication</li>
<li>Expandable strategy library</li>
</ul>
<p>This framework enables:</p>
<ul>
<li>Rapid strategy development</li>
<li>Consistent interface across strategies</li>
<li>Easy experimentation with parameters</li>
<li>Strategy combination and hybridization</li>
<li>Efficient implementation of diverse approaches</li>
</ul>
<p>The custom strategy framework provides a foundation for trading system research and development.</p>
<h4 id="strategy-parameterization-approach">Strategy Parameterization Approach</h4>
<p>Effective parameterization enables strategy optimization and adaptation:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> parameterized_strategy #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> PARAM_COUNT = <span class="hljs-number">8</span>,
    <span class="hljs-keyword">parameter</span> STRATEGY_TYPE = <span class="hljs-number">0</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Market data</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    
    <span class="hljs-comment">// Indicators</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_value,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi_value,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bb_upper,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] bb_lower,
    
    <span class="hljs-comment">// Strategy parameters</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] parameters [PARAM_COUNT-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>],
    
    <span class="hljs-comment">// Output signals</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] confidence,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Parameter index definitions</span>
    <span class="hljs-keyword">localparam</span> RSI_OVERSOLD = <span class="hljs-number">0</span>,
               RSI_OVERBOUGHT = <span class="hljs-number">1</span>,
               MA_TYPE = <span class="hljs-number">2</span>,
               BB_STDEV = <span class="hljs-number">3</span>,
               SIGNAL_THRESHOLD = <span class="hljs-number">4</span>,
               LOOKBACK_PERIOD = <span class="hljs-number">5</span>,
               SENSITIVITY = <span class="hljs-number">6</span>,
               FILTER_STRENGTH = <span class="hljs-number">7</span>;
    
    <span class="hljs-comment">// State machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, EVALUATE = <span class="hljs-number">1</span>, FILTER = <span class="hljs-number">2</span>, COMPLETE = <span class="hljs-number">3</span>;
    
    <span class="hljs-comment">// Internal signals</span>
    <span class="hljs-keyword">reg</span> raw_buy, raw_sell;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] raw_confidence;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            buy &lt;= <span class="hljs-number">0</span>;
            sell &lt;= <span class="hljs-number">0</span>;
            confidence &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            state &lt;= IDLE;
            raw_buy &lt;= <span class="hljs-number">0</span>;
            raw_sell &lt;= <span class="hljs-number">0</span>;
            raw_confidence &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        state &lt;= EVALUATE;
                        <span class="hljs-comment">// Clear signals</span>
                        done &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                EVALUATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Strategy-specific signal generation using parameters</span>
                    <span class="hljs-keyword">case</span> (STRATEGY_TYPE)
                        <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// RSI Mean Reversion</span>
                            <span class="hljs-comment">// Raw signals based on RSI thresholds</span>
                            raw_buy &lt;= (rsi_value &lt; parameters[RSI_OVERSOLD]);
                            raw_sell &lt;= (rsi_value &gt; parameters[RSI_OVERBOUGHT]);
                            
                            <span class="hljs-comment">// Confidence calculation</span>
                            <span class="hljs-keyword">if</span> (rsi_value &lt; parameters[RSI_OVERSOLD])
                                raw_confidence &lt;= parameters[RSI_OVERSOLD] - rsi_value;
                            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rsi_value &gt; parameters[RSI_OVERBOUGHT])
                                raw_confidence &lt;= rsi_value - parameters[RSI_OVERBOUGHT];
                            <span class="hljs-keyword">else</span>
                                raw_confidence &lt;= <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// MA + RSI Trend Following</span>
                            <span class="hljs-comment">// Trend determination with RSI confirmation</span>
                            <span class="hljs-keyword">if</span> (price &gt; ma_value &amp;&amp; rsi_value &gt; <span class="hljs-number">50</span> &amp;&amp; 
                                rsi_value &lt; parameters[RSI_OVERBOUGHT]) <span class="hljs-keyword">begin</span>
                                raw_buy &lt;= <span class="hljs-number">1</span>;
                                raw_sell &lt;= <span class="hljs-number">0</span>;
                                raw_confidence &lt;= (rsi_value - <span class="hljs-number">50</span>) * <span class="hljs-number">2</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; ma_value &amp;&amp; rsi_value &lt; <span class="hljs-number">50</span> &amp;&amp; 
                                       rsi_value &gt; parameters[RSI_OVERSOLD]) <span class="hljs-keyword">begin</span>
                                raw_buy &lt;= <span class="hljs-number">0</span>;
                                raw_sell &lt;= <span class="hljs-number">1</span>;
                                raw_confidence &lt;= (<span class="hljs-number">50</span> - rsi_value) * <span class="hljs-number">2</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                raw_buy &lt;= <span class="hljs-number">0</span>;
                                raw_sell &lt;= <span class="hljs-number">0</span>;
                                raw_confidence &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Bollinger Band Breakout</span>
                            <span class="hljs-comment">// Breakout detection with sensitivity parameter</span>
                            <span class="hljs-keyword">if</span> (price &gt; bb_upper + (parameters[SENSITIVITY] * price / <span class="hljs-number">1000</span>)) <span class="hljs-keyword">begin</span>
                                raw_buy &lt;= <span class="hljs-number">1</span>;
                                raw_sell &lt;= <span class="hljs-number">0</span>;
                                raw_confidence &lt;= <span class="hljs-number">70</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; bb_lower - (parameters[SENSITIVITY] * price / <span class="hljs-number">1000</span>)) <span class="hljs-keyword">begin</span>
                                raw_buy &lt;= <span class="hljs-number">0</span>;
                                raw_sell &lt;= <span class="hljs-number">1</span>;
                                raw_confidence &lt;= <span class="hljs-number">70</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                raw_buy &lt;= <span class="hljs-number">0</span>;
                                raw_sell &lt;= <span class="hljs-number">0</span>;
                                raw_confidence &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Simple RSI strategy</span>
                            raw_buy &lt;= (rsi_value &lt; parameters[RSI_OVERSOLD]);
                            raw_sell &lt;= (rsi_value &gt; parameters[RSI_OVERBOUGHT]);
                            raw_confidence &lt;= <span class="hljs-number">50</span>;
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">endcase</span>
                    
                    state &lt;= FILTER;
                <span class="hljs-keyword">end</span>
                
                FILTER: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Signal filtering based on strength parameter</span>
                    <span class="hljs-keyword">if</span> (raw_buy &amp;&amp; raw_confidence &gt;= parameters[SIGNAL_THRESHOLD]) <span class="hljs-keyword">begin</span>
                        buy &lt;= <span class="hljs-number">1</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        confidence &lt;= raw_confidence;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (raw_sell &amp;&amp; raw_confidence &gt;= parameters[SIGNAL_THRESHOLD]) <span class="hljs-keyword">begin</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">1</span>;
                        confidence &lt;= raw_confidence;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        buy &lt;= <span class="hljs-number">0</span>;
                        sell &lt;= <span class="hljs-number">0</span>;
                        confidence &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                    
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: state &lt;= IDLE;
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key parameterization features:</p>
<ul>
<li>Multiple parameter categories</li>
<li>Strategy-specific parameter usage</li>
<li>Signal filtering based on parameters</li>
<li>Confidence calculation</li>
<li>Sensitivity and threshold control</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Strategy optimization through parameter tuning</li>
<li>Adaptation to different market conditions</li>
<li>Backtesting with parameter sweeps</li>
<li>Controlled signal generation</li>
<li>Systematic strategy development</li>
</ul>
<p>Effective parameterization creates adaptable trading systems with improved performance across various market conditions.</p>
<h4 id="strategy-performance-metrics">Strategy Performance Metrics</h4>
<p>An integrated metrics system enables strategy evaluation and optimization:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> strategy_performance_metrics #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> MAX_TRADES = <span class="hljs-number">32</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Trading signals</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> buy,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> sell,
    
    <span class="hljs-comment">// Price data</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    
    <span class="hljs-comment">// Control</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> reset_stats,
    
    <span class="hljs-comment">// Performance metrics</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] total_trades,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] winning_trades,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] losing_trades,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] win_rate_pct,       <span class="hljs-comment">// Win rate * 100</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] avg_win_pts,        <span class="hljs-comment">// Average win in price points</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] avg_loss_pts,       <span class="hljs-comment">// Average loss in price points</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] profit_factor_pct,  <span class="hljs-comment">// Profit factor * 100</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] max_drawdown,       <span class="hljs-comment">// Maximum drawdown</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] current_equity,     <span class="hljs-comment">// Current equity value</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Trade tracking registers</span>
    <span class="hljs-keyword">reg</span> in_position = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] entry_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] position_pnl = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Performance tracking</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] total_profit = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] total_loss = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] cumulative_profit = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] peak_equity = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] trade_results [MAX_TRADES-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] trade_index = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// State machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, PROCESS_SIGNALS = <span class="hljs-number">1</span>, UPDATE_METRICS = <span class="hljs-number">2</span>, CALCULATE = <span class="hljs-number">3</span>, COMPLETE = <span class="hljs-number">4</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst || reset_stats) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset all performance metrics</span>
            total_trades &lt;= <span class="hljs-number">0</span>;
            winning_trades &lt;= <span class="hljs-number">0</span>;
            losing_trades &lt;= <span class="hljs-number">0</span>;
            win_rate_pct &lt;= <span class="hljs-number">0</span>;
            avg_win_pts &lt;= <span class="hljs-number">0</span>;
            avg_loss_pts &lt;= <span class="hljs-number">0</span>;
            profit_factor_pct &lt;= <span class="hljs-number">0</span>;
            max_drawdown &lt;= <span class="hljs-number">0</span>;
            current_equity &lt;= <span class="hljs-number">0</span>;
            
            in_position &lt;= <span class="hljs-number">0</span>;
            entry_price &lt;= <span class="hljs-number">0</span>;
            position_pnl &lt;= <span class="hljs-number">0</span>;
            total_profit &lt;= <span class="hljs-number">0</span>;
            total_loss &lt;= <span class="hljs-number">0</span>;
            cumulative_profit &lt;= <span class="hljs-number">0</span>;
            peak_equity &lt;= <span class="hljs-number">0</span>;
            trade_index &lt;= <span class="hljs-number">0</span>;
            
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_TRADES; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                trade_results[i] &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
            
            done &lt;= <span class="hljs-number">0</span>;
            state &lt;= IDLE;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_price) <span class="hljs-keyword">begin</span>
                        state &lt;= PROCESS_SIGNALS;
                        done &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                PROCESS_SIGNALS: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Process new position entries</span>
                    <span class="hljs-keyword">if</span> (!in_position &amp;&amp; buy) <span class="hljs-keyword">begin</span>
                        in_position &lt;= <span class="hljs-number">1</span>;
                        entry_price &lt;= price;
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-comment">// Process position exits</span>
                    <span class="hljs-keyword">if</span> (in_position &amp;&amp; (sell || (buy &amp;&amp; entry_price != price))) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Calculate trade result</span>
                        position_pnl &lt;= price - entry_price;
                        
                        <span class="hljs-comment">// Store result</span>
                        <span class="hljs-keyword">if</span> (trade_index &lt; MAX_TRADES) <span class="hljs-keyword">begin</span>
                            trade_results[trade_index] &lt;= price - entry_price;
                            trade_index &lt;= trade_index + <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-comment">// Update totals</span>
                        total_trades &lt;= total_trades + <span class="hljs-number">1</span>;
                        
                        <span class="hljs-keyword">if</span> (price &gt; entry_price) <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Winning trade</span>
                            winning_trades &lt;= winning_trades + <span class="hljs-number">1</span>;
                            total_profit &lt;= total_profit + (price - entry_price);
                        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; entry_price) <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Losing trade</span>
                            losing_trades &lt;= losing_trades + <span class="hljs-number">1</span>;
                            total_loss &lt;= total_loss + (entry_price - price);
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-comment">// Update equity</span>
                        cumulative_profit &lt;= cumulative_profit + (price - entry_price);
                        
                        <span class="hljs-comment">// Reset position</span>
                        in_position &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                    
                    state &lt;= UPDATE_METRICS;
                <span class="hljs-keyword">end</span>
                
                UPDATE_METRICS: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Update current equity</span>
                    current_equity &lt;= <span class="hljs-number">10000</span> + cumulative_profit;  <span class="hljs-comment">// Starting capital + profits</span>
                    
                    <span class="hljs-comment">// Update peak equity</span>
                    <span class="hljs-keyword">if</span> (current_equity &gt; peak_equity)
                        peak_equity &lt;= current_equity;
                    
                    <span class="hljs-comment">// Update drawdown</span>
                    <span class="hljs-keyword">if</span> (peak_equity &gt; current_equity &amp;&amp; 
                        (peak_equity - current_equity) &gt; max_drawdown)
                        max_drawdown &lt;= peak_equity - current_equity;
                    
                    state &lt;= CALCULATE;
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculate win rate</span>
                    <span class="hljs-keyword">if</span> (total_trades &gt; <span class="hljs-number">0</span>)
                        win_rate_pct &lt;= (winning_trades * <span class="hljs-number">100</span>) / total_trades;
                    
                    <span class="hljs-comment">// Calculate average win</span>
                    <span class="hljs-keyword">if</span> (winning_trades &gt; <span class="hljs-number">0</span>)
                        avg_win_pts &lt;= total_profit / winning_trades;
                    
                    <span class="hljs-comment">// Calculate average loss</span>
                    <span class="hljs-keyword">if</span> (losing_trades &gt; <span class="hljs-number">0</span>)
                        avg_loss_pts &lt;= total_loss / losing_trades;
                    
                    <span class="hljs-comment">// Calculate profit factor</span>
                    <span class="hljs-keyword">if</span> (total_loss &gt; <span class="hljs-number">0</span>)
                        profit_factor_pct &lt;= (total_profit * <span class="hljs-number">100</span>) / total_loss;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (total_profit &gt; <span class="hljs-number">0</span>)
                        profit_factor_pct &lt;= <span class="hljs-number">9999</span>;  <span class="hljs-comment">// Very large number for no losses</span>
                    
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: state &lt;= IDLE;
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key metrics features:</p>
<ul>
<li>Comprehensive trading statistics</li>
<li>Trade-by-trade tracking</li>
<li>Real-time performance calculation</li>
<li>Equity curve monitoring</li>
<li>Drawdown tracking</li>
</ul>
<p>This system enables:</p>
<ul>
<li>Strategy effectiveness evaluation</li>
<li>Performance optimization</li>
<li>Risk management monitoring</li>
<li>Comparative strategy analysis</li>
<li>Systematic trading system development</li>
</ul>
<p>Performance metrics provide essential feedback for strategy refinement and selection.</p>
<h3 id="hardware-optimizations">Hardware Optimizations</h3>
<h4 id="pipelining-techniques">Pipelining Techniques</h4>
<p>Pipelining enhances throughput and clock frequency:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> pipelined_ma_calculator #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Pipeline registers</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum_stage1 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum_stage2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] div_result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price_reg = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price_reg = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Pipeline control signals</span>
    <span class="hljs-keyword">reg</span> valid_stage1 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> valid_stage2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> valid_stage3 = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Pipeline stages</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset all pipeline registers</span>
            sum_stage1 &lt;= <span class="hljs-number">0</span>;
            sum_stage2 &lt;= <span class="hljs-number">0</span>;
            div_result &lt;= <span class="hljs-number">0</span>;
            new_price_reg &lt;= <span class="hljs-number">0</span>;
            oldest_price_reg &lt;= <span class="hljs-number">0</span>;
            
            valid_stage1 &lt;= <span class="hljs-number">0</span>;
            valid_stage2 &lt;= <span class="hljs-number">0</span>;
            valid_stage3 &lt;= <span class="hljs-number">0</span>;
            
            moving_avg &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Stage 1: Input registration and subtraction/addition preparation</span>
            new_price_reg &lt;= new_price;
            oldest_price_reg &lt;= oldest_price;
            valid_stage1 &lt;= start;
            
            <span class="hljs-comment">// Stage 2: Update running sum</span>
            <span class="hljs-keyword">if</span> (valid_stage1) <span class="hljs-keyword">begin</span>
                sum_stage2 &lt;= sum_stage1 + new_price_reg - oldest_price_reg;
                valid_stage2 &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                valid_stage2 &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-comment">// Stage 3: Division operation</span>
            <span class="hljs-keyword">if</span> (valid_stage2) <span class="hljs-keyword">begin</span>
                div_result &lt;= sum_stage2 / WINDOW;
                valid_stage3 &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                valid_stage3 &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-comment">// Output stage</span>
            <span class="hljs-keyword">if</span> (valid_stage3) <span class="hljs-keyword">begin</span>
                moving_avg &lt;= div_result;
                done &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key pipelining features:</p>
<ul>
<li>Multi-stage calculation process</li>
<li>Pipeline stage registers</li>
<li>Valid flags for data propagation</li>
<li>Sequential operation through stages</li>
<li>Overlapped execution</li>
</ul>
<p>This approach provides:</p>
<ul>
<li>Increased throughput (one result every cycle)</li>
<li>Higher achievable clock frequency</li>
<li>Better timing closure</li>
<li>Scalable performance</li>
<li>Predictable latency</li>
</ul>
<p>Pipelining enables efficient implementation of complex calculations with high throughput requirements.</p>
<h4 id="fixed-point-implementation">Fixed-Point Implementation</h4>
<p>Fixed-point arithmetic enhances precision while maintaining efficiency:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> fixed_point_rsi_calculator #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> FRAC_BITS = <span class="hljs-number">8</span>  <span class="hljs-comment">// Fractional bits for fixed-point</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Fixed-point constants</span>
    <span class="hljs-keyword">localparam</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] FIXED_ONE = <span class="hljs-number">1</span> &lt;&lt; FRAC_BITS;  <span class="hljs-comment">// 1.0 in fixed-point</span>
    <span class="hljs-keyword">localparam</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] FIXED_HUNDRED = <span class="hljs-number">100</span> &lt;&lt; FRAC_BITS;  <span class="hljs-comment">// 100.0 in fixed-point</span>
    
    <span class="hljs-comment">// Internal registers (fixed-point)</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] gain_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] loss_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] prev_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> initialized = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] sample_count = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// State machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, INIT = <span class="hljs-number">1</span>, ACCUMULATE = <span class="hljs-number">2</span>, CALCULATE = <span class="hljs-number">3</span>, COMPLETE = <span class="hljs-number">4</span>;
    
    <span class="hljs-comment">// Fixed-point calculation registers</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] rs_value;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] rsi_fixed;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            gain_sum &lt;= <span class="hljs-number">0</span>;
            loss_sum &lt;= <span class="hljs-number">0</span>;
            prev_price &lt;= <span class="hljs-number">0</span>;
            initialized &lt;= <span class="hljs-number">0</span>;
            sample_count &lt;= <span class="hljs-number">0</span>;
            rsi &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            state &lt;= IDLE;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (!initialized) <span class="hljs-keyword">begin</span>
                            state &lt;= INIT;
                        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                            state &lt;= ACCUMULATE;
                        <span class="hljs-keyword">end</span>
                        done &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                INIT: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Initialize with first price</span>
                    prev_price &lt;= price &lt;&lt; FRAC_BITS;  <span class="hljs-comment">// Convert to fixed-point</span>
                    initialized &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                ACCUMULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculate gain/loss with fixed-point precision</span>
                    <span class="hljs-keyword">if</span> ((price &lt;&lt; FRAC_BITS) &gt; prev_price) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Gain situation</span>
                        gain_sum &lt;= gain_sum + ((price &lt;&lt; FRAC_BITS) - prev_price);
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((price &lt;&lt; FRAC_BITS) &lt; prev_price) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Loss situation</span>
                        loss_sum &lt;= loss_sum + (prev_price - (price &lt;&lt; FRAC_BITS));
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-comment">// Update previous price</span>
                    prev_price &lt;= price &lt;&lt; FRAC_BITS;
                    
                    <span class="hljs-comment">// Update sample count</span>
                    <span class="hljs-keyword">if</span> (sample_count &lt; WINDOW)
                        sample_count &lt;= sample_count + <span class="hljs-number">1</span>;
                    
                    <span class="hljs-comment">// Move to calculation if enough samples</span>
                    <span class="hljs-keyword">if</span> (sample_count &gt;= WINDOW - <span class="hljs-number">1</span>)
                        state &lt;= CALCULATE;
                    <span class="hljs-keyword">else</span>
                        state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Fixed-point RSI calculation</span>
                    <span class="hljs-keyword">if</span> (loss_sum &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Calculate RS with fixed-point precision</span>
                        rs_value &lt;= (gain_sum * FIXED_ONE) / loss_sum;
                        
                        <span class="hljs-comment">// Calculate RSI = 100 - (100 / (1 + RS))</span>
                        rsi_fixed &lt;= FIXED_HUNDRED - 
                                    ((FIXED_HUNDRED * FIXED_ONE) / (FIXED_ONE + rs_value));
                        
                        <span class="hljs-comment">// Convert fixed-point to integer</span>
                        rsi &lt;= rsi_fixed &gt;&gt; FRAC_BITS;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gain_sum &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// All gains, no losses = RSI 100</span>
                        rsi &lt;= <span class="hljs-number">100</span>;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// No gains or losses = RSI 50</span>
                        rsi &lt;= <span class="hljs-number">50</span>;
                    <span class="hljs-keyword">end</span>
                    
                    state &lt;= COMPLETE;
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: state &lt;= IDLE;
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key fixed-point features:</p>
<ul>
<li>Configurable fractional precision</li>
<li>Consistent representation throughout calculation</li>
<li>Precise gain/loss tracking</li>
<li>Accurate division operations</li>
<li>Controlled conversion to integer output</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Higher calculation precision</li>
<li>Decimal fraction representation</li>
<li>More accurate technical indicators</li>
<li>Reduced cumulative error</li>
<li>Better handling of small price changes</li>
</ul>
<p>Fixed-point implementation enhances the accuracy of technical indicators while maintaining efficient FPGA implementation.</p>
<h4 id="custom-division-units">Custom Division Units</h4>
<p>Optimized division accelerates critical calculations:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> fast_division_unit #(
    <span class="hljs-keyword">parameter</span> DIVIDEND_WIDTH = <span class="hljs-number">32</span>,
    <span class="hljs-keyword">parameter</span> DIVISOR_WIDTH = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> FRACTIONAL_BITS = <span class="hljs-number">8</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DIVIDEND_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] dividend,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DIVISOR_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] divisor,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [DIVIDEND_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] quotient,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Division method selection parameters</span>
    <span class="hljs-keyword">parameter</span> METHOD = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0=Sequential, 1=CORDIC, 2=Newton-Raphson</span>
    
    <span class="hljs-comment">// Sequential division state</span>
    <span class="hljs-keyword">reg</span> [DIVIDEND_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] remainder;
    <span class="hljs-keyword">reg</span> [DIVIDEND_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] temp_quotient;
    <span class="hljs-keyword">reg</span> [DIVISOR_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] shifted_divisor;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] bit_index;
    
    <span class="hljs-comment">// State machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, SETUP = <span class="hljs-number">1</span>, DIVIDE = <span class="hljs-number">2</span>, SHIFT = <span class="hljs-number">3</span>, COMPLETE = <span class="hljs-number">4</span>;
    
    <span class="hljs-comment">// Method-specific registers</span>
    <span class="hljs-keyword">reg</span> [DIVIDEND_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] x_next;  <span class="hljs-comment">// For iterative methods</span>
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            quotient &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            state &lt;= IDLE;
            remainder &lt;= <span class="hljs-number">0</span>;
            temp_quotient &lt;= <span class="hljs-number">0</span>;
            bit_index &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (METHOD)
                <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Sequential division</span>
                    <span class="hljs-keyword">case</span> (state)
                        IDLE: <span class="hljs-keyword">begin</span>
                            <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                                state &lt;= SETUP;
                                done &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        SETUP: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Initialize division</span>
                            remainder &lt;= {DIVIDEND_WIDTH{<span class="hljs-number">1&#x27;b0</span>}};
                            temp_quotient &lt;= {DIVIDEND_WIDTH{<span class="hljs-number">1&#x27;b0</span>}};
                            bit_index &lt;= DIVIDEND_WIDTH - <span class="hljs-number">1</span>;
                            state &lt;= DIVIDE;
                        <span class="hljs-keyword">end</span>
                        
                        DIVIDE: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Shift in next bit from dividend</span>
                            remainder &lt;= {remainder[DIVIDEND_WIDTH-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>], dividend[bit_index]};
                            
                            <span class="hljs-comment">// Check if remainder &gt;= divisor</span>
                            <span class="hljs-keyword">if</span> ({remainder[DIVIDEND_WIDTH-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>], dividend[bit_index]} &gt;= 
                                {divisor, {DIVIDEND_WIDTH-DIVISOR_WIDTH{<span class="hljs-number">1&#x27;b0</span>}}}) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Subtraction and set quotient bit</span>
                                remainder &lt;= {remainder[DIVIDEND_WIDTH-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>], dividend[bit_index]} - 
                                            {divisor, {DIVIDEND_WIDTH-DIVISOR_WIDTH{<span class="hljs-number">1&#x27;b0</span>}}};
                                temp_quotient[bit_index] &lt;= <span class="hljs-number">1&#x27;b1</span>;
                            <span class="hljs-keyword">end</span>
                            
                            state &lt;= SHIFT;
                        <span class="hljs-keyword">end</span>
                        
                        SHIFT: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Check if all bits processed</span>
                            <span class="hljs-keyword">if</span> (bit_index == <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                                quotient &lt;= temp_quotient;
                                state &lt;= COMPLETE;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                bit_index &lt;= bit_index - <span class="hljs-number">1</span>;
                                state &lt;= DIVIDE;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        COMPLETE: <span class="hljs-keyword">begin</span>
                            done &lt;= <span class="hljs-number">1</span>;
                            state &lt;= IDLE;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: state &lt;= IDLE;
                    <span class="hljs-keyword">endcase</span>
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// CORDIC division approximation</span>
                    <span class="hljs-comment">// CORDIC implementation for division</span>
                    <span class="hljs-comment">// This is a simplified placeholder; a full implementation</span>
                    <span class="hljs-comment">// would include the complete CORDIC algorithm</span>
                    <span class="hljs-keyword">case</span> (state)
                        IDLE: <span class="hljs-keyword">begin</span>
                            <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                                state &lt;= SETUP;
                                done &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        SETUP: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Initialize CORDIC algorithm</span>
                            x_next &lt;= dividend &lt;&lt; FRACTIONAL_BITS;
                            bit_index &lt;= <span class="hljs-number">16</span>;  <span class="hljs-comment">// Number of iterations</span>
                            state &lt;= DIVIDE;
                        <span class="hljs-keyword">end</span>
                        
                        DIVIDE: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// CORDIC iteration (simplified)</span>
                            <span class="hljs-keyword">if</span> (bit_index &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Update approximation</span>
                                <span class="hljs-keyword">if</span> (divisor != <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                                    x_next &lt;= x_next - (x_next &gt;&gt; bit_index) + 
                                            ((divisor * x_next) &gt;&gt; (bit_index + FRACTIONAL_BITS));
                                <span class="hljs-keyword">end</span>
                                bit_index &lt;= bit_index - <span class="hljs-number">1</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                quotient &lt;= x_next;
                                state &lt;= COMPLETE;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        COMPLETE: <span class="hljs-keyword">begin</span>
                            done &lt;= <span class="hljs-number">1</span>;
                            state &lt;= IDLE;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: state &lt;= IDLE;
                    <span class="hljs-keyword">endcase</span>
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Newton-Raphson reciprocal approximation</span>
                    <span class="hljs-comment">// Newton-Raphson implementation for division</span>
                    <span class="hljs-comment">// This is a simplified placeholder; a full implementation</span>
                    <span class="hljs-comment">// would include the complete Newton-Raphson algorithm</span>
                    <span class="hljs-keyword">case</span> (state)
                        IDLE: <span class="hljs-keyword">begin</span>
                            <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                                state &lt;= SETUP;
                                done &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        SETUP: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Initialize Newton-Raphson approximation</span>
                            x_next &lt;= <span class="hljs-number">1</span> &lt;&lt; FRACTIONAL_BITS;  <span class="hljs-comment">// Initial guess = 1.0</span>
                            bit_index &lt;= <span class="hljs-number">4</span>;  <span class="hljs-comment">// Number of iterations</span>
                            state &lt;= DIVIDE;
                        <span class="hljs-keyword">end</span>
                        
                        DIVIDE: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Newton-Raphson iteration (simplified)</span>
                            <span class="hljs-keyword">if</span> (bit_index &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// x_next = x * (2 - D*x)</span>
                                <span class="hljs-comment">// Where x is approximation of 1/D</span>
                                <span class="hljs-keyword">if</span> (divisor != <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                                    x_next &lt;= (x_next * ((<span class="hljs-number">2</span> &lt;&lt; FRACTIONAL_BITS) - 
                                              ((divisor * x_next) &gt;&gt; FRACTIONAL_BITS))) &gt;&gt; FRACTIONAL_BITS;
                                <span class="hljs-keyword">end</span>
                                bit_index &lt;= bit_index - <span class="hljs-number">1</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Final result: dividend * (1/divisor)</span>
                                quotient &lt;= (dividend * x_next) &gt;&gt; FRACTIONAL_BITS;
                                state &lt;= COMPLETE;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        COMPLETE: <span class="hljs-keyword">begin</span>
                            done &lt;= <span class="hljs-number">1</span>;
                            state &lt;= IDLE;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: state &lt;= IDLE;
                    <span class="hljs-keyword">endcase</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key custom division features:</p>
<ul>
<li>Multiple division algorithm options</li>
<li>Configurable precision</li>
<li>Fractional result support</li>
<li>Optimized for FPGA implementation</li>
<li>Method selection based on requirements</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Accelerated division operations</li>
<li>Reduced critical path delay</li>
<li>Higher calculation throughput</li>
<li>Better resource utilization</li>
<li>Customized performance/accuracy tradeoffs</li>
</ul>
<p>Custom division units optimize a critical component of many technical indicators, improving overall system performance.</p>
<h4 id="multi-clock-domain-design">Multi-Clock Domain Design</h4>
<p>A multi-clock domain approach enhances performance and flexibility:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> multi_clock_trading_system (
    <span class="hljs-comment">// Fast clock domain</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> fast_clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> fast_rst,
    
    <span class="hljs-comment">// Slow clock domain</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> slow_clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> slow_rst,
    
    <span class="hljs-comment">// Market data input (slow domain)</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price,
    
    <span class="hljs-comment">// Calculation results (fast domain)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_value,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi_value,
    
    <span class="hljs-comment">// Trading signals (slow domain)</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> buy_signal,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> sell_signal
);
    <span class="hljs-comment">// Cross-domain synchronization signals</span>
    <span class="hljs-keyword">wire</span> price_valid_fast;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price_fast;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_slow;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi_slow;
    <span class="hljs-keyword">wire</span> calc_done_fast;
    <span class="hljs-keyword">wire</span> calc_done_slow;
    
    <span class="hljs-comment">// Fast clock domain: Calculations</span>
    <span class="hljs-comment">// ------------------------------</span>
    
    <span class="hljs-comment">// Synchronizers for data coming from slow domain</span>
    sync_fifo #(
        <span class="hljs-variable">.WIDTH</span>(<span class="hljs-number">17</span>),  <span class="hljs-comment">// price + valid</span>
        <span class="hljs-variable">.DEPTH</span>(<span class="hljs-number">4</span>)
    ) input_sync (
        <span class="hljs-variable">.wr_clk</span>(slow_clk),
        <span class="hljs-variable">.wr_rst</span>(slow_rst),
        <span class="hljs-variable">.wr_en</span>(new_data),
        <span class="hljs-variable">.wr_data</span>({<span class="hljs-number">1&#x27;b1</span>, price}),
        
        <span class="hljs-variable">.rd_clk</span>(fast_clk),
        <span class="hljs-variable">.rd_rst</span>(fast_rst),
        <span class="hljs-variable">.rd_data</span>({price_valid_fast, price_fast}),
        <span class="hljs-variable">.empty</span>()
    );
    
    <span class="hljs-comment">// Indicator calculations in fast domain</span>
    fast_ma_calculator fast_ma (
        <span class="hljs-variable">.clk</span>(fast_clk),
        <span class="hljs-variable">.rst</span>(fast_rst),
        <span class="hljs-variable">.new_data</span>(price_valid_fast),
        <span class="hljs-variable">.price</span>(price_fast),
        <span class="hljs-variable">.ma</span>(ma_value),
        <span class="hljs-variable">.done</span>(ma_done_fast)
    );
    
    fast_rsi_calculator fast_rsi (
        <span class="hljs-variable">.clk</span>(fast_clk),
        <span class="hljs-variable">.rst</span>(fast_rst),
        <span class="hljs-variable">.new_data</span>(price_valid_fast),
        <span class="hljs-variable">.price</span>(price_fast),
        <span class="hljs-variable">.rsi</span>(rsi_value),
        <span class="hljs-variable">.done</span>(rsi_done_fast)
    );
    
    <span class="hljs-comment">// Combined calculation status</span>
    <span class="hljs-keyword">assign</span> calc_done_fast = ma_done_fast &amp; rsi_done_fast;
    
    <span class="hljs-comment">// Slow clock domain: Decision making</span>
    <span class="hljs-comment">// ---------------------------------</span>
    
    <span class="hljs-comment">// Synchronizers for data coming from fast domain</span>
    sync_fifo #(
        <span class="hljs-variable">.WIDTH</span>(<span class="hljs-number">40</span>),  <span class="hljs-comment">// ma + rsi + done</span>
        <span class="hljs-variable">.DEPTH</span>(<span class="hljs-number">4</span>)
    ) output_sync (
        <span class="hljs-variable">.wr_clk</span>(fast_clk),
        <span class="hljs-variable">.wr_rst</span>(fast_rst),
        <span class="hljs-variable">.wr_en</span>(calc_done_fast),
        <span class="hljs-variable">.wr_data</span>({ma_value, rsi_value, calc_done_fast}),
        
        <span class="hljs-variable">.rd_clk</span>(slow_clk),
        <span class="hljs-variable">.rd_rst</span>(slow_rst),
        <span class="hljs-variable">.rd_data</span>({ma_slow, rsi_slow, calc_done_slow}),
        <span class="hljs-variable">.empty</span>()
    );
    
    <span class="hljs-comment">// Trading decision in slow domain</span>
    trading_decision slow_decision (
        <span class="hljs-variable">.clk</span>(slow_clk),
        <span class="hljs-variable">.rst</span>(slow_rst),
        <span class="hljs-variable">.price_now</span>(price),
        <span class="hljs-variable">.moving_avg</span>(ma_slow),
        <span class="hljs-variable">.rsi</span>(rsi_slow),
        <span class="hljs-variable">.buy</span>(buy_signal),
        <span class="hljs-variable">.sell</span>(sell_signal)
    );
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key multi-clock features:</p>
<ul>
<li>Dedicated fast clock for calculations</li>
<li>Slower clock for interface and decisions</li>
<li>Cross-domain synchronization</li>
<li>Domain-specific optimization</li>
<li>Clean separation of functions</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Higher performance for critical calculations</li>
<li>Efficient integration with slower interfaces</li>
<li>Optimized resource utilization</li>
<li>Function-appropriate timing</li>
<li>Improved system flexibility</li>
</ul>
<p>Multi-clock design offers significant performance advantages for calculation-intensive applications like technical analysis.</p>
<h4 id="resource-sharing-strategies">Resource Sharing Strategies</h4>
<p>Efficient resource sharing optimizes FPGA utilization:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> shared_resource_calculator #(
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> INDICATOR_COUNT = <span class="hljs-number">4</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Data input</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price,
    
    <span class="hljs-comment">// Configuration</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] indicator_select,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] window_size,
    
    <span class="hljs-comment">// Output</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] result,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done
);
    <span class="hljs-comment">// Shared arithmetic unit</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] accum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] div_result = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Shared memory resources</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price_history [<span class="hljs-number">0</span>:<span class="hljs-number">63</span>];  <span class="hljs-comment">// Shared price buffer</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] count = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Indicator-specific state</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] ma_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] gain_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] loss_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] prev_price = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Calculation state</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] calc_type = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] calc_period = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> calc_active = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Shared arithmetic unit state machine</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, STORE_PRICE = <span class="hljs-number">1</span>, INIT_CALC = <span class="hljs-number">2</span>, ACCUMULATE = <span class="hljs-number">3</span>, 
               DIVISION = <span class="hljs-number">4</span>, FINALIZE = <span class="hljs-number">5</span>, COMPLETE = <span class="hljs-number">6</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset all registers</span>
            accum &lt;= <span class="hljs-number">0</span>;
            div_result &lt;= <span class="hljs-number">0</span>;
            write_ptr &lt;= <span class="hljs-number">0</span>;
            read_ptr &lt;= <span class="hljs-number">0</span>;
            count &lt;= <span class="hljs-number">0</span>;
            ma_sum &lt;= <span class="hljs-number">0</span>;
            gain_sum &lt;= <span class="hljs-number">0</span>;
            loss_sum &lt;= <span class="hljs-number">0</span>;
            prev_price &lt;= <span class="hljs-number">0</span>;
            calc_type &lt;= <span class="hljs-number">0</span>;
            calc_period &lt;= <span class="hljs-number">0</span>;
            calc_active &lt;= <span class="hljs-number">0</span>;
            result &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            state &lt;= IDLE;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
                        state &lt;= STORE_PRICE;
                        done &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                STORE_PRICE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Store new price in circular buffer</span>
                    price_history[write_ptr] &lt;= price;
                    write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                    
                    <span class="hljs-comment">// Update count</span>
                    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">64</span>)
                        count &lt;= count + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">else</span>
                        read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                    
                    <span class="hljs-comment">// Check if we have enough data</span>
                    <span class="hljs-keyword">if</span> (count &gt;= window_size)
                        state &lt;= INIT_CALC;
                    <span class="hljs-keyword">else</span>
                        state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                INIT_CALC: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Setup calculation based on indicator_select</span>
                    calc_type &lt;= indicator_select;
                    calc_period &lt;= window_size;
                    calc_active &lt;= <span class="hljs-number">1</span>;
                    
                    <span class="hljs-comment">// Initialize calculation variables</span>
                    <span class="hljs-keyword">case</span> (indicator_select)
                        <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Moving Average</span>
                            accum &lt;= <span class="hljs-number">0</span>;
                            read_ptr &lt;= (write_ptr + <span class="hljs-number">64</span> - window_size) % <span class="hljs-number">64</span>;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// RSI</span>
                            gain_sum &lt;= <span class="hljs-number">0</span>;
                            loss_sum &lt;= <span class="hljs-number">0</span>;
                            prev_price &lt;= price_history[(write_ptr + <span class="hljs-number">63</span>) % <span class="hljs-number">64</span>];
                            read_ptr &lt;= (write_ptr + <span class="hljs-number">64</span> - window_size) % <span class="hljs-number">64</span>;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Exponential MA</span>
                            accum &lt;= price_history[(write_ptr + <span class="hljs-number">63</span>) % <span class="hljs-number">64</span>] &lt;&lt; <span class="hljs-number">8</span>;  <span class="hljs-comment">// Fixed-point</span>
                            read_ptr &lt;= (write_ptr + <span class="hljs-number">64</span> - window_size + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">3</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Standard Deviation</span>
                            accum &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">// First pass: calculate mean</span>
                            read_ptr &lt;= (write_ptr + <span class="hljs-number">64</span> - window_size) % <span class="hljs-number">64</span>;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>
                            state &lt;= IDLE;
                            calc_active &lt;= <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">endcase</span>
                    
                    <span class="hljs-keyword">if</span> (calc_active)
                        state &lt;= ACCUMULATE;
                <span class="hljs-keyword">end</span>
                
                ACCUMULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Perform accumulation based on indicator type</span>
                    <span class="hljs-keyword">case</span> (calc_type)
                        <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Moving Average</span>
                            <span class="hljs-comment">// Sum all prices in window</span>
                            <span class="hljs-keyword">if</span> (read_ptr != write_ptr) <span class="hljs-keyword">begin</span>
                                accum &lt;= accum + price_history[read_ptr];
                                read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                state &lt;= DIVISION;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// RSI</span>
                            <span class="hljs-comment">// Accumulate gains and losses</span>
                            <span class="hljs-keyword">if</span> (read_ptr != write_ptr) <span class="hljs-keyword">begin</span>
                                <span class="hljs-keyword">if</span> (price_history[read_ptr] &gt; prev_price)
                                    gain_sum &lt;= gain_sum + (price_history[read_ptr] - prev_price);
                                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price_history[read_ptr] &lt; prev_price)
                                    loss_sum &lt;= loss_sum + (prev_price - price_history[read_ptr]);
                                
                                prev_price &lt;= price_history[read_ptr];
                                read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                state &lt;= DIVISION;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Exponential MA</span>
                            <span class="hljs-comment">// EMA calculation with shared arithmetic</span>
                            <span class="hljs-keyword">if</span> (read_ptr != write_ptr) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// alpha = 2/(period+1)</span>
                                <span class="hljs-comment">// EMA = price * alpha + EMA * (1-alpha)</span>
                                <span class="hljs-comment">// Using fixed-point arithmetic (8 fractional bits)</span>
                                <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] alpha = (<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">8</span>) / (calc_period + <span class="hljs-number">1</span>);
                                accum &lt;= ((price_history[read_ptr] &lt;&lt; <span class="hljs-number">8</span>) * alpha + 
                                         accum * (<span class="hljs-number">256</span> - alpha)) &gt;&gt; <span class="hljs-number">8</span>;
                                
                                read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                state &lt;= FINALIZE;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">3</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Standard Deviation (first pass: mean)</span>
                            <span class="hljs-comment">// First accumulate for mean calculation</span>
                            <span class="hljs-keyword">if</span> (read_ptr != write_ptr) <span class="hljs-keyword">begin</span>
                                accum &lt;= accum + price_history[read_ptr];
                                read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                div_result &lt;= accum / calc_period;  <span class="hljs-comment">// Calculate mean</span>
                                accum &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">// Reset for variance calculation</span>
                                read_ptr &lt;= (write_ptr + <span class="hljs-number">64</span> - calc_period) % <span class="hljs-number">64</span>;
                                state &lt;= FINALIZE;  <span class="hljs-comment">// Go to second pass</span>
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: state &lt;= IDLE;
                    <span class="hljs-keyword">endcase</span>
                <span class="hljs-keyword">end</span>
                
                DIVISION: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Shared division operation</span>
                    <span class="hljs-keyword">case</span> (calc_type)
                        <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Moving Average</span>
                            div_result &lt;= accum / calc_period;
                            state &lt;= FINALIZE;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// RSI</span>
                            <span class="hljs-comment">// Calculate RSI = 100 * gain_sum / (gain_sum + loss_sum)</span>
                            <span class="hljs-keyword">if</span> (gain_sum + loss_sum &gt; <span class="hljs-number">0</span>)
                                div_result &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
                            <span class="hljs-keyword">else</span>
                                div_result &lt;= <span class="hljs-number">50</span>;  <span class="hljs-comment">// Default when no movement</span>
                            
                            state &lt;= FINALIZE;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: state &lt;= FINALIZE;
                    <span class="hljs-keyword">endcase</span>
                <span class="hljs-keyword">end</span>
                
                FINALIZE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Final result preparation</span>
                    <span class="hljs-keyword">case</span> (calc_type)
                        <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Moving Average</span>
                            result &lt;= div_result;
                            state &lt;= COMPLETE;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// RSI</span>
                            result &lt;= div_result;
                            state &lt;= COMPLETE;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Exponential MA</span>
                            result &lt;= accum &gt;&gt; <span class="hljs-number">8</span>;  <span class="hljs-comment">// Convert fixed-point to integer</span>
                            state &lt;= COMPLETE;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">3</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// Standard Deviation (second pass: variance)</span>
                            <span class="hljs-keyword">if</span> (read_ptr != write_ptr) <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Calculate sum of squared differences</span>
                                <span class="hljs-keyword">if</span> (price_history[read_ptr] &gt; div_result)
                                    accum &lt;= accum + (price_history[read_ptr] - div_result) * 
                                            (price_history[read_ptr] - div_result);
                                <span class="hljs-keyword">else</span>
                                    accum &lt;= accum + (div_result - price_history[read_ptr]) * 
                                            (div_result - price_history[read_ptr]);
                                
                                read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % <span class="hljs-number">64</span>;
                            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                                <span class="hljs-comment">// Calculate standard deviation (sqrt of variance)</span>
                                <span class="hljs-comment">// Simple integer square root approximation</span>
                                result &lt;= integer_sqrt(accum / calc_period);
                                state &lt;= COMPLETE;
                            <span class="hljs-keyword">end</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: state &lt;= COMPLETE;
                    <span class="hljs-keyword">endcase</span>
                <span class="hljs-keyword">end</span>
                
                COMPLETE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    calc_active &lt;= <span class="hljs-number">0</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: state &lt;= IDLE;
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Simple integer square root function</span>
    <span class="hljs-keyword">function</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] integer_sqrt;
        <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] num;
        <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] res;
        <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] <span class="hljs-keyword">bit</span>;
        <span class="hljs-keyword">begin</span>
            res = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">bit</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;
            
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">bit</span> &gt; num)
                <span class="hljs-keyword">bit</span> = <span class="hljs-keyword">bit</span> &gt;&gt; <span class="hljs-number">2</span>;
            
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">bit</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (num &gt;= res + <span class="hljs-keyword">bit</span>) <span class="hljs-keyword">begin</span>
                    num = num - (res + <span class="hljs-keyword">bit</span>);
                    res = (res &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-keyword">bit</span>;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    res = res &gt;&gt; <span class="hljs-number">1</span>;
                <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">bit</span> = <span class="hljs-keyword">bit</span> &gt;&gt; <span class="hljs-number">2</span>;
            <span class="hljs-keyword">end</span>
            
            integer_sqrt = res;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key resource sharing features:</p>
<ul>
<li>Common arithmetic unit</li>
<li>Shared price history buffer</li>
<li>Time-multiplexed calculation</li>
<li>Indicator-specific state preservation</li>
<li>Flexible configuration</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Reduced FPGA resource utilization</li>
<li>Support for multiple indicators</li>
<li>Configurable operation</li>
<li>Efficient implementation</li>
<li>Hardware scalability</li>
</ul>
<p>Resource sharing strategies optimize FPGA utilization while maintaining calculation capabilities.</p>
<h4 id="power-optimization-approaches">Power Optimization Approaches</h4>
<p>Power-efficient design enhances system reliability and efficiency:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> power_optimized_trading_system (
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    
    <span class="hljs-comment">// Market data input</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> new_data,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price,
    
    <span class="hljs-comment">// Power management</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> power_save_mode,
    
    <span class="hljs-comment">// Calculation results</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi,
    
    <span class="hljs-comment">// Trading signals</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> buy,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> sell,
    
    <span class="hljs-comment">// Status</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> active,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> power_status
);
    <span class="hljs-comment">// Clock gating</span>
    <span class="hljs-keyword">wire</span> calc_clk;
    <span class="hljs-keyword">reg</span> clk_enable;
    
    <span class="hljs-comment">// Enable clock only when needed</span>
    <span class="hljs-keyword">assign</span> calc_clk = clk &amp; clk_enable;
    
    <span class="hljs-comment">// Power domains</span>
    <span class="hljs-keyword">reg</span> calc_power_on = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">reg</span> decision_power_on = <span class="hljs-number">1</span>;
    
    <span class="hljs-comment">// Activity detection</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] last_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">19</span>:<span class="hljs-number">0</span>] inactive_counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> INACTIVE_THRESHOLD = <span class="hljs-number">20&#x27;hFFFFF</span>;  <span class="hljs-comment">// ~1 million cycles</span>
    
    <span class="hljs-comment">// Power management state</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] power_state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">localparam</span> FULL_POWER = <span class="hljs-number">0</span>, LOW_POWER = <span class="hljs-number">1</span>, ULTRA_LOW_POWER = <span class="hljs-number">2</span>;
    
    <span class="hljs-comment">// Trading system with power management</span>
    trading_system_with_power trading_core (
        <span class="hljs-variable">.clk</span>(calc_clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.price_in</span>(price),
        <span class="hljs-variable">.new_price</span>(new_data &amp; calc_power_on),
        <span class="hljs-variable">.moving_avg</span>(moving_avg),
        <span class="hljs-variable">.rsi</span>(rsi),
        <span class="hljs-variable">.buy</span>(buy),
        <span class="hljs-variable">.sell</span>(sell),
        <span class="hljs-variable">.calc_power_on</span>(calc_power_on),
        <span class="hljs-variable">.decision_power_on</span>(decision_power_on)
    );
    
    <span class="hljs-comment">// Activity monitoring</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            inactive_counter &lt;= <span class="hljs-number">0</span>;
            last_price &lt;= <span class="hljs-number">0</span>;
            active &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Activity detected</span>
            <span class="hljs-keyword">if</span> (price != last_price) <span class="hljs-keyword">begin</span>
                inactive_counter &lt;= <span class="hljs-number">0</span>;
                last_price &lt;= price;
                active &lt;= <span class="hljs-number">1</span>;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Same price, might be inactive</span>
                <span class="hljs-keyword">if</span> (inactive_counter &lt; INACTIVE_THRESHOLD)
                    inactive_counter &lt;= inactive_counter + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">else</span>
                    active &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// No new data</span>
            <span class="hljs-keyword">if</span> (inactive_counter &lt; INACTIVE_THRESHOLD)
                inactive_counter &lt;= inactive_counter + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span>
                active &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Power management</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            power_state &lt;= FULL_POWER;
            calc_power_on &lt;= <span class="hljs-number">1</span>;
            decision_power_on &lt;= <span class="hljs-number">1</span>;
            clk_enable &lt;= <span class="hljs-number">1</span>;
            power_status &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Update power state based on activity and mode</span>
            <span class="hljs-keyword">if</span> (power_save_mode) <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (!active &amp;&amp; inactive_counter &gt; INACTIVE_THRESHOLD) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Long inactivity - ultra low power</span>
                    power_state &lt;= ULTRA_LOW_POWER;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!active) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Short inactivity - low power</span>
                    power_state &lt;= LOW_POWER;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Active - full power</span>
                    power_state &lt;= FULL_POWER;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Power save mode disabled - always full power</span>
                power_state &lt;= FULL_POWER;
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-comment">// Apply power state</span>
            <span class="hljs-keyword">case</span> (power_state)
                FULL_POWER: <span class="hljs-keyword">begin</span>
                    calc_power_on &lt;= <span class="hljs-number">1</span>;
                    decision_power_on &lt;= <span class="hljs-number">1</span>;
                    clk_enable &lt;= <span class="hljs-number">1</span>;
                    power_status &lt;= <span class="hljs-number">1</span>;
                <span class="hljs-keyword">end</span>
                
                LOW_POWER: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Reduce calculation frequency</span>
                    clk_enable &lt;= !clk_enable;  <span class="hljs-comment">// 50% duty cycle</span>
                    calc_power_on &lt;= <span class="hljs-number">1</span>;
                    decision_power_on &lt;= <span class="hljs-number">1</span>;
                    power_status &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
                
                ULTRA_LOW_POWER: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Minimal power consumption</span>
                    calc_power_on &lt;= <span class="hljs-number">0</span>;  <span class="hljs-comment">// Turn off calculation unit</span>
                    clk_enable &lt;= new_data;  <span class="hljs-comment">// Clock only when new data</span>
                    decision_power_on &lt;= new_data;  <span class="hljs-comment">// Decision logic only when needed</span>
                    power_status &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
                
                <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>
                    calc_power_on &lt;= <span class="hljs-number">1</span>;
                    decision_power_on &lt;= <span class="hljs-number">1</span>;
                    clk_enable &lt;= <span class="hljs-number">1</span>;
                    power_status &lt;= <span class="hljs-number">1</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key power optimization features:</p>
<ul>
<li>Clock gating for inactive periods</li>
<li>Power domain management</li>
<li>Activity monitoring</li>
<li>Multiple power states</li>
<li>Adaptive clock frequency</li>
</ul>
<p>This approach enables:</p>
<ul>
<li>Reduced power consumption</li>
<li>Lower heat generation</li>
<li>Improved system reliability</li>
<li>Efficient battery operation</li>
<li>Environmental sustainability</li>
</ul>
<p>Power optimization is particularly valuable for deployed trading systems with continuous operation requirements.</p>
<h2 id="12-design-considerations-and-tradeoffs">12. Design Considerations and Tradeoffs</h2>
<h3 id="integer-vs-fixed-point-arithmetic">Integer vs. Fixed-Point Arithmetic</h3>
<h4 id="precision-analysis">Precision Analysis</h4>
<p>The choice between integer and fixed-point arithmetic involves precision tradeoffs:</p>
<p><strong>Integer Arithmetic (Current Implementation)</strong>:</p>
<ul>
<li>Uses whole-number representation throughout</li>
<li>Division truncates fractional results (rounds toward zero)</li>
<li>Precision limited to whole units</li>
<li>Simple implementation with minimal overhead</li>
<li>Adequate for many trading applications</li>
</ul>
<p><strong>Fixed-Point Arithmetic (Alternative)</strong>:</p>
<ul>
<li>Allocates bits for fractional representation</li>
<li>Typical format: 16.16 (16 integer bits, 16 fractional bits)</li>
<li>Maintains decimal precision through calculations</li>
<li>Requires scaling operations for arithmetic</li>
<li>More accurate for small price movements</li>
</ul>
<p><strong>Precision Requirements Analysis</strong>:</p>
<ol>
<li>
<p><strong>Moving Average Calculation</strong>:</p>
<ul>
<li>Integer division: <code>sum / WINDOW</code></li>
<li>For WINDOW = 20, resolution is 1/20 = 0.05 units</li>
<li>Error magnitude: up to 0.05 units per calculation</li>
<li>Cumulative error: potentially significant over time</li>
<li>Fixed-point alternative: <code>(sum &lt;&lt; 16) / WINDOW</code> with 16 fractional bits</li>
</ul>
</li>
<li>
<p><strong>RSI Calculation</strong>:</p>
<ul>
<li>Integer division: <code>(100 * gain_sum) / (gain_sum + loss_sum)</code></li>
<li>Resolution: minimum 1% RSI value</li>
<li>Meaningful for trading decisions (30/70 thresholds)</li>
<li>Critical near threshold boundaries</li>
<li>Fixed-point alternative: higher precision near boundaries</li>
</ul>
</li>
<li>
<p><strong>Technical Analysis Requirements</strong>:</p>
<ul>
<li>Precision needs depend on price magnitude and volatility</li>
<li>High-value instruments (e.g., BTC): integer sufficient</li>
<li>Low-value instruments: fixed-point preferred</li>
<li>Mean reversion strategies: higher precision beneficial</li>
<li>Trend-following strategies: integer often sufficient</li>
</ul>
</li>
</ol>
<p><strong>Recommendation</strong>:</p>
<ul>
<li>
<p>Integer arithmetic suitable for:</p>
<ul>
<li>High-value instruments</li>
<li>Strong trend identification</li>
<li>Simple trading strategies</li>
<li>Resource-constrained implementations</li>
</ul>
</li>
<li>
<p>Fixed-point arithmetic beneficial for:</p>
<ul>
<li>Low-value instruments</li>
<li>Precise reversal detection</li>
<li>Complex statistical indicators</li>
<li>When calculation accuracy is critical</li>
</ul>
</li>
</ul>
<p>The implementation provides a foundation for both approaches, with integer arithmetic as the default and fixed-point as an extension option.</p>
<h4 id="resource-impact-comparison">Resource Impact Comparison</h4>
<p>The resource utilization impact of integer vs. fixed-point implementations:</p>
<p><strong>Register Width Requirements</strong>:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Integer Width</th>
<th>Fixed-Point Width</th>
<th>Increase</th>
</tr>
</thead>
<tbody>
<tr>
<td>Price Data</td>
<td>16 bits</td>
<td>16.16 = 32 bits</td>
<td>100%</td>
</tr>
<tr>
<td>Sum Register</td>
<td>64 bits</td>
<td>64.16 = 80 bits</td>
<td>25%</td>
</tr>
<tr>
<td>MA Result</td>
<td>32 bits</td>
<td>32.16 = 48 bits</td>
<td>50%</td>
</tr>
<tr>
<td>RSI Accumulators</td>
<td>32 bits</td>
<td>32.16 = 48 bits</td>
<td>50%</td>
</tr>
<tr>
<td>Average Resource Increase</td>
<td></td>
<td></td>
<td>56%</td>
</tr>
</tbody>
</table>
<p><strong>Arithmetic Operation Complexity</strong>:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Integer Implementation</th>
<th>Fixed-Point Implementation</th>
<th>Impact</th>
</tr>
</thead>
<tbody>
<tr>
<td>Addition</td>
<td>Direct addition</td>
<td>Direct addition</td>
<td>No change</td>
</tr>
<tr>
<td>Subtraction</td>
<td>Direct subtraction</td>
<td>Direct subtraction</td>
<td>No change</td>
</tr>
<tr>
<td>Multiplication</td>
<td>Standard multiply</td>
<td>Multiply + shift</td>
<td>25% increase</td>
</tr>
<tr>
<td>Division</td>
<td>Standard divide</td>
<td>Scale, divide, shift</td>
<td>50% increase</td>
</tr>
<tr>
<td>Comparison</td>
<td>Direct comparison</td>
<td>Direct comparison</td>
<td>No change</td>
</tr>
<tr>
<td>Average Complexity Increase</td>
<td></td>
<td></td>
<td>15%</td>
</tr>
</tbody>
</table>
<p><strong>FPGA Resource Utilization</strong>:</p>
<table>
<thead>
<tr>
<th>Resource Type</th>
<th>Integer Impact</th>
<th>Fixed-Point Impact</th>
<th>Difference</th>
</tr>
</thead>
<tbody>
<tr>
<td>Registers</td>
<td>Base</td>
<td>~50% increase</td>
<td>Significant</td>
</tr>
<tr>
<td>LUTs</td>
<td>Base</td>
<td>~20% increase</td>
<td>Moderate</td>
</tr>
<tr>
<td>DSP Blocks</td>
<td>Base</td>
<td>~30% increase</td>
<td>Moderate</td>
</tr>
<tr>
<td>Memory</td>
<td>Base</td>
<td>~40% increase</td>
<td>Significant</td>
</tr>
<tr>
<td>Overall Resource Impact</td>
<td>Base</td>
<td>~35% increase</td>
<td>Moderate</td>
</tr>
</tbody>
</table>
<p><strong>Performance Characteristics</strong>:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Integer Approach</th>
<th>Fixed-Point Approach</th>
<th>Tradeoff</th>
</tr>
</thead>
<tbody>
<tr>
<td>Maximum Clock Frequency</td>
<td>Higher</td>
<td>Lower (~10-15%)</td>
<td>Performance</td>
</tr>
<tr>
<td>Calculation Latency</td>
<td>Lower</td>
<td>Higher (~20%)</td>
<td>Latency</td>
</tr>
<tr>
<td>Result Precision</td>
<td>Lower</td>
<td>Higher</td>
<td>Accuracy</td>
</tr>
<tr>
<td>Implementation Complexity</td>
<td>Lower</td>
<td>Higher</td>
<td>Development</td>
</tr>
</tbody>
</table>
<p><strong>Scaling Considerations</strong>:</p>
<ul>
<li>Integer implementation scales better with increased window size</li>
<li>Fixed-point implementation scales better with increased precision requirements</li>
<li>Multi-instrument systems: resource impact multiplied by instrument count</li>
<li>Pipeline architecture can mitigate performance impact of fixed-point</li>
</ul>
<p>These resource impact comparisons inform implementation decisions based on specific application requirements and available FPGA resources.</p>
<h4 id="implementation-complexity">Implementation Complexity</h4>
<p>The implementation complexity comparison between integer and fixed-point approaches:</p>
<p><strong>Integer Arithmetic Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average calculation</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
        sum &lt;= sum + new_price - oldest_price;
        moving_avg &lt;= sum / WINDOW;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Direct arithmetic operations</li>
<li>No scaling requirements</li>
<li>Simple division implementation</li>
<li>Straightforward design</li>
<li>Minimal signal management</li>
</ul>
<p><strong>Fixed-Point Arithmetic Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Fixed-point constants and types</span>
<span class="hljs-keyword">localparam</span> FRAC_BITS = <span class="hljs-number">16</span>;
<span class="hljs-keyword">localparam</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] FIXED_ONE = <span class="hljs-number">1</span> &lt;&lt; FRAC_BITS;

<span class="hljs-comment">// Moving Average calculation with fixed-point</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
        sum_fixed &lt;= sum_fixed + (new_price &lt;&lt; FRAC_BITS) - (oldest_price &lt;&lt; FRAC_BITS);
        sum_scaled &lt;= sum_fixed / WINDOW;
        moving_avg &lt;= {sum_scaled[<span class="hljs-number">47</span>:<span class="hljs-number">32</span>], sum_scaled[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>]};  <span class="hljs-comment">// Extract integer and fraction</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Additional scaling operations</li>
<li>Explicit fraction management</li>
<li>More complex signal paths</li>
<li>Increased register management</li>
<li>More involved debugging</li>
</ul>
<p><strong>Development Impact Factors</strong>:</p>
<ol>
<li>
<p><strong>Code Complexity</strong>:</p>
<ul>
<li>Integer: ~100 lines typical implementation</li>
<li>Fixed-Point: ~150 lines with fraction handling</li>
<li>Increased comment requirements for fixed-point</li>
<li>More complex function interfaces</li>
<li>Additional helper functions for fixed-point</li>
</ul>
</li>
<li>
<p><strong>Verification Complexity</strong>:</p>
<ul>
<li>Integer: Simple result checking</li>
<li>Fixed-Point: Precision verification required</li>
<li>More complex test vectors</li>
<li>Increased verification time</li>
<li>Additional edge case handling</li>
</ul>
</li>
<li>
<p><strong>Debugging Challenges</strong>:</p>
<ul>
<li>Integer: Direct value inspection</li>
<li>Fixed-Point: Format conversion for debugging</li>
<li>Additional visualization tools</li>
<li>More complex trace analysis</li>
<li>Increased simulation requirements</li>
</ul>
</li>
<li>
<p><strong>Maintenance Considerations</strong>:</p>
<ul>
<li>Integer: Straightforward updates</li>
<li>Fixed-Point: Format consistency required</li>
<li>Precision documentation needed</li>
<li>Format conversion management</li>
<li>Increased refactoring complexity</li>
</ul>
</li>
<li>
<p><strong>Integration Complexity</strong>:</p>
<ul>
<li>Integer: Direct connection to standard modules</li>
<li>Fixed-Point: Interface adapters often required</li>
<li>Format standardization across modules</li>
<li>Consistent scaling requirements</li>
<li>Format documentation for users</li>
</ul>
</li>
</ol>
<p>The complexity differences highlight the tradeoff between implementation simplicity and precision requirements. For many trading applications, the integer approach provides sufficient precision with minimal complexity, while fixed-point offers enhanced precision at the cost of increased implementation complexity.</p>
<h4 id="error-propagation-characteristics">Error Propagation Characteristics</h4>
<p>The error characteristics of integer and fixed-point implementations differ significantly:</p>
<p><strong>Integer Arithmetic Error Analysis</strong>:</p>
<ol>
<li>
<p><strong>Truncation Error</strong>:</p>
<ul>
<li>Division operation truncates fractions</li>
<li>Error up to 1 unit per division</li>
<li>Non-uniform distribution (biased toward negative)</li>
<li>Example: 103/20 = 5 (true value 5.15)</li>
<li>Error magnitude: 0.15 units (3% relative error)</li>
</ul>
</li>
<li>
<p><strong>Accumulation Error</strong>:</p>
<ul>
<li>Sliding window algorithm maintains running sum</li>
<li>Truncation errors can accumulate over time</li>
<li>Worst case: biased truncation in one direction</li>
<li>Example: 20 consecutive divisions with similar error</li>
<li>Potential cumulative error: several units</li>
</ul>
</li>
<li>
<p><strong>Error Significance</strong>:</p>
<ul>
<li>Relative error decreases with price magnitude</li>
<li>Critical for small price movements</li>
<li>Less significant for large price values</li>
<li>Can impact threshold crossing detection</li>
<li>May cause missed trading signals</li>
</ul>
</li>
</ol>
<p><strong>Fixed-Point Arithmetic Error Analysis</strong>:</p>
<ol>
<li>
<p><strong>Representation Error</strong>:</p>
<ul>
<li>Limited fractional bits (typically 8-16)</li>
<li>Minimum representable value: 2^(-FRAC_BITS)</li>
<li>For 16 fractional bits: ~1.5e-5 units</li>
<li>Bounded precision for irrational values</li>
<li>Significantly reduced truncation error</li>
</ul>
</li>
<li>
<p><strong>Rounding Strategies</strong>:</p>
<ul>
<li>Truncation: Fast but biased</li>
<li>Round to nearest: More accurate but complex</li>
<li>Fixed-point offers controlled rounding</li>
<li>Example: 103/20 with 16 fractional bits</li>
<li>Result: 5.15  1.5e-5 units</li>
</ul>
</li>
<li>
<p><strong>Error Propagation</strong>:</p>
<ul>
<li>Better bounded error accumulation</li>
<li>Controlled precision loss</li>
<li>Consistent error characteristics</li>
<li>Predictable error bounds</li>
<li>Reduced impact on threshold detection</li>
</ul>
</li>
</ol>
<p><strong>Comparative Error Example</strong>:</p>
<p>For calculating a 20-period moving average of prices fluctuating around 1000:</p>
<table>
<thead>
<tr>
<th>Price Pattern</th>
<th>True MA</th>
<th>Integer MA</th>
<th>Fixed-Point MA (16-bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Small oscillation (5)</td>
<td>1000.25</td>
<td>1000</td>
<td>1000.25</td>
</tr>
<tr>
<td>Critical threshold 1000.4</td>
<td>1000.4</td>
<td>1000</td>
<td>1000.40</td>
</tr>
<tr>
<td>RSI calculation gain/loss</td>
<td>0.15 ratio</td>
<td>0 ratio</td>
<td>0.15 ratio</td>
</tr>
<tr>
<td>Trading signal generated?</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>This example demonstrates how integer truncation can lose critical information for trading decisions, while fixed-point maintains the necessary precision.</p>
<p><strong>Error Mitigation Strategies</strong>:</p>
<ul>
<li>Integer: Conservative thresholds to account for errors</li>
<li>Fixed-point: Appropriate fractional bit allocation</li>
<li>Both: Periodic recalculation to reset accumulated errors</li>
<li>Both: Validation against floating-point reference</li>
<li>Both: Awareness of precision limitations in strategy design</li>
</ul>
<p>Understanding these error propagation characteristics is essential for developing reliable trading strategies, particularly for mean reversion approaches sensitive to small price movements.</p>
<h4 id="recommended-implementation-approaches">Recommended Implementation Approaches</h4>
<p>Based on the analysis of precision requirements, resource impact, implementation complexity, and error propagation, the following implementation approaches are recommended:</p>
<p><strong>For Standard Trading Applications</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Integer implementation with wider registers</span>
<span class="hljs-keyword">module</span> enhanced_integer_ma #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Wider accumulator for better precision</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Conservative division handling</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Update sum</span>
            sum &lt;= sum + new_price - oldest_price;
            
            <span class="hljs-comment">// Division with rounding</span>
            moving_avg &lt;= (sum + (WINDOW/<span class="hljs-number">2</span>)) / WINDOW;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<ul>
<li>Enhanced integer approach with rounding</li>
<li>Minimal resource overhead</li>
<li>Improved accuracy over basic integer</li>
<li>Simple implementation</li>
<li>Good balance of precision and complexity</li>
</ul>
<p><strong>For Precision-Critical Applications</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Fixed-point implementation with configurable precision</span>
<span class="hljs-keyword">module</span> fixed_point_ma #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> FRAC_BITS = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Fixed-point registers</span>
    <span class="hljs-keyword">reg</span> [DW+FRAC_BITS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Constants</span>
    <span class="hljs-keyword">localparam</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] FIXED_ONE = <span class="hljs-number">1</span> &lt;&lt; FRAC_BITS;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Update sum with scaled prices</span>
            sum &lt;= sum + (new_price &lt;&lt; FRAC_BITS) - (oldest_price &lt;&lt; FRAC_BITS);
            
            <span class="hljs-comment">// Division with proper scaling</span>
            moving_avg &lt;= sum / WINDOW;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<ul>
<li>Full fixed-point implementation</li>
<li>Configurable precision</li>
<li>Higher resource utilization</li>
<li>More complex implementation</li>
<li>Maximum accuracy for critical applications</li>
</ul>
<p><strong>Hybrid Approach for Resource Efficiency</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Hybrid approach with fixed-point for critical operations</span>
<span class="hljs-keyword">module</span> hybrid_ma_rsi #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Integer accumulator</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Fixed-point for critical calculations</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] rsi_gain_ratio;  <span class="hljs-comment">// 8.8 fixed-point</span>
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Integer MA calculation</span>
            sum &lt;= sum + new_price - oldest_price;
            moving_avg &lt;= sum / WINDOW;
            
            <span class="hljs-comment">// Fixed-point RSI calculation</span>
            <span class="hljs-keyword">if</span> (gain_sum &gt; <span class="hljs-number">0</span> || loss_sum &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// 8.8 fixed-point division for ratios</span>
                rsi_gain_ratio &lt;= (gain_sum &lt;&lt; <span class="hljs-number">8</span>) / (gain_sum + loss_sum);
                rsi &lt;= (rsi_gain_ratio * <span class="hljs-number">100</span>) &gt;&gt; <span class="hljs-number">8</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<ul>
<li>Integer for most calculations</li>
<li>Fixed-point for critical ratio calculations</li>
<li>Balanced resource utilization</li>
<li>Targeted precision where needed</li>
<li>Good compromise solution</li>
</ul>
<p><strong>Application-Specific Recommendations</strong>:</p>
<ol>
<li>
<p><strong>Trend-Following Strategies</strong>:</p>
<ul>
<li>Integer implementation often sufficient</li>
<li>Meaningful price movements typically exceed error margin</li>
<li>Resource-efficient implementation</li>
<li>Higher performance potential</li>
<li>Simplified development and verification</li>
</ul>
</li>
<li>
<p><strong>Mean-Reversion Strategies</strong>:</p>
<ul>
<li>Fixed-point recommended for precision</li>
<li>Critical threshold crossing detection</li>
<li>Accurate reversal identification</li>
<li>Worth the additional resource utilization</li>
<li>Essential for reliable signal generation</li>
</ul>
</li>
<li>
<p><strong>Multi-Instrument Systems</strong>:</p>
<ul>
<li>Consider hybrid approach</li>
<li>Fixed-point for low-value instruments</li>
<li>Integer for high-value instruments</li>
<li>Resource-optimized implementation</li>
<li>Balanced performance and precision</li>
</ul>
</li>
<li>
<p><strong>Low-Resource FPGAs</strong>:</p>
<ul>
<li>Enhanced integer with rounding</li>
<li>Wider accumulators for precision</li>
<li>Conservative threshold design</li>
<li>Efficient resource utilization</li>
<li>Acceptable performance-precision balance</li>
</ul>
</li>
</ol>
<p>These recommended approaches provide a range of implementation options based on specific application requirements, enabling an optimal balance between precision, resource utilization, and implementation complexity.</p>
<h4 id="migration-strategy">Migration Strategy</h4>
<p>For systems requiring migration from integer to fixed-point arithmetic:</p>
<p><strong>Step 1: Assessment and Planning</strong></p>
<ul>
<li>Evaluate precision requirements for each calculation</li>
<li>Identify critical calculations requiring higher precision</li>
<li>Determine appropriate fixed-point format (bit allocation)</li>
<li>Establish resource budget and constraints</li>
<li>Create migration roadmap with prioritized components</li>
</ul>
<p><strong>Step 2: Register Width Adjustment</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Original integer implementation</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Migrated fixed-point implementation</span>
<span class="hljs-comment">// Add fractional bits while maintaining integer capacity</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>+FRAC_BITS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sum_fixed = <span class="hljs-number">0</span>;
<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>+FRAC_BITS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] moving_avg_fixed = <span class="hljs-number">0</span>;
</div></code></pre>
<ul>
<li>Expand register widths to accommodate fractional bits</li>
<li>Maintain original integer capacity</li>
<li>Define clear fixed-point format constants</li>
<li>Document format in comments</li>
<li>Update all dependent signal widths</li>
</ul>
<p><strong>Step 3: Calculation Adaptation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Original integer calculation</span>
sum &lt;= sum + new_price - oldest_price;
moving_avg &lt;= sum / WINDOW;

<span class="hljs-comment">// Migrated fixed-point calculation</span>
sum_fixed &lt;= sum_fixed + (new_price &lt;&lt; FRAC_BITS) - (oldest_price &lt;&lt; FRAC_BITS);
moving_avg_fixed &lt;= sum_fixed / WINDOW;  <span class="hljs-comment">// Division preserves fractional bits</span>
</div></code></pre>
<ul>
<li>Convert integer operations to fixed-point</li>
<li>Add scaling operations where needed</li>
<li>Ensure consistent fixed-point format throughout</li>
<li>Update division handling for fractional preservation</li>
<li>Maintain calculation structure for clarity</li>
</ul>
<p><strong>Step 4: Interface Management</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Input interface adaptation</span>
<span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price_in;  <span class="hljs-comment">// Integer external interface</span>
<span class="hljs-keyword">wire</span> [DW+FRAC_BITS-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] price_fixed = price_in &lt;&lt; FRAC_BITS;  <span class="hljs-comment">// Convert to fixed-point</span>

<span class="hljs-comment">// Output interface adaptation</span>
<span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] moving_avg_out = moving_avg_fixed &gt;&gt; FRAC_BITS;  <span class="hljs-comment">// Convert to integer</span>
</div></code></pre>
<ul>
<li>Create adapter logic for external interfaces</li>
<li>Maintain backward compatibility where needed</li>
<li>Scale inputs to fixed-point format</li>
<li>Convert outputs back to required format</li>
<li>Document interface expectations clearly</li>
</ul>
<p><strong>Step 5: Hybrid Implementation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Hybrid approach during migration</span>
<span class="hljs-keyword">module</span> hybrid_calculation (
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Original integer signals</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] ma_sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ma_result = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// New fixed-point signals</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] rsi_gain_fixed = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 32.16 format</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">47</span>:<span class="hljs-number">0</span>] rsi_loss_fixed = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 32.16 format</span>
    
    <span class="hljs-comment">// Mixed calculation approach</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Keep MA calculation as integer</span>
        ma_sum &lt;= ma_sum + new_price - oldest_price;
        ma_result &lt;= ma_sum / WINDOW;
        
        <span class="hljs-comment">// Convert RSI calculation to fixed-point</span>
        <span class="hljs-keyword">if</span> (price &gt; prev_price) <span class="hljs-keyword">begin</span>
            rsi_gain_fixed &lt;= rsi_gain_fixed + ((price - prev_price) &lt;&lt; FRAC_BITS);
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; prev_price) <span class="hljs-keyword">begin</span>
            rsi_loss_fixed &lt;= rsi_loss_fixed + ((prev_price - price) &lt;&lt; FRAC_BITS);
        <span class="hljs-keyword">end</span>
        
        <span class="hljs-comment">// Fixed-point RSI calculation</span>
        <span class="hljs-keyword">if</span> (rsi_gain_fixed + rsi_loss_fixed &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
            rsi &lt;= ((<span class="hljs-number">100</span> &lt;&lt; FRAC_BITS) * rsi_gain_fixed) / 
                  (rsi_gain_fixed + rsi_loss_fixed);
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<ul>
<li>Convert critical calculations first</li>
<li>Maintain integer approach for non-critical elements</li>
<li>Create clear separation between approaches</li>
<li>Document conversion boundaries</li>
<li>Progressive migration path</li>
</ul>
<p><strong>Step 6: Verification Strategy</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Verification module example</span>
<span class="hljs-keyword">module</span> fixed_point_verification;
    <span class="hljs-comment">// Reference floating-point model</span>
    <span class="hljs-keyword">real</span> float_sum = <span class="hljs-number">0</span><span class="hljs-variable">.0</span>;
    <span class="hljs-keyword">real</span> float_ma = <span class="hljs-number">0</span><span class="hljs-variable">.0</span>;
    
    <span class="hljs-comment">// Test with identical inputs</span>
    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Apply test vectors to both implementations</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TEST_COUNT; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Update both models</span>
            apply_test_vector(i);
            
            <span class="hljs-comment">// Compare results</span>
            fixed_point_error = float_ma - (fixed_point_ma / <span class="hljs-number">2</span><span class="hljs-variable">.0</span>**FRAC_BITS);
            
            <span class="hljs-comment">// Report differences</span>
            <span class="hljs-keyword">if</span> (abs(fixed_point_error) &gt; ERROR_THRESHOLD) <span class="hljs-keyword">begin</span>
                <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Excessive error at test %d: %f&quot;</span>, i, fixed_point_error);
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<ul>
<li>Develop reference floating-point model</li>
<li>Apply identical test vectors to both implementations</li>
<li>Compare results with appropriate error tolerance</li>
<li>Verify critical threshold crossing behavior</li>
<li>Document precision improvements</li>
</ul>
<p><strong>Step 7: Incremental Deployment</strong></p>
<ol>
<li>Deploy fixed-point implementation in parallel with integer</li>
<li>Compare results in real operation</li>
<li>Switch to fixed-point for critical components first</li>
<li>Monitor system behavior and performance</li>
<li>Complete migration when verified</li>
</ol>
<p>This migration strategy enables a gradual transition from integer to fixed-point arithmetic, with manageable risk and resource impact at each stage. The hybrid approach allows for targeted precision improvement in critical calculations while maintaining system stability during migration.</p>
<h3 id="fifo-implementation-tradeoffs">FIFO Implementation Tradeoffs</h3>
<h4 id="shift-register-vs-circular-buffer">Shift Register vs. Circular Buffer</h4>
<p>The price memory module can be implemented using two primary approaches:</p>
<p><strong>Shift Register Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> shift_register_fifo #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Shift all data one position</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = DEPTH-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                data[i] &lt;= data[i-<span class="hljs-number">1</span>];
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-comment">// Insert new data at the beginning</span>
            data[<span class="hljs-number">0</span>] &lt;= new_data;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Oldest data</span>
<span class="hljs-keyword">module</span> shift_register_fifo #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Shift all data one position</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = DEPTH-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                data[i] &lt;= data[i-<span class="hljs-number">1</span>];
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-comment">// Insert new data at the beginning</span>
            data[<span class="hljs-number">0</span>] &lt;= new_data;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Oldest data always at the end</span>
    <span class="hljs-keyword">assign</span> oldest_data = data[DEPTH-<span class="hljs-number">1</span>];
    
    <span class="hljs-comment">// Full when enough writes have occurred</span>
    <span class="hljs-keyword">assign</span> full = (count == DEPTH);
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key characteristics:</p>
<ul>
<li>Physical movement of data through the array</li>
<li>Newest data at index 0, oldest at index DEPTH-1</li>
<li>Fixed access pattern for oldest/newest</li>
<li>O(n) complexity for data insertion</li>
<li>No pointer management required</li>
</ul>
<p><strong>Circular Buffer Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> circular_buffer_fifo #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] count = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Write to current position</span>
            data[write_ptr] &lt;= new_data;
            
            <span class="hljs-comment">// Update write pointer</span>
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            
            <span class="hljs-comment">// Update count and read pointer</span>
            <span class="hljs-keyword">if</span> (count &lt; DEPTH) <span class="hljs-keyword">begin</span>
                count &lt;= count + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Oldest data at read pointer</span>
    <span class="hljs-keyword">assign</span> oldest_data = data[read_ptr];
    
    <span class="hljs-comment">// Full when count reaches capacity</span>
    <span class="hljs-keyword">assign</span> full = (count == DEPTH);
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key characteristics:</p>
<ul>
<li>Data remains stationary in memory</li>
<li>Pointers move to track newest/oldest positions</li>
<li>Dynamic access pattern through pointers</li>
<li>O(1) complexity for data insertion</li>
<li>Requires pointer management</li>
</ul>
<p><strong>Comparison Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Shift Register</th>
<th>Circular Buffer</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Movement</td>
<td>Physical shift</td>
<td>Logical movement via pointers</td>
</tr>
<tr>
<td>Write Operation Complexity</td>
<td>O(n) - n shifts per write</td>
<td>O(1) - single write</td>
</tr>
<tr>
<td>Logic Utilization</td>
<td>Higher (shifting logic)</td>
<td>Lower (pointer update only)</td>
</tr>
<tr>
<td>Memory Access</td>
<td>Fixed pattern</td>
<td>Pointer-based</td>
</tr>
<tr>
<td>Scaling with Depth</td>
<td>Poor - complexity increases</td>
<td>Excellent - constant regardless of depth</td>
</tr>
<tr>
<td>Implementation Simplicity</td>
<td>Higher - no pointers</td>
<td>Lower - pointer management</td>
</tr>
<tr>
<td>Resource Efficiency</td>
<td>Lower</td>
<td>Higher</td>
</tr>
<tr>
<td>Timing Characteristics</td>
<td>Multiple register transfers</td>
<td>Single memory operation</td>
</tr>
</tbody>
</table>
<p>The current price memory implementation uses the circular buffer approach due to its superior efficiency, particularly for larger buffer depths typical in technical analysis applications.</p>
<h4 id="scaling-characteristics">Scaling Characteristics</h4>
<p>The scaling behavior of FIFO implementations is critical for supporting various window sizes:</p>
<p><strong>Shift Register Scaling</strong>:</p>
<ul>
<li>
<p><strong>Resource Scaling</strong>:</p>
<ul>
<li>Register usage scales linearly with depth: O(n)</li>
<li>Shifting logic complexity scales linearly: O(n)</li>
<li>Fan-out increases with depth</li>
<li>Timing path length increases with depth</li>
<li>Significant performance degradation at larger sizes</li>
</ul>
</li>
<li>
<p><strong>Performance Impact</strong>:</p>
<ul>
<li>Maximum clock frequency decreases with depth</li>
<li>Write operation latency increases linearly</li>
<li>Read access remains constant (fixed position)</li>
<li>Critical path through shifting logic</li>
<li>Practical limit around 16-32 elements</li>
</ul>
</li>
<li>
<p><strong>Depth Adaptation Example</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Changing depth requires adjusting the entire shift chain</span>
<span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">50</span>;  <span class="hljs-comment">// Significantly increased depth</span>

<span class="hljs-comment">// Implementation complexity increases proportionally</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = DEPTH-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
    data[i] &lt;= data[i-<span class="hljs-number">1</span>];  <span class="hljs-comment">// 49 shift operations per write</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
</li>
</ul>
<p><strong>Circular Buffer Scaling</strong>:</p>
<ul>
<li>
<p><strong>Resource Scaling</strong>:</p>
<ul>
<li>Register usage scales linearly with depth: O(n)</li>
<li>Control logic remains constant: O(1)</li>
<li>Pointer width scales logarithmically: O(log n)</li>
<li>Timing characteristics independent of depth</li>
<li>Consistent performance across size ranges</li>
</ul>
</li>
<li>
<p><strong>Performance Impact</strong>:</p>
<ul>
<li>Maximum clock frequency stable with depth</li>
<li>Write operation latency constant</li>
<li>Read access latency constant</li>
<li>Critical path through pointer arithmetic</li>
<li>Practical implementation for 1000+ elements</li>
</ul>
</li>
<li>
<p><strong>Depth Adaptation Example</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Changing depth only requires pointer width adjustment</span>
<span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">50</span>;  <span class="hljs-comment">// Significantly increased depth</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] write_ptr;  <span class="hljs-comment">// Only pointer width changes</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] read_ptr;   <span class="hljs-comment">// Only pointer width changes</span>

<span class="hljs-comment">// Implementation complexity remains constant</span>
write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;  <span class="hljs-comment">// Single operation regardless of depth</span>
</div></code></pre>
</li>
</ul>
<p><strong>Window Size Flexibility</strong>:</p>
<ul>
<li>
<p><strong>Shift Register Approach</strong>:</p>
<ul>
<li>Window size fixed at design time</li>
<li>Changing window requires re-synthesis</li>
<li>Performance decreases with larger windows</li>
<li>Resource utilization increases with window size</li>
<li>Not practical for runtime configuration</li>
</ul>
</li>
<li>
<p><strong>Circular Buffer Approach</strong>:</p>
<ul>
<li>Window size configurable within buffer capacity</li>
<li>Dynamic window adjustment possible</li>
<li>Performance consistent across window sizes</li>
<li>Resource utilization scales efficiently</li>
<li>Supports runtime configuration options</li>
</ul>
</li>
</ul>
<p>The circular buffer's superior scaling characteristics make it the preferred choice for technical indicators with varying window requirements, particularly for larger window sizes typical in financial analysis.</p>
<h4 id="memory-resource-utilization">Memory Resource Utilization</h4>
<p>The memory resource utilization differs significantly between FIFO implementation approaches:</p>
<p><strong>Shift Register Memory Usage</strong>:</p>
<ul>
<li>
<p><strong>Memory Implementation</strong>:</p>
<ul>
<li>Typically synthesized to register array</li>
<li>Each element requires a unique register</li>
<li>Routing complexity between registers</li>
<li>Difficult to map to block RAM</li>
<li>Distributed across FPGA fabric</li>
</ul>
</li>
<li>
<p><strong>FPGA Resource Types</strong>:</p>
<ul>
<li>Primary usage: Flip-flops</li>
<li>Secondary usage: Routing resources</li>
<li>LUT usage for shift control</li>
<li>Higher overall fabric utilization</li>
<li>Competes with computational resources</li>
</ul>
</li>
<li>
<p><strong>Utilization Metrics</strong> (20-element FIFO, 16-bit width):</p>
<ul>
<li>Register count: ~320 flip-flops</li>
<li>LUT count: ~100 for control</li>
<li>Routing resources: High</li>
<li>Block RAM: Not utilized</li>
<li>DSP blocks: Not utilized</li>
</ul>
</li>
</ul>
<p><strong>Circular Buffer Memory Usage</strong>:</p>
<ul>
<li>
<p><strong>Memory Implementation</strong>:</p>
<ul>
<li>Can be synthesized to register array or memory blocks</li>
<li>Sequential addressing pattern</li>
<li>Efficient mapping to block RAM</li>
<li>Consolidated memory structure</li>
<li>Optimized placement possible</li>
</ul>
</li>
<li>
<p><strong>FPGA Resource Types</strong>:</p>
<ul>
<li>Small buffers: Register arrays</li>
<li>Larger buffers: Block RAM resources</li>
<li>Minimal LUT usage for pointer control</li>
<li>Reduced routing complexity</li>
<li>Separated from computational resources</li>
</ul>
</li>
<li>
<p><strong>Utilization Metrics</strong> (20-element FIFO, 16-bit width):</p>
<ul>
<li>Register count: 320 for data + ~20 for control</li>
<li>LUT count: ~30 for pointer management</li>
<li>Routing resources: Low to moderate</li>
<li>Block RAM: Potential utilization for larger sizes</li>
<li>DSP blocks: Not utilized</li>
</ul>
</li>
</ul>
<p><strong>FPGA-Specific Optimizations</strong>:</p>
<ul>
<li>
<p><strong>Small Buffer Implementations</strong>:</p>
<ul>
<li>Both approaches use similar register resources</li>
<li>Shift register may use SRL16E/SRL32E primitives</li>
<li>Circular buffer uses standard registers</li>
<li>Specialized shift register primitives available</li>
<li>Size-dependent optimization opportunities</li>
</ul>
</li>
<li>
<p><strong>Large Buffer Implementations</strong>:</p>
<ul>
<li>Shift register poorly suited for large sizes</li>
<li>Circular buffer efficiently maps to block RAM</li>
<li>Memory inference patterns recognized by tools</li>
<li>Significant resource advantage for circular buffer</li>
<li>Critical for larger indicator windows (50+ elements)</li>
</ul>
</li>
<li>
<p><strong>Tool-Based Optimization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Synthesis attributes for memory inference</span>
(* ram_style = <span class="hljs-string">&quot;block&quot;</span> *) <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];

<span class="hljs-comment">// Or for distributed memory</span>
(* ram_style = <span class="hljs-string">&quot;distributed&quot;</span> *) <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];
</div></code></pre>
<ul>
<li>Explicit memory type control</li>
<li>Optimization guidance for tools</li>
<li>Resource allocation control</li>
<li>Performance tuning capability</li>
<li>Implementation flexibility</li>
</ul>
</li>
</ul>
<p>The circular buffer approach generally offers more efficient memory resource utilization, particularly for larger buffer sizes, and provides better mapping to dedicated FPGA memory resources like block RAM.</p>
<h4 id="access-pattern-efficiency">Access Pattern Efficiency</h4>
<p>The efficiency of memory access patterns significantly impacts overall system performance:</p>
<p><strong>Shift Register Access Patterns</strong>:</p>
<ul>
<li>
<p><strong>Write Access</strong>:</p>
<ul>
<li>Cascaded shifts through entire array</li>
<li>Multiple register transfers per write</li>
<li>Write to fixed position (index 0)</li>
<li>Distributed operation across array</li>
<li>Significant routing resources</li>
</ul>
</li>
<li>
<p><strong>Read Access</strong>:</p>
<ul>
<li>Fixed position access (index DEPTH-1)</li>
<li>Direct connection to output</li>
<li>Zero access latency</li>
<li>Consistent timing</li>
<li>Simple routing path</li>
</ul>
</li>
<li>
<p><strong>Access Timing</strong>:</p>
<pre class="hljs"><code><div>Write operation timing (cascaded):
data[0] &lt;= new_data;           // Cycle 1
data[1] &lt;= data[0];            // Cycle 1
data[2] &lt;= data[1];            // Cycle 1
...
data[DEPTH-1] &lt;= data[DEPTH-2]; // Cycle 1
</div></code></pre>
<ul>
<li>Single cycle for complete shift</li>
<li>Parallel register transfers</li>
<li>Dependent on register-to-register paths</li>
<li>Critical path through entire chain</li>
<li>Clock frequency limited by shift path</li>
</ul>
</li>
</ul>
<p><strong>Circular Buffer Access Patterns</strong>:</p>
<ul>
<li>
<p><strong>Write Access</strong>:</p>
<ul>
<li>Single memory write to pointer location</li>
<li>Independent of buffer content</li>
<li>Write to dynamic position (write_ptr)</li>
<li>Localized operation</li>
<li>Efficient routing</li>
</ul>
</li>
<li>
<p><strong>Read Access</strong>:</p>
<ul>
<li>Indexed access to dynamic position (read_ptr)</li>
<li>Multiplexed output path</li>
<li>Memory read operation</li>
<li>Potential for higher latency</li>
<li>More complex routing</li>
</ul>
</li>
<li>
<p><strong>Access Timing</strong>:</p>
<pre class="hljs"><code><div>Write operation timing (direct):
data[write_ptr] &lt;= new_data;     // Cycle 1
write_ptr &lt;= (write_ptr + 1) % DEPTH; // Cycle 1
</div></code></pre>
<ul>
<li>Single cycle for complete write</li>
<li>Single memory operation</li>
<li>Independent of buffer size</li>
<li>Critical path through address calculation</li>
<li>Stable clock frequency with size</li>
</ul>
</li>
</ul>
<p><strong>Performance Impact Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Access Aspect</th>
<th>Shift Register</th>
<th>Circular Buffer</th>
</tr>
</thead>
<tbody>
<tr>
<td>Write Operation</td>
<td>Multiple transfers</td>
<td>Single memory write</td>
</tr>
<tr>
<td>Critical Path</td>
<td>Through entire shift chain</td>
<td>Through pointer arithmetic</td>
</tr>
<tr>
<td>Size Scaling</td>
<td>Performance degrades</td>
<td>Performance stable</td>
</tr>
<tr>
<td>Clock Frequency</td>
<td>Decreases with size</td>
<td>Stable with size</td>
</tr>
<tr>
<td>Routing Complexity</td>
<td>High, distributed</td>
<td>Moderate, localized</td>
</tr>
<tr>
<td>Concurrent Access</td>
<td>Limited by shift operations</td>
<td>Concurrent read/write possible</td>
</tr>
<tr>
<td>Memory Technology</td>
<td>Limited to registers</td>
<td>Compatible with block RAM</td>
</tr>
</tbody>
</table>
<p><strong>Real-World Access Scenarios</strong>:</p>
<ul>
<li>
<p><strong>Sequential Updates (Technical Analysis)</strong>:</p>
<ul>
<li>New price arrives every market tick</li>
<li>Regular update pattern</li>
<li>Predictable access timing</li>
<li>Circular buffer significantly more efficient</li>
<li>Advantage increases with window size</li>
</ul>
</li>
<li>
<p><strong>Random Access Requirements</strong>:</p>
<ul>
<li>Circular buffer provides indexed access capability</li>
<li>Shift register limited to ends of chain</li>
<li>Additional index tracking possible with circular buffer</li>
<li>More flexible data access patterns</li>
<li>Better support for complex algorithms</li>
</ul>
</li>
</ul>
<p>The circular buffer implementation offers superior access pattern efficiency, particularly for the sequential update patterns typical in technical analysis applications, with significant performance advantages for larger window sizes.</p>
<h4 id="implementation-complexity-comparison">Implementation Complexity Comparison</h4>
<p>The implementation complexity differs between the two FIFO approaches:</p>
<p><strong>Shift Register Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> shift_register_fifo #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> wr_en,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_data,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_data,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> full,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count
);
    <span class="hljs-comment">// Data storage</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_count = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset logic</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; DEPTH; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                data[i] &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
            write_count &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Shift all data one position</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = DEPTH-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                data[i] &lt;= data[i-<span class="hljs-number">1</span>];
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-comment">// Insert new data</span>
            data[<span class="hljs-number">0</span>] &lt;= new_data;
            
            <span class="hljs-comment">// Update count</span>
            <span class="hljs-keyword">if</span> (write_count &lt; DEPTH)
                write_count &lt;= write_count + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Output connections</span>
    <span class="hljs-keyword">assign</span> oldest_data = data[DEPTH-<span class="hljs-number">1</span>];
    <span class="hljs-keyword">assign</span> full = (write_count == DEPTH);
    <span class="hljs-keyword">assign</span> count = write_count;
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p><strong>Circular Buffer Implementation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> circular_buffer_fifo #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> clk,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> rst,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> wr_en,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_data,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_data,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> full,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count
);
    <span class="hljs-comment">// Data storage</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] data [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] item_count = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset logic</span>
            write_ptr &lt;= <span class="hljs-number">0</span>;
            read_ptr &lt;= <span class="hljs-number">0</span>;
            item_count &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Store new data</span>
            data[write_ptr] &lt;= new_data;
            
            <span class="hljs-comment">// Update pointers and count</span>
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % DEPTH;
            
            <span class="hljs-keyword">if</span> (item_count &lt; DEPTH) <span class="hljs-keyword">begin</span>
                item_count &lt;= item_count + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % DEPTH;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Output connections</span>
    <span class="hljs-keyword">assign</span> oldest_data = data[read_ptr];
    <span class="hljs-keyword">assign</span> full = (item_count == DEPTH);
    <span class="hljs-keyword">assign</span> count = item_count;
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p><strong>Complexity Comparison</strong>:</p>
<table>
<thead>
<tr>
<th>Complexity Aspect</th>
<th>Shift Register</th>
<th>Circular Buffer</th>
</tr>
</thead>
<tbody>
<tr>
<td>Line Count</td>
<td>~30 lines</td>
<td>~40 lines</td>
</tr>
<tr>
<td>State Variables</td>
<td>1 counter</td>
<td>3 counters/pointers</td>
</tr>
<tr>
<td>Logic Complexity</td>
<td>Simple shift</td>
<td>Pointer arithmetic</td>
</tr>
<tr>
<td>Reset Logic</td>
<td>Array initialization</td>
<td>Pointer resets</td>
</tr>
<tr>
<td>Conceptual Model</td>
<td>Physical movement</td>
<td>Logical movement</td>
</tr>
<tr>
<td>Debugging Ease</td>
<td>Visually traceable</td>
<td>Pointer tracking needed</td>
</tr>
<tr>
<td>Reasoning Complexity</td>
<td>Lower</td>
<td>Higher</td>
</tr>
<tr>
<td>Error Susceptibility</td>
<td>Lower</td>
<td>Higher (pointer bugs)</td>
</tr>
<tr>
<td>Implementation Effort</td>
<td>Lower</td>
<td>Moderate</td>
</tr>
</tbody>
</table>
<p><strong>Common Implementation Challenges</strong>:</p>
<ol>
<li>
<p><strong>Shift Register Challenges</strong>:</p>
<ul>
<li>Loop unrolling in synthesis</li>
<li>Efficient register chaining</li>
<li>Reset behavior with large arrays</li>
<li>Tool-specific optimization</li>
<li>Performance with large depths</li>
</ul>
</li>
<li>
<p><strong>Circular Buffer Challenges</strong>:</p>
<ul>
<li>Pointer wraparound logic</li>
<li>Empty/full condition detection</li>
<li>Read/write pointer synchronization</li>
<li>Modulo arithmetic implementation</li>
<li>Reset state consistency</li>
</ul>
</li>
</ol>
<p><strong>Development Considerations</strong>:</p>
<ul>
<li>
<p><strong>Code Maintainability</strong>:</p>
<ul>
<li>Shift register: Simpler concept, easier to understand</li>
<li>Circular buffer: More complex, requires careful documentation</li>
<li>Shift register: Fewer state variables to track</li>
<li>Circular buffer: More error-prone pointer management</li>
<li>Trade-off between simplicity and efficiency</li>
</ul>
</li>
<li>
<p><strong>Verification Effort</strong>:</p>
<ul>
<li>Shift register: Fewer corner cases</li>
<li>Circular buffer: More pointer conditions to verify</li>
<li>Shift register: Easier visual inspection</li>
<li>Circular buffer: Requires more thorough testing</li>
<li>Both benefit from formal verification</li>
</ul>
</li>
</ul>
<p>The shift register offers implementation simplicity advantages at the cost of performance and scalability, while the circular buffer provides superior performance and resource efficiency with increased implementation complexity.</p>
<h4 id="selection-guidelines">Selection Guidelines</h4>
<p>To select the appropriate FIFO implementation for a specific application, consider the following guidelines:</p>
<p><strong>Use Shift Register When</strong>:</p>
<ul>
<li>Buffer depth is small (16 elements)</li>
<li>Implementation simplicity is prioritized</li>
<li>Performance is not critical</li>
<li>Resource efficiency is secondary</li>
<li>Window size is fixed and small</li>
<li>Debugging visibility is important</li>
<li>Development time is limited</li>
</ul>
<p><strong>Use Circular Buffer When</strong>:</p>
<ul>
<li>Buffer depth is moderate to large (&gt;16 elements)</li>
<li>Performance is a priority</li>
<li>Resource efficiency is important</li>
<li>Window size may vary or is large</li>
<li>Scaling to larger sizes may be required</li>
<li>Block RAM utilization is desired</li>
<li>Implementation complexity is acceptable</li>
</ul>
<p><strong>Application-Specific Selection Matrix</strong>:</p>
<table>
<thead>
<tr>
<th>Application Characteristic</th>
<th>Recommended Approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>Small MA window (5-10)</td>
<td>Shift Register</td>
</tr>
<tr>
<td>Large MA window (50+)</td>
<td>Circular Buffer</td>
</tr>
<tr>
<td>RSI calculation (14+)</td>
<td>Circular Buffer</td>
</tr>
<tr>
<td>Multiple indicators</td>
<td>Circular Buffer</td>
</tr>
<tr>
<td>Resource-constrained FPGA</td>
<td>Circular Buffer</td>
</tr>
<tr>
<td>Simple prototype</td>
<td>Shift Register</td>
</tr>
<tr>
<td>Variable window experimentation</td>
<td>Circular Buffer</td>
</tr>
<tr>
<td>High-frequency trading</td>
<td>Circular Buffer</td>
</tr>
<tr>
<td>Educational implementation</td>
<td>Shift Register</td>
</tr>
<tr>
<td>Production system</td>
<td>Circular Buffer</td>
</tr>
</tbody>
</table>
<p><strong>Hybrid Approaches</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> hybrid_fifo #(
    <span class="hljs-keyword">parameter</span> DEPTH = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Small shift register for newest data (fast access)</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] newest_data [<span class="hljs-number">0</span>:<span class="hljs-number">3</span>];
    
    <span class="hljs-comment">// Circular buffer for older data (efficient storage)</span>
    <span class="hljs-keyword">reg</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] older_data [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">5</span>];
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] write_ptr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] read_ptr = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Combined approach</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (wr_en) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Shift newest data</span>
            newest_data[<span class="hljs-number">3</span>] &lt;= newest_data[<span class="hljs-number">2</span>];
            newest_data[<span class="hljs-number">2</span>] &lt;= newest_data[<span class="hljs-number">1</span>];
            newest_data[<span class="hljs-number">1</span>] &lt;= newest_data[<span class="hljs-number">0</span>];
            newest_data[<span class="hljs-number">0</span>] &lt;= new_data;
            
            <span class="hljs-comment">// Write oldest of newest to circular buffer</span>
            older_data[write_ptr] &lt;= newest_data[<span class="hljs-number">3</span>];
            write_ptr &lt;= (write_ptr + <span class="hljs-number">1</span>) % (DEPTH-<span class="hljs-number">4</span>);
            
            <span class="hljs-comment">// Update read pointer when full</span>
            <span class="hljs-keyword">if</span> (count &gt;= DEPTH)
                read_ptr &lt;= (read_ptr + <span class="hljs-number">1</span>) % (DEPTH-<span class="hljs-number">4</span>);
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Output oldest data</span>
    <span class="hljs-keyword">assign</span> oldest_data = older_data[read_ptr];
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This hybrid approach combines the simplicity of a small shift register for newest data with the efficiency of a circular buffer for the majority of the history, providing optimized access patterns for both newest and oldest data.</p>
<p><strong>Migration Considerations</strong>:</p>
<ul>
<li>Start with simplest appropriate implementation</li>
<li>Profile performance and resource utilization</li>
<li>Identify bottlenecks and constraints</li>
<li>Consider hybrid approaches for specific access patterns</li>
<li>Refactor to more efficient implementation if needed</li>
<li>Maintain clear interface compatibility</li>
<li>Document implementation details</li>
</ul>
<p>The price memory module in the current technical analysis system uses the circular buffer approach due to its superior performance, efficiency, and scalability characteristics, which are essential for financial applications with potentially large window sizes and performance requirements.</p>
<h3 id="calculation-timing-tradeoffs">Calculation Timing Tradeoffs</h3>
<h4 id="deterministic-vs-variable-latency">Deterministic vs. Variable Latency</h4>
<p>The technical analysis system faces tradeoffs between deterministic and variable calculation timing:</p>
<p><strong>Deterministic Latency Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Moving Average with fixed cycle count</span>
<span class="hljs-keyword">module</span> fixed_latency_ma #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// State machine with fixed cycle count</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, CALC = <span class="hljs-number">1</span>, DONE = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state = IDLE;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] cycle_count = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                    state &lt;= CALC;
                    cycle_count &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-comment">// Initialize calculation</span>
                    sum &lt;= sum + new_price - oldest_price;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            CALC: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Always take exactly 4 cycles for consistency</span>
                <span class="hljs-keyword">if</span> (cycle_count &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
                    cycle_count &lt;= cycle_count + <span class="hljs-number">1</span>;
                    <span class="hljs-comment">// Calculation complete in first cycle, just wait</span>
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    state &lt;= DONE;
                    moving_avg &lt;= sum / WINDOW;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            DONE: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">1</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key characteristics:</p>
<ul>
<li>Fixed number of clock cycles regardless of data</li>
<li>Predictable completion timing</li>
<li>Consistent latency for all calculations</li>
<li>Simplified system synchronization</li>
<li>Potentially wasted cycles</li>
</ul>
<p><strong>Variable Latency Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// RSI with data-dependent cycle count</span>
<span class="hljs-keyword">module</span> variable_latency_rsi #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// State machine with variable progression</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, ACCUMULATE = <span class="hljs-number">1</span>, DIVIDE = <span class="hljs-number">2</span>, DONE = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (start)
                    state &lt;= ACCUMULATE;
            <span class="hljs-keyword">end</span>
            
            ACCUMULATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Process until all data examined</span>
                <span class="hljs-keyword">if</span> (sample_count &lt; WINDOW) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Process next sample</span>
                    sample_count &lt;= sample_count + <span class="hljs-number">1</span>;
                    <span class="hljs-comment">// Update gain/loss accumulators</span>
                    <span class="hljs-comment">// ...</span>
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    state &lt;= DIVIDE;
                }
            <span class="hljs-keyword">end</span>
            
            DIVIDE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Perform division operation</span>
                <span class="hljs-keyword">if</span> (loss_sum &gt; <span class="hljs-number">0</span>)
                    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
                <span class="hljs-keyword">else</span>
                    rsi &lt;= <span class="hljs-number">100</span>;  <span class="hljs-comment">// All gains</span>
                
                state &lt;= DONE;
            <span class="hljs-keyword">end</span>
            
            DONE: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">1</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key characteristics:</p>
<ul>
<li>Variable cycle count based on data conditions</li>
<li>Optimized execution time</li>
<li>Efficient resource utilization</li>
<li>More complex system synchronization</li>
<li>Data-dependent completion timing</li>
</ul>
<p><strong>Timing Analysis Comparison</strong>:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Deterministic Latency</th>
<th>Variable Latency</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cycle Count</td>
<td>Fixed (4 cycles example)</td>
<td>Data-dependent (1-20+ cycles)</td>
</tr>
<tr>
<td>Completion Timing</td>
<td>Predictable</td>
<td>Varies with data</td>
</tr>
<tr>
<td>Resource Efficiency</td>
<td>Lower (may waste cycles)</td>
<td>Higher (optimized execution)</td>
</tr>
<tr>
<td>System Integration</td>
<td>Simpler</td>
<td>More complex</td>
</tr>
<tr>
<td>Performance</td>
<td>Consistent but potentially slower</td>
<td>Optimized but variable</td>
</tr>
<tr>
<td>Implementation Complexity</td>
<td>Lower</td>
<td>Higher</td>
</tr>
</tbody>
</table>
<p><strong>System Integration Implications</strong>:</p>
<ul>
<li>
<p><strong>Deterministic Approach</strong>:</p>
<ul>
<li>Simplifies downstream component timing</li>
<li>Enables fixed pipeline stage design</li>
<li>Consistent system throughput</li>
<li>Predictable system behavior</li>
<li>Easier verification and validation</li>
</ul>
</li>
<li>
<p><strong>Variable Approach</strong>:</p>
<ul>
<li>Requires handshaking protocols</li>
<li>Needs completion signaling</li>
<li>May create timing bubbles in pipeline</li>
<li>More complex verification</li>
<li>Potentially higher overall throughput</li>
</ul>
</li>
</ul>
<p>The technical analysis system balances these approaches by implementing predominantly deterministic calculations with clear completion signaling, ensuring reliable operation while maintaining reasonable performance.</p>
<h4 id="resource-implications">Resource Implications</h4>
<p>The choice between deterministic and variable latency approaches has significant resource implications:</p>
<p><strong>Deterministic Timing Resources</strong>:</p>
<ul>
<li>
<p><strong>State Machine Complexity</strong>:</p>
<ul>
<li>Simpler structure with fixed states</li>
<li>Predetermined state transitions</li>
<li>Fixed cycle counters</li>
<li>Minimal conditional logic</li>
<li>Smaller state encoding</li>
</ul>
</li>
<li>
<p><strong>Buffering Requirements</strong>:</p>
<ul>
<li>Input data remains stable</li>
<li>No intermediate result buffering</li>
<li>Simplified data path</li>
<li>Reduced register count</li>
<li>Fixed storage allocation</li>
</ul>
</li>
<li>
<p><strong>Control Logic</strong>:</p>
<ul>
<li>Fixed timing control</li>
<li>Simple counter-based progression</li>
<li>Predictable state duration</li>
<li>Minimal conditional branches</li>
<li>Efficient synthesis to hardware</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Example</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Fixed 4-cycle implementation</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state;          <span class="hljs-comment">// 2-bit state register</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] cycle_counter;  <span class="hljs-comment">// 2-bit counter (0-3)</span>
<span class="hljs-comment">// Total: 4 flip-flops for control</span>
</div></code></pre>
</li>
</ul>
<p><strong>Variable Timing Resources</strong>:</p>
<ul>
<li>
<p><strong>State Machine Complexity</strong>:</p>
<ul>
<li>More complex with conditional progression</li>
<li>Data-dependent transitions</li>
<li>Variable iteration counts</li>
<li>Multiple conditional paths</li>
<li>Larger state encoding</li>
</ul>
</li>
<li>
<p><strong>Buffering Requirements</strong>:</p>
<ul>
<li>Interim result storage</li>
<li>Pipeline stage buffers</li>
<li>Multiple data registers</li>
<li>Complex data flow management</li>
<li>Dynamic storage allocation</li>
</ul>
</li>
<li>
<p><strong>Control Logic</strong>:</p>
<ul>
<li>Conditional timing control</li>
<li>Complex progression criteria</li>
<li>Variable state duration</li>
<li>Multiple branch conditions</li>
<li>More complex hardware structure</li>
</ul>
</li>
<li>
<p><strong>Resource Utilization Example</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Variable-cycle implementation</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state;          <span class="hljs-comment">// 3-bit state register</span>
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] sample_counter; <span class="hljs-comment">// 5-bit counter (0-31)</span>
<span class="hljs-keyword">reg</span> data_valid;           <span class="hljs-comment">// Valid flag</span>
<span class="hljs-keyword">reg</span> calc_complete;        <span class="hljs-comment">// Completion flag</span>
<span class="hljs-comment">// Total: 10+ flip-flops for control</span>
</div></code></pre>
</li>
</ul>
<p><strong>Specific Resource Impacts</strong>:</p>
<ol>
<li>
<p><strong>Register Utilization</strong>:</p>
<ul>
<li>Deterministic: Lower, fixed allocation</li>
<li>Variable: Higher, data-dependent allocation</li>
<li>Deterministic: Simpler control registers</li>
<li>Variable: More state tracking registers</li>
<li>Difference can be significant for complex operations</li>
</ul>
</li>
<li>
<p><strong>LUT Utilization</strong>:</p>
<ul>
<li>Deterministic: Lower, simpler logic paths</li>
<li>Variable: Higher, conditional evaluation</li>
<li>Deterministic: Regular structure</li>
<li>Variable: Irregular, branch-heavy logic</li>
<li>Impact scales with calculation complexity</li>
</ul>
</li>
<li>
<p><strong>Memory Utilization</strong>:</p>
<ul>
<li>Deterministic: Predictable access patterns</li>
<li>Variable: Irregular access patterns</li>
<li>Deterministic: Simplified memory control</li>
<li>Variable: Complex addressing and timing</li>
<li>Affects memory inference and optimization</li>
</ul>
</li>
<li>
<p><strong>FPGA-Specific Resource Impact</strong>:</p>
<ul>
<li>DSP usage typically similar for either approach</li>
<li>Block RAM utilization may differ with buffering needs</li>
<li>Routing complexity typically higher for variable approach</li>
<li>Timing closure more challenging with variable approach</li>
<li>Resource sharing opportunities differ between approaches</li>
</ul>
</li>
</ol>
<p>The resource implications of timing approach selection extend beyond simple component count to affect overall system architecture, scalability, and implementation efficiency.</p>
<h4 id="throughput-impact-analysis">Throughput Impact Analysis</h4>
<p>The calculation timing approach significantly affects system throughput:</p>
<p><strong>Deterministic Timing Throughput</strong>:</p>
<ul>
<li>
<p><strong>Calculation Rate</strong>:</p>
<ul>
<li>Fixed cycles per calculation</li>
<li>Example: 4 cycles per MA update</li>
<li>Predictable completion timing</li>
<li>Constant processing rate</li>
<li>Throughput = Clock Frequency / Fixed Cycle Count</li>
</ul>
</li>
<li>
<p><strong>Pipelining Potential</strong>:</p>
<ul>
<li>Regular stage timing</li>
<li>Balanced pipeline design</li>
<li>Fixed stage latency</li>
<li>Predictable throughput</li>
<li>Efficient resource utilization</li>
</ul>
</li>
<li>
<p><strong>Parallel Processing</strong>:</p>
<ul>
<li>Synchronized calculation units</li>
<li>Coordinated completion</li>
<li>Simplified result combining</li>
<li>Predictable system behavior</li>
<li>Efficient scaling</li>
</ul>
</li>
<li>
<p><strong>Throughput Calculation Example</strong>:</p>
<pre class="hljs"><code><div>System clock: 100 MHz
MA calculation: 4 cycles fixed
RSI calculation: 4 cycles fixed

MA throughput: 100 MHz / 4 = 25 million calculations per second
RSI throughput: 100 MHz / 4 = 25 million calculations per second
System throughput: 25 million updates per second
</div></code></pre>
</li>
</ul>
<p><strong>Variable Timing Throughput</strong>:</p>
<ul>
<li>
<p><strong>Calculation Rate</strong>:</p>
<ul>
<li>Data-dependent cycle count</li>
<li>Example: 1-20 cycles per RSI update</li>
<li>Varying completion timing</li>
<li>Fluctuating processing rate</li>
<li>Throughput = Clock Frequency / Average Cycle Count</li>
</ul>
</li>
<li>
<p><strong>Pipelining Challenges</strong>:</p>
<ul>
<li>Irregular stage timing</li>
<li>Pipeline bubbles</li>
<li>Variable stage latency</li>
<li>Fluctuating throughput</li>
<li>Complex resource management</li>
</ul>
</li>
<li>
<p><strong>Parallel Processing</strong>:</p>
<ul>
<li>Asynchronous calculation units</li>
<li>Independent completion</li>
<li>Complex result combining</li>
<li>Less predictable system behavior</li>
<li>Challenging scaling</li>
</ul>
</li>
<li>
<p><strong>Throughput Calculation Example</strong>:</p>
<pre class="hljs"><code><div>System clock: 100 MHz
MA calculation: 1-2 cycles variable
RSI calculation: 2-20 cycles variable

MA throughput: 100 MHz / 1.5 avg = 66.7 million calculations per second
RSI throughput: 100 MHz / 10 avg = 10 million calculations per second
System throughput: 10 million updates per second (limited by slowest component)
</div></code></pre>
</li>
</ul>
<p><strong>Throughput Optimization Techniques</strong>:</p>
<ol>
<li>
<p><strong>Hybrid Timing Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Variable computation with deterministic interface</span>
<span class="hljs-keyword">module</span> hybrid_timing_ma (
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state = IDLE;
    <span class="hljs-keyword">reg</span> computation_done = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Start variable-time calculation</span>
                    start_calculation &lt;= <span class="hljs-number">1</span>;
                    state &lt;= CALC;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            CALC: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Wait for calculation completion</span>
                <span class="hljs-keyword">if</span> (computation_done) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Always complete in exactly 4 cycles</span>
                    <span class="hljs-keyword">if</span> (cycle_count == <span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
                        state &lt;= DONE;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        cycle_count &lt;= cycle_count + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            DONE: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">1</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Variable-time calculation core</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (start_calculation) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Perform calculation (completes in variable time)</span>
            sum &lt;= sum + new_price - oldest_price;
            result &lt;= sum / WINDOW;
            computation_done &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            computation_done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<ul>
<li>Variable internal computation</li>
<li>Deterministic external interface</li>
<li>Balanced performance and predictability</li>
<li>Simplified system integration</li>
<li>Efficient resource utilization</li>
</ul>
</li>
<li>
<p><strong>Pipelined Calculation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Pipelined MA calculation</span>
<span class="hljs-keyword">module</span> pipelined_ma (
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Pipeline stages</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] sum_stage1;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] div_stage2;
    <span class="hljs-keyword">reg</span> valid_stage1, valid_stage2;
    
    <span class="hljs-comment">// Pipeline stage 1: Addition</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (new_data_valid) <span class="hljs-keyword">begin</span>
            sum_stage1 &lt;= sum + new_price - oldest_price;
            valid_stage1 &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            valid_stage1 &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Pipeline stage 2: Division</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (valid_stage1) <span class="hljs-keyword">begin</span>
            div_stage2 &lt;= sum_stage1 / WINDOW;
            valid_stage2 &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            valid_stage2 &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Output stage</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (valid_stage2) <span class="hljs-keyword">begin</span>
            moving_avg &lt;= div_stage2;
            done &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<ul>
<li>Continuous calculation flow</li>
<li>One result per clock cycle when pipelined</li>
<li>Maximized throughput</li>
<li>Increased latency</li>
<li>Higher resource utilization</li>
</ul>
</li>
</ol>
<p>The throughput impact analysis demonstrates that while variable timing may provide better average-case performance, deterministic timing often delivers more reliable system throughput, particularly in pipelined or parallel processing environments.</p>
<h4 id="design-simplicity-considerations">Design Simplicity Considerations</h4>
<p>Design simplicity represents an important consideration in the timing approach selection:</p>
<p><strong>Deterministic Timing Simplicity</strong>:</p>
<ul>
<li>
<p><strong>State Machine Structure</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Simple state machine with fixed transitions</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">case</span> (state)
        IDLE: <span class="hljs-keyword">if</span> (start) state &lt;= CALC;
        CALC: state &lt;= DONE;
        DONE: state &lt;= IDLE;
    <span class="hljs-keyword">endcase</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Linear state progression</li>
<li>Minimal conditional branches</li>
<li>Simple transition logic</li>
<li>Predictable execution flow</li>
<li>Straightforward implementation</li>
</ul>
</li>
<li>
<p><strong>Control Logic</strong>:</p>
<ul>
<li>Fixed operation sequencing</li>
<li>Predetermined cycle counts</li>
<li>Simple counter-based control</li>
<li>Minimal condition checking</li>
<li>Clear operational boundaries</li>
</ul>
</li>
<li>
<p><strong>Debugging and Verification</strong>:</p>
<ul>
<li>Predictable signal timing</li>
<li>Consistent waveform patterns</li>
<li>Easy cycle counting</li>
<li>Simpler test vector generation</li>
<li>More straightforward coverage analysis</li>
</ul>
</li>
<li>
<p><strong>Documentation Requirements</strong>:</p>
<ul>
<li>Fixed timing specifications</li>
<li>Simple interface description</li>
<li>Consistent operational description</li>
<li>Clear latency definition</li>
<li>Minimal timing dependencies</li>
</ul>
</li>
</ul>
<p><strong>Variable Timing Complexity</strong>:</p>
<ul>
<li>
<p><strong>State Machine Structure</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Complex state machine with data-dependent transitions</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">case</span> (state)
        IDLE: <span class="hljs-keyword">if</span> (start) state &lt;= PROCESS;
        PROCESS: <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">if</span> (sample_count &lt; WINDOW &amp;&amp; !fifo_empty) <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Continue processing</span>
                sample_count &lt;= sample_count + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sample_count &gt;= WINDOW) <span class="hljs-keyword">begin</span>
                state &lt;= CALCULATE;
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Wait for more data</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        CALCULATE: state &lt;= DONE;
        DONE: state &lt;= IDLE;
    <span class="hljs-keyword">endcase</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Branching state progression</li>
<li>Multiple conditional paths</li>
<li>Complex transition logic</li>
<li>Data-dependent execution flow</li>
<li>More involved implementation</li>
</ul>
</li>
<li>
<p><strong>Control Logic</strong>:</p>
<ul>
<li>Complex operation sequencing</li>
<li>Data-dependent termination</li>
<li>Multiple condition checks</li>
<li>Extensive flag management</li>
<li>Overlapping operational phases</li>
</ul>
</li>
<li>
<p><strong>Debugging and Verification</strong>:</p>
<ul>
<li>Variable signal timing</li>
<li>Inconsistent waveform patterns</li>
<li>Complex execution tracing</li>
<li>Data-dependent test vectors</li>
<li>More challenging coverage analysis</li>
</ul>
</li>
<li>
<p><strong>Documentation Requirements</strong>:</p>
<ul>
<li>Min/max/average timing specifications</li>
<li>Complex interface protocol description</li>
<li>Conditional operation documentation</li>
<li>Variable latency explanation</li>
<li>Extensive timing dependencies</li>
</ul>
</li>
</ul>
<p><strong>Design Complexity Metrics</strong>:</p>
<table>
<thead>
<tr>
<th>Complexity Metric</th>
<th>Deterministic Timing</th>
<th>Variable Timing</th>
</tr>
</thead>
<tbody>
<tr>
<td>State Count</td>
<td>Lower</td>
<td>Higher</td>
</tr>
<tr>
<td>Transition Conditions</td>
<td>Fewer, simpler</td>
<td>More, complex</td>
</tr>
<tr>
<td>Control Signals</td>
<td>Fewer</td>
<td>More</td>
</tr>
<tr>
<td>Flag Registers</td>
<td>Fewer</td>
<td>More</td>
</tr>
<tr>
<td>Code Lines</td>
<td>Fewer</td>
<td>More</td>
</tr>
<tr>
<td>Branch Complexity</td>
<td>Lower</td>
<td>Higher</td>
</tr>
<tr>
<td>Cognitive Load</td>
<td>Lower</td>
<td>Higher</td>
</tr>
<tr>
<td>Verification Effort</td>
<td>Lower</td>
<td>Higher</td>
</tr>
</tbody>
</table>
<p><strong>Maintenance Considerations</strong>:</p>
<ul>
<li>
<p><strong>Deterministic Timing</strong>:</p>
<ul>
<li>Easier to understand for new developers</li>
<li>Simpler modification process</li>
<li>Lower regression risk with changes</li>
<li>Clearer interface contracts</li>
<li>More straightforward performance analysis</li>
</ul>
</li>
<li>
<p><strong>Variable Timing</strong>:</p>
<ul>
<li>Higher learning curve for new developers</li>
<li>More complex modification process</li>
<li>Higher regression risk with changes</li>
<li>More complex interface requirements</li>
<li>More involved performance analysis</li>
</ul>
</li>
</ul>
<p>The design simplicity advantage of deterministic timing approaches translates to lower development and maintenance costs, reduced risk, and improved project sustainability, often outweighing the potential performance benefits of variable timing for many applications.</p>
<h4 id="application-specific-selection-criteria">Application-Specific Selection Criteria</h4>
<p>Different applications have unique requirements that influence the timing approach selection:</p>
<p><strong>High-Frequency Trading Applications</strong>:</p>
<ul>
<li>
<p><strong>Primary Requirements</strong>:</p>
<ul>
<li>Lowest possible latency</li>
<li>Deterministic response time</li>
<li>Predictable system behavior</li>
<li>Reliable operation</li>
<li>Precise timing characteristics</li>
</ul>
</li>
<li>
<p><strong>Recommended Approach</strong>:</p>
<ul>
<li>Deterministic timing with minimum fixed cycles</li>
<li>Fully pipelined implementation</li>
<li>Fixed latency guarantees</li>
<li>Worst-case performance optimization</li>
<li>Clear timing boundaries</li>
</ul>
</li>
<li>
<p><strong>Implementation Example</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Minimal-latency fixed-cycle implementation</span>
<span class="hljs-keyword">module</span> hft_ma_calculator (
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Single-cycle MA update</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (new_data) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Update MA in exactly one cycle</span>
            sum &lt;= sum + new_price - oldest_price;
            moving_avg &lt;= (sum + new_price - oldest_price) / WINDOW;
            done &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
</ul>
<p><strong>Backtesting and Analysis Systems</strong>:</p>
<ul>
<li>
<p><strong>Primary Requirements</strong>:</p>
<ul>
<li>Maximum throughput</li>
<li>Efficient resource utilization</li>
<li>Scalability to multiple instruments</li>
<li>Flexible calculation options</li>
<li>Overall system performance</li>
</ul>
</li>
<li>
<p><strong>Recommended Approach</strong>:</p>
<ul>
<li>Variable timing for maximum efficiency</li>
<li>Optimized calculation paths</li>
<li>Asynchronous processing</li>
<li>Average-case optimization</li>
<li>Resource sharing capabilities</li>
</ul>
</li>
<li>
<p><strong>Implementation Example</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// High-throughput variable-cycle implementation</span>
<span class="hljs-keyword">module</span> backtesting_calculator (
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Process multiple instruments with shared resources</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (!calculation_queue_empty) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Get next instrument from queue</span>
                    current_instrument &lt;= queue_instrument;
                    state &lt;= CALCULATE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            CALCULATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Perform calculation with minimum required cycles</span>
                <span class="hljs-keyword">if</span> (calculation_complete) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Store result and proceed to next</span>
                    result_valid[current_instrument] &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
</ul>
<p><strong>Multi-Strategy Trading Systems</strong>:</p>
<ul>
<li>
<p><strong>Primary Requirements</strong>:</p>
<ul>
<li>Multiple indicator calculation</li>
<li>Strategy combination capabilities</li>
<li>Balanced resource utilization</li>
<li>Reliable signal generation</li>
<li>Manageable system complexity</li>
</ul>
</li>
<li>
<p><strong>Recommended Approach</strong>:</p>
<ul>
<li>Hybrid timing approach</li>
<li>Critical path optimization</li>
<li>Selective deterministic components</li>
<li>Balanced resource allocation</li>
<li>Clear synchronization points</li>
</ul>
</li>
<li>
<p><strong>Implementation Example</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Multi-strategy system with mixed timing</span>
<span class="hljs-keyword">module</span> multi_strategy_system (
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Critical path: Deterministic timing</span>
    moving_average_fsm ma_calculator (
        <span class="hljs-comment">// Fixed-cycle implementation</span>
        <span class="hljs-comment">// ...</span>
    );
    
    <span class="hljs-comment">// Secondary indicators: Variable timing</span>
    rsi_calculator rsi_calc (
        <span class="hljs-comment">// Variable-cycle implementation</span>
        <span class="hljs-comment">// ...</span>
    );
    
    <span class="hljs-comment">// Synchronization at strategy decision point</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (ma_done &amp;&amp; rsi_done) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Generate trading signals</span>
            strategy_active &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
</ul>
<p><strong>Educational and Prototyping Systems</strong>:</p>
<ul>
<li>
<p><strong>Primary Requirements</strong>:</p>
<ul>
<li>Implementation clarity</li>
<li>Understandable operation</li>
<li>Straightforward debugging</li>
<li>Flexible modification</li>
<li>Demonstration capability</li>
</ul>
</li>
<li>
<p><strong>Recommended Approach</strong>:</p>
<ul>
<li>Deterministic timing for simplicity</li>
<li>Clear state boundaries</li>
<li>Explicit operation phases</li>
<li>Simple control structures</li>
<li>Modular design</li>
</ul>
</li>
<li>
<p><strong>Implementation Example</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Educational implementation with clear phases</span>
<span class="hljs-keyword">module</span> educational_ma_calculator (
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Clear state definitions</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, READ = <span class="hljs-number">1</span>, ACCUMULATE = <span class="hljs-number">2</span>, DIVIDE = <span class="hljs-number">3</span>, DONE = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-comment">// Explicit phased operation</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">if</span> (start) state &lt;= READ;
            READ: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Read data phase</span>
                oldest &lt;= data[read_ptr];
                state &lt;= ACCUMULATE;
            <span class="hljs-keyword">end</span>
            ACCUMULATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Calculation phase</span>
                sum &lt;= sum + new_price - oldest;
                state &lt;= DIVIDE;
            <span class="hljs-keyword">end</span>
            DIVIDE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Division phase</span>
                result &lt;= sum / WINDOW;
                state &lt;= DONE;
            <span class="hljs-keyword">end</span>
            DONE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Result phase</span>
                done &lt;= <span class="hljs-number">1</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
</ul>
<p><strong>Application-Specific Selection Matrix</strong>:</p>
<table>
<thead>
<tr>
<th>Application Type</th>
<th>Timing Priority</th>
<th>Resource Priority</th>
<th>Recommended Approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>High-Frequency Trading</td>
<td>Latency</td>
<td>Performance</td>
<td>Fixed minimal cycles</td>
</tr>
<tr>
<td>Backtesting System</td>
<td>Throughput</td>
<td>Efficiency</td>
<td>Variable optimized</td>
</tr>
<tr>
<td>Multi-Strategy Trading</td>
<td>Balance</td>
<td>Functionality</td>
<td>Hybrid approach</td>
</tr>
<tr>
<td>Educational System</td>
<td>Clarity</td>
<td>Understandability</td>
<td>Phased deterministic</td>
</tr>
<tr>
<td>Production Trading</td>
<td>Reliability</td>
<td>Maintainability</td>
<td>Deterministic</td>
</tr>
<tr>
<td>Research Platform</td>
<td>Flexibility</td>
<td>Adaptability</td>
<td>Configurable hybrid</td>
</tr>
</tbody>
</table>
<p>The application-specific selection criteria provide a framework for choosing the most appropriate timing approach based on the unique requirements and constraints of each trading system implementation.</p>
<h4 id="hybrid-approach-possibilities">Hybrid Approach Possibilities</h4>
<p>Hybrid timing approaches combine the benefits of both deterministic and variable timing:</p>
<p><strong>1. Deterministic Interface with Variable Core</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> hybrid_timing_calculator #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> FIXED_CYCLES = <span class="hljs-number">4</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// State machine for deterministic external interface</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ext_state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] cycle_counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> calculation_started = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> internal_done = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// External deterministic interface</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (ext_state)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// IDLE</span>
                <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                    ext_state &lt;= <span class="hljs-number">1</span>;
                    cycle_counter &lt;= <span class="hljs-number">0</span>;
                    calculation_started &lt;= <span class="hljs-number">1</span>;
                    done &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// CALCULATE</span>
                calculation_started &lt;= <span class="hljs-number">0</span>;
                
                <span class="hljs-comment">// Always take exactly FIXED_CYCLES cycles</span>
                <span class="hljs-keyword">if</span> (cycle_counter &lt; FIXED_CYCLES-<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                    cycle_counter &lt;= cycle_counter + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    ext_state &lt;= <span class="hljs-number">2</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// DONE</span>
                done &lt;= <span class="hljs-number">1</span>;
                ext_state &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Internal variable-time calculation core</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] int_state = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (calculation_started) <span class="hljs-keyword">begin</span>
            int_state &lt;= <span class="hljs-number">1</span>;
            internal_done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
        
        <span class="hljs-keyword">case</span> (int_state)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// IDLE</span>
                <span class="hljs-comment">// Wait for trigger</span>
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// VARIABLE CALCULATION</span>
                <span class="hljs-comment">// Perform calculation in variable time</span>
                <span class="hljs-comment">// ...</span>
                
                <span class="hljs-comment">// Optimized calculation path</span>
                sum &lt;= sum + new_price - oldest_price;
                
                <span class="hljs-comment">// When complete (variable timing)</span>
                int_state &lt;= <span class="hljs-number">2</span>;
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// FINALIZE</span>
                moving_avg &lt;= sum / WINDOW;
                internal_done &lt;= <span class="hljs-number">1</span>;
                int_state &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This approach features:</p>
<ul>
<li>Deterministic external timing for system integration</li>
<li>Variable internal timing for calculation efficiency</li>
<li>Clean interface contract</li>
<li>Optimized internal implementation</li>
<li>Buffer between timing domains</li>
</ul>
<p><strong>2. Adaptive Cycle Allocation</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> adaptive_timing_calculator #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> MAX_CYCLES = <span class="hljs-number">8</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Adaptive timing control</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] allocated_cycles;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] cycle_counter = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Cycle allocation based on system load</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (system_busy) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reduce allocated cycles when system is busy</span>
            allocated_cycles &lt;= <span class="hljs-number">2</span>;  <span class="hljs-comment">// Minimum cycles</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Use more cycles when system has capacity</span>
            allocated_cycles &lt;= <span class="hljs-number">6</span>;  <span class="hljs-comment">// More thorough calculation</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// State machine with adaptive timing</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                    state &lt;= CALCULATE;
                    cycle_counter &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            CALCULATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Adaptive calculation quality based on allocated cycles</span>
                <span class="hljs-keyword">if</span> (cycle_counter &lt; allocated_cycles) <span class="hljs-keyword">begin</span>
                    cycle_counter &lt;= cycle_counter + <span class="hljs-number">1</span>;
                    
                    <span class="hljs-comment">// Perform incremental calculation improvements</span>
                    <span class="hljs-keyword">case</span> (cycle_counter)
                        <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Essential calculation (always performed)</span>
                            sum &lt;= sum + new_price - oldest_price;
                            basic_avg &lt;= sum / WINDOW;
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Enhanced precision (if cycles available)</span>
                            <span class="hljs-comment">// ...</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Additional filtering (if cycles available)</span>
                            <span class="hljs-comment">// ...</span>
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">endcase</span>
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    state &lt;= DONE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            DONE: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">1</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This approach enables:</p>
<ul>
<li>Dynamic cycle allocation based on system conditions</li>
<li>Quality/performance tradeoff control</li>
<li>Graceful degradation under load</li>
<li>Enhanced results when resources available</li>
<li>Bounded worst-case timing</li>
</ul>
<p><strong>3. Parallel Processing with Result Selection</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> parallel_timing_calculator #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Parallel calculation paths</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] fast_result;    <span class="hljs-comment">// Quick approximation</span>
    <span class="hljs-keyword">reg</span> fast_done = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] precise_result; <span class="hljs-comment">// Precise calculation</span>
    <span class="hljs-keyword">reg</span> precise_done = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Fast calculation path (deterministic timing)</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Simplified calculation (2 cycles)</span>
            sum &lt;= sum + new_price - oldest_price;
            fast_result &lt;= sum / WINDOW;
            fast_done &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            fast_done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Precise calculation path (variable timing)</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (precise_state)
            <span class="hljs-number">0</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// IDLE</span>
                <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                    precise_state &lt;= <span class="hljs-number">1</span>;
                    <span class="hljs-comment">// Initialize precise calculation</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            <span class="hljs-number">1</span>: <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// CALCULATE</span>
                <span class="hljs-comment">// More complex algorithm (variable cycles)</span>
                <span class="hljs-comment">// ...</span>
                
                <span class="hljs-comment">// When complete</span>
                precise_result &lt;= enhanced_result;
                precise_done &lt;= <span class="hljs-number">1</span>;
                precise_state &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Result selection</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (timeout || precise_done) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Use precise result if available in time</span>
            moving_avg &lt;= precise_done ? precise_result : fast_result;
            done &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fast_done &amp;&amp; !wait_for_precise) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Use fast result if not waiting for precise</span>
            moving_avg &lt;= fast_result;
            done &lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This hybrid approach provides:</p>
<ul>
<li>Guaranteed result availability through fast path</li>
<li>Enhanced precision when time permits</li>
<li>Configurable precision/latency tradeoff</li>
<li>Bounded worst-case timing</li>
<li>Quality scaling with available time</li>
</ul>
<p><strong>4. Time-Sliced Processing</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> time_sliced_calculator #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> SLICE_SIZE = <span class="hljs-number">4</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Time-sliced processing state</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] process_index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> processing_active = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Time-sliced calculation</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                    state &lt;= PROCESS;
                    process_index &lt;= <span class="hljs-number">0</span>;
                    processing_active &lt;= <span class="hljs-number">1</span>;
                    <span class="hljs-comment">// Initialize calculation</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            PROCESS: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Process data in fixed-size slices</span>
                <span class="hljs-keyword">if</span> (process_index &lt; WINDOW) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Process SLICE_SIZE elements per cycle</span>
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SLICE_SIZE; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> (process_index + i &lt; WINDOW) <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Process element at process_index + i</span>
                            <span class="hljs-comment">// ...</span>
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">end</span>
                    
                    <span class="hljs-comment">// Update process index</span>
                    process_index &lt;= process_index + SLICE_SIZE;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    state &lt;= FINALIZE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            FINALIZE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Complete calculation</span>
                moving_avg &lt;= sum / WINDOW;
                state &lt;= DONE;
            <span class="hljs-keyword">end</span>
            
            DONE: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">1</span>;
                processing_active &lt;= <span class="hljs-number">0</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// External interface</span>
    <span class="hljs-keyword">assign</span> busy = processing_active;
    <span class="hljs-keyword">assign</span> progress = (process_index * <span class="hljs-number">100</span>) / WINDOW;
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This approach enables:</p>
<ul>
<li>Predictable processing rate</li>
<li>Interruptible calculation</li>
<li>Progress monitoring</li>
<li>Configurable time slice size</li>
<li>Balanced system loading</li>
</ul>
<p>These hybrid approach possibilities offer flexible implementations that can be tailored to specific application requirements, combining the benefits of both deterministic and variable timing approaches while mitigating their respective drawbacks.</p>
<h3 id="state-machine-complexity-tradeoffs">State Machine Complexity Tradeoffs</h3>
<h4 id="simplicity-vs-functionality">Simplicity vs. Functionality</h4>
<p>State machine design involves fundamental tradeoffs between simplicity and functionality:</p>
<p><strong>Simple State Machine Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Minimal Moving Average FSM (3 states)</span>
<span class="hljs-keyword">module</span> simple_ma_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Simple 3-state machine</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, CALCULATE = <span class="hljs-number">1</span>, DONE = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            state &lt;= IDLE;
            sum &lt;= <span class="hljs-number">0</span>;
            moving_avg &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Default signal assignments</span>
            done &lt;= <span class="hljs-number">0</span>;
            
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (start)
                        state &lt;= CALCULATE;
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Single-state calculation</span>
                    sum &lt;= sum + new_price - oldest_price;
                    moving_avg &lt;= sum / WINDOW;
                    state &lt;= DONE;
                <span class="hljs-keyword">end</span>
                
                DONE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key characteristics:</p>
<ul>
<li>Minimal state count (3 states)</li>
<li>Linear state progression</li>
<li>Simple transition logic</li>
<li>Limited functionality</li>
<li>Straightforward implementation</li>
</ul>
<p><strong>Feature-Rich State Machine Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Enhanced Moving Average FSM (7+ states)</span>
<span class="hljs-keyword">module</span> enhanced_ma_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Enhanced port list...</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> pause,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> reset_accum,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] precision_mode,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] status,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> error
);
    <span class="hljs-comment">// Complex state machine</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, CHECK = <span class="hljs-number">1</span>, INIT = <span class="hljs-number">2</span>, ACCUMULATE = <span class="hljs-number">3</span>, 
               DIVIDE = <span class="hljs-number">4</span>, FILTER = <span class="hljs-number">5</span>, DONE = <span class="hljs-number">6</span>, ERROR = <span class="hljs-number">7</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset logic</span>
            state &lt;= IDLE;
            <span class="hljs-comment">// ... register initialization</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Default assignments</span>
            done &lt;= <span class="hljs-number">0</span>;
            error &lt;= <span class="hljs-number">0</span>;
            
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (start)
                        state &lt;= CHECK;
                <span class="hljs-keyword">end</span>
                
                CHECK: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Input validation</span>
                    <span class="hljs-keyword">if</span> (new_price &gt; MAX_VALID_PRICE || oldest_price &gt; MAX_VALID_PRICE) <span class="hljs-keyword">begin</span>
                        error &lt;= <span class="hljs-number">1</span>;
                        state &lt;= ERROR;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        state &lt;= (reset_accum) ? INIT : ACCUMULATE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                INIT: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Reinitialize calculation</span>
                    sum &lt;= new_price;
                    count &lt;= <span class="hljs-number">1</span>;
                    state &lt;= ACCUMULATE;
                <span class="hljs-keyword">end</span>
                
                ACCUMULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Update running sum</span>
                    <span class="hljs-keyword">if</span> (!pause) <span class="hljs-keyword">begin</span>
                        sum &lt;= sum + new_price - oldest_price;
                        state &lt;= DIVIDE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                DIVIDE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Division with precision modes</span>
                    <span class="hljs-keyword">case</span> (precision_mode)
                        <span class="hljs-number">0</span>: moving_avg &lt;= sum / WINDOW;                     <span class="hljs-comment">// Fast</span>
                        <span class="hljs-number">1</span>: moving_avg &lt;= (sum + (WINDOW/<span class="hljs-number">2</span>)) / WINDOW;      <span class="hljs-comment">// Rounded</span>
                        <span class="hljs-number">2</span>: moving_avg &lt;= fixed_point_divide(sum, WINDOW);  <span class="hljs-comment">// High precision</span>
                        <span class="hljs-number">3</span>: moving_avg &lt;= adaptive_precision_divide(sum, WINDOW); <span class="hljs-comment">// Context-aware</span>
                    <span class="hljs-keyword">endcase</span>
                    
                    state &lt;= FILTER;
                <span class="hljs-keyword">end</span>
                
                FILTER: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Optional output filtering</span>
                    <span class="hljs-keyword">if</span> (enable_filter) <span class="hljs-keyword">begin</span>
                        moving_avg &lt;= apply_filter(moving_avg);
                    <span class="hljs-keyword">end</span>
                    
                    state &lt;= DONE;
                <span class="hljs-keyword">end</span>
                
                DONE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    status &lt;= STATUS_COMPLETE;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                ERROR: <span class="hljs-keyword">begin</span>
                    status &lt;= STATUS_ERROR;
                    <span class="hljs-keyword">if</span> (error_ack)
                        state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key characteristics:</p>
<ul>
<li>Expanded state count (8 states)</li>
<li>Complex state transitions</li>
<li>Feature-rich implementation</li>
<li>Enhanced functionality</li>
<li>Sophisticated control</li>
</ul>
<p><strong>Simplicity vs. Functionality Comparison</strong>:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Simple Approach</th>
<th>Feature-Rich Approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>State Count</td>
<td>3-4 states</td>
<td>7+ states</td>
</tr>
<tr>
<td>Code Size</td>
<td>~30 lines</td>
<td>100+ lines</td>
</tr>
<tr>
<td>Features</td>
<td>Basic calculation</td>
<td>Advanced features</td>
</tr>
<tr>
<td>Error Handling</td>
<td>Minimal/none</td>
<td>Comprehensive</td>
</tr>
<tr>
<td>Configurability</td>
<td>Fixed operation</td>
<td>Multiple options</td>
</tr>
<tr>
<td>Maintenance</td>
<td>Straightforward</td>
<td>More complex</td>
</tr>
<tr>
<td>Verification</td>
<td>Simpler</td>
<td>More involved</td>
</tr>
<tr>
<td>Resource Usage</td>
<td>Lower</td>
<td>Higher</td>
</tr>
</tbody>
</table>
<p><strong>Feature Impact Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>State Impact</th>
<th>Complexity Impact</th>
<th>Benefit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input Validation</td>
<td>+1 state</td>
<td>Medium</td>
<td>Error prevention</td>
</tr>
<tr>
<td>Pause/Resume</td>
<td>+1 state</td>
<td>Medium</td>
<td>Operational control</td>
</tr>
<tr>
<td>Precision Modes</td>
<td>+1 state</td>
<td>High</td>
<td>Calculation quality</td>
</tr>
<tr>
<td>Filtering</td>
<td>+1 state</td>
<td>Medium</td>
<td>Output quality</td>
</tr>
<tr>
<td>Error Recovery</td>
<td>+1 state</td>
<td>High</td>
<td>Robustness</td>
</tr>
<tr>
<td>Status Reporting</td>
<td>+0 states</td>
<td>Low</td>
<td>System monitoring</td>
</tr>
<tr>
<td>Accumulator Reset</td>
<td>+1 state</td>
<td>Low</td>
<td>Manual control</td>
</tr>
</tbody>
</table>
<p>The current technical analysis system balances these tradeoffs, implementing relatively simple state machines for the core indicators while providing sufficient functionality for reliable operation. This design choice prioritizes reliability and maintainability over advanced features, appropriate for the system's primary purpose of generating consistent trading signals.</p>
<h4 id="error-handling-capabilities">Error Handling Capabilities</h4>
<p>State machine design significantly impacts error handling capabilities:</p>
<p><strong>Minimal Error Handling Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Simple state machine with basic error handling</span>
<span class="hljs-keyword">module</span> basic_error_ma_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Simple state machine</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, CALCULATE = <span class="hljs-number">1</span>, DONE = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset handling</span>
            state &lt;= IDLE;
            sum &lt;= <span class="hljs-number">0</span>;
            moving_avg &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            <span class="hljs-comment">// No error handling</span>
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (start)
                        state &lt;= CALCULATE;
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Basic calculation without error checking</span>
                    sum &lt;= sum + new_price - oldest_price;
                    moving_avg &lt;= sum / WINDOW;
                    state &lt;= DONE;
                <span class="hljs-keyword">end</span>
                
                DONE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key limitations:</p>
<ul>
<li>No input validation</li>
<li>No overflow detection</li>
<li>No error reporting</li>
<li>No recovery mechanisms</li>
<li>Reset as only error response</li>
</ul>
<p><strong>Comprehensive Error Handling Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Enhanced state machine with robust error handling</span>
<span class="hljs-keyword">module</span> robust_error_ma_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> MAX_VALID_PRICE = <span class="hljs-number">16&#x27;hFF00</span>
)(
    <span class="hljs-comment">// Extended ports...</span>
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> start,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] new_price,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [DW-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] oldest_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> done,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] error_code,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> error_active,
    <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> error_ack
);
    <span class="hljs-comment">// Enhanced state machine</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, VALIDATE = <span class="hljs-number">1</span>, CALCULATE = <span class="hljs-number">2</span>, DONE = <span class="hljs-number">3</span>, 
               ERROR = <span class="hljs-number">4</span>, RECOVER = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-comment">// Error codes</span>
    <span class="hljs-keyword">localparam</span> ERR_NONE = <span class="hljs-number">0</span>, ERR_INVALID_PRICE = <span class="hljs-number">1</span>, 
               ERR_OVERFLOW = <span class="hljs-number">2</span>, ERR_DIVIDE_ZERO = <span class="hljs-number">3</span>,
               ERR_TIMEOUT = <span class="hljs-number">4</span>;
    
    <span class="hljs-comment">// Overflow detection registers</span>
    <span class="hljs-keyword">reg</span> overflow_detected;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] prev_sum;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Reset handling</span>
            state &lt;= IDLE;
            sum &lt;= <span class="hljs-number">0</span>;
            moving_avg &lt;= <span class="hljs-number">0</span>;
            done &lt;= <span class="hljs-number">0</span>;
            error_code &lt;= ERR_NONE;
            error_active &lt;= <span class="hljs-number">0</span>;
            overflow_detected &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-comment">// Default assignments</span>
            done &lt;= <span class="hljs-number">0</span>;
            
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                        error_code &lt;= ERR_NONE;
                        error_active &lt;= <span class="hljs-number">0</span>;
                        state &lt;= VALIDATE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                VALIDATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Input validation</span>
                    <span class="hljs-keyword">if</span> (new_price &gt; MAX_VALID_PRICE) <span class="hljs-keyword">begin</span>
                        error_code &lt;= ERR_INVALID_PRICE;
                        error_active &lt;= <span class="hljs-number">1</span>;
                        state &lt;= ERROR;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WINDOW == <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                        error_code &lt;= ERR_DIVIDE_ZERO;
                        error_active &lt;= <span class="hljs-number">1</span>;
                        state &lt;= ERROR;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        state &lt;= CALCULATE;
                        prev_sum &lt;= sum;  <span class="hljs-comment">// Save for overflow detection</span>
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Calculation with error checking</span>
                    sum &lt;= sum + new_price - oldest_price;
                    
                    <span class="hljs-comment">// Overflow detection</span>
                    <span class="hljs-keyword">if</span> ((sum + new_price) &lt; sum) <span class="hljs-keyword">begin</span>
                        error_code &lt;= ERR_OVERFLOW;
                        error_active &lt;= <span class="hljs-number">1</span>;
                        state &lt;= ERROR;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        moving_avg &lt;= sum / WINDOW;
                        state &lt;= DONE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                DONE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
                
                ERROR: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Error handling state</span>
                    <span class="hljs-keyword">if</span> (error_ack) <span class="hljs-keyword">begin</span>
                        state &lt;= RECOVER;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                RECOVER: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Error recovery actions</span>
                    <span class="hljs-keyword">case</span> (error_code)
                        ERR_OVERFLOW: <span class="hljs-keyword">begin</span>
                            sum &lt;= prev_sum;  <span class="hljs-comment">// Restore previous sum</span>
                        <span class="hljs-keyword">end</span>
                        
                        ERR_INVALID_PRICE: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Skip this price update</span>
                        <span class="hljs-keyword">end</span>
                        
                        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Generic recovery</span>
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">endcase</span>
                    
                    error_active &lt;= <span class="hljs-number">0</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key capabilities:</p>
<ul>
<li>Input value validation</li>
<li>Overflow detection</li>
<li>Error classification</li>
<li>Recovery mechanisms</li>
<li>Status reporting</li>
</ul>
<p><strong>Error Handling Capability Comparison</strong>:</p>
<table>
<thead>
<tr>
<th>Error Handling Aspect</th>
<th>Minimal Approach</th>
<th>Robust Approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>Error Detection</td>
<td>None/reset only</td>
<td>Comprehensive</td>
</tr>
<tr>
<td>Error Classification</td>
<td>None</td>
<td>Multiple error codes</td>
</tr>
<tr>
<td>Recovery Options</td>
<td>System reset</td>
<td>Error-specific recovery</td>
</tr>
<tr>
<td>System Integration</td>
<td>Minimal</td>
<td>Status reporting</td>
</tr>
<tr>
<td>Resource Overhead</td>
<td>None</td>
<td>Moderate</td>
</tr>
<tr>
<td>State Overhead</td>
<td>None</td>
<td>2-3 additional states</td>
</tr>
</tbody>
</table>
<p><strong>Error Handling Categories</strong>:</p>
<ol>
<li>
<p><strong>Input Validation</strong>:</p>
<ul>
<li>Range checking for prices</li>
<li>Parameter validation</li>
<li>Protocol compliance</li>
<li>Timing verification</li>
<li>Data consistency checks</li>
</ul>
</li>
<li>
<p><strong>Computational Error Detection</strong>:</p>
<ul>
<li>Overflow/underflow detection</li>
<li>Division by zero prevention</li>
<li>Precision loss monitoring</li>
<li>Algorithm convergence checks</li>
<li>Result range validation</li>
</ul>
</li>
<li>
<p><strong>Operational Error Handling</strong>:</p>
<ul>
<li>Timeout detection</li>
<li>Protocol violation response</li>
<li>Synchronization error recovery</li>
<li>Resource exhaustion handling</li>
<li>System integrity verification</li>
</ul>
</li>
<li>
<p><strong>Error Reporting Mechanisms</strong>:</p>
<ul>
<li>Error code generation</li>
<li>Status register updating</li>
<li>Error signal assertion</li>
<li>Diagnostic information capture</li>
<li>System notification</li>
</ul>
</li>
<li>
<p><strong>Recovery Strategies</strong>:</p>
<ul>
<li>State rollback</li>
<li>Safe value substitution</li>
<li>Calculation restart</li>
<li>Graceful degradation</li>
<li>System reset initiation</li>
</ul>
</li>
</ol>
<p>The current technical analysis system implements moderate error handling, focusing on critical aspects like overflow prevention through appropriate register sizing, while maintaining relatively simple state machines. This approach balances robustness with implementation complexity, appropriate for the reliable execution of well-defined calculations.</p>
<h4 id="edge-case-management">Edge Case Management</h4>
<p>State machine design significantly affects edge case handling capabilities:</p>
<p><strong>Basic Edge Case Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Simple state machine with minimal edge case handling</span>
<span class="hljs-keyword">module</span> basic_rsi_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Simple state machine</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, CALCULATE = <span class="hljs-number">1</span>, DONE = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (start)
                    state &lt;= CALCULATE;
            <span class="hljs-keyword">end</span>
            
            CALCULATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Basic RSI calculation</span>
                <span class="hljs-keyword">if</span> (price &gt; prev_price)
                    gain_sum &lt;= gain_sum + (price - prev_price);
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; prev_price)
                    loss_sum &lt;= loss_sum + (prev_price - price);
                
                <span class="hljs-comment">// Calculate RSI</span>
                <span class="hljs-keyword">if</span> (loss_sum &gt; <span class="hljs-number">0</span>)
                    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
                <span class="hljs-keyword">else</span>
                    rsi &lt;= <span class="hljs-number">100</span>;  <span class="hljs-comment">// Simple edge case</span>
                
                state &lt;= DONE;
            <span class="hljs-keyword">end</span>
            
            DONE: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">1</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key limitations:</p>
<ul>
<li>Minimal edge case detection</li>
<li>Simple default handling</li>
<li>No special initialization</li>
<li>Limited boundary condition management</li>
<li>Potential for incorrect results</li>
</ul>
<p><strong>Comprehensive Edge Case Management</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Enhanced state machine with robust edge case handling</span>
<span class="hljs-keyword">module</span> robust_rsi_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Extended ports...</span>
);
    <span class="hljs-comment">// Enhanced state machine</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, INIT = <span class="hljs-number">1</span>, WARMUP = <span class="hljs-number">2</span>, ACCUMULATE = <span class="hljs-number">3</span>, 
               CALCULATE = <span class="hljs-number">4</span>, VALIDATE = <span class="hljs-number">5</span>, DONE = <span class="hljs-number">6</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-comment">// Edge case tracking</span>
    <span class="hljs-keyword">reg</span> initialization_complete = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] sample_count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> all_same_prices = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">reg</span> extreme_values_detected = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Bounds and validation</span>
    <span class="hljs-keyword">localparam</span> MIN_VALID_CHANGE = <span class="hljs-number">16&#x27;d2</span>;  <span class="hljs-comment">// Minimum significant change</span>
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (!initialization_complete) <span class="hljs-keyword">begin</span>
                        state &lt;= INIT;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        state &lt;= ACCUMULATE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            INIT: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Proper initialization</span>
                gain_sum &lt;= <span class="hljs-number">0</span>;
                loss_sum &lt;= <span class="hljs-number">0</span>;
                prev_price &lt;= price;
                sample_count &lt;= <span class="hljs-number">1</span>;
                all_same_prices &lt;= <span class="hljs-number">1</span>;
                extreme_values_detected &lt;= <span class="hljs-number">0</span>;
                initialization_complete &lt;= <span class="hljs-number">1</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
            
            WARMUP: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Special handling during initial window filling</span>
                <span class="hljs-keyword">if</span> (sample_count &lt; WINDOW) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Accumulate but don&#x27;t calculate until window filled</span>
                    <span class="hljs-keyword">if</span> (price &gt; prev_price) <span class="hljs-keyword">begin</span>
                        gain_sum &lt;= gain_sum + (price - prev_price);
                        <span class="hljs-keyword">if</span> ((price - prev_price) &gt;= MIN_VALID_CHANGE)
                            all_same_prices &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; prev_price) <span class="hljs-keyword">begin</span>
                        loss_sum &lt;= loss_sum + (prev_price - price);
                        <span class="hljs-keyword">if</span> ((prev_price - price) &gt;= MIN_VALID_CHANGE)
                            all_same_prices &lt;= <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">end</span>
                    
                    prev_price &lt;= price;
                    sample_count &lt;= sample_count + <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    state &lt;= CALCULATE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            ACCUMULATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Normal operation after initialization</span>
                <span class="hljs-keyword">if</span> (price &gt; prev_price) <span class="hljs-keyword">begin</span>
                    gain_sum &lt;= gain_sum + (price - prev_price);
                    <span class="hljs-keyword">if</span> ((price - prev_price) &gt;= MIN_VALID_CHANGE)
                        all_same_prices &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (price &lt; prev_price) <span class="hljs-keyword">begin</span>
                    loss_sum &lt;= loss_sum + (prev_price - price);
                    <span class="hljs-keyword">if</span> ((prev_price - price) &gt;= MIN_VALID_CHANGE)
                        all_same_prices &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span>
                
                prev_price &lt;= price;
                state &lt;= CALCULATE;
            <span class="hljs-keyword">end</span>
            
            CALCULATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Edge case handling in calculation</span>
                <span class="hljs-keyword">if</span> (all_same_prices) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// No significant price changes</span>
                    rsi &lt;= <span class="hljs-number">50</span>;  <span class="hljs-comment">// Neutral RSI value</span>
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (loss_sum == <span class="hljs-number">0</span> &amp;&amp; gain_sum &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// All gains, no losses</span>
                    rsi &lt;= <span class="hljs-number">100</span>;  <span class="hljs-comment">// Maximum RSI value</span>
                    extreme_values_detected &lt;= <span class="hljs-number">1</span>;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gain_sum == <span class="hljs-number">0</span> &amp;&amp; loss_sum &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// All losses, no gains</span>
                    rsi &lt;= <span class="hljs-number">0</span>;   <span class="hljs-comment">// Minimum RSI value</span>
                    extreme_values_detected &lt;= <span class="hljs-number">1</span>;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gain_sum + loss_sum &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Normal calculation</span>
                    rsi &lt;= (<span class="hljs-number">100</span> * gain_sum) / (gain_sum + loss_sum);
                    extreme_values_detected &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// No movement at all</span>
                    rsi &lt;= <span class="hljs-number">50</span>;  <span class="hljs-comment">// Neutral RSI value</span>
                }
                
                state &lt;= VALIDATE;
            <span class="hljs-keyword">end</span>
            
            VALIDATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Result validation</span>
                <span class="hljs-keyword">if</span> (rsi &gt; <span class="hljs-number">100</span>) <span class="hljs-keyword">begin</span>
                    rsi &lt;= <span class="hljs-number">100</span>;  <span class="hljs-comment">// Clamp to valid range</span>
                <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rsi &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                    rsi &lt;= <span class="hljs-number">0</span>;    <span class="hljs-comment">// Clamp to valid range</span>
                <span class="hljs-keyword">end</span>
                
                state &lt;= DONE;
            <span class="hljs-keyword">end</span>
            
            DONE: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">1</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Key capabilities:</p>
<ul>
<li>Proper initialization handling</li>
<li>Warm-up period management</li>
<li>Multiple edge case detection</li>
<li>Special condition handling</li>
<li>Result validation</li>
</ul>
<p><strong>Edge Case Handling Comparison</strong>:</p>
<table>
<thead>
<tr>
<th>Edge Case Category</th>
<th>Basic Approach</th>
<th>Comprehensive Approach</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initialization</td>
<td>Simple reset</td>
<td>Phased initialization</td>
</tr>
<tr>
<td>No Price Movement</td>
<td>Limited handling</td>
<td>Explicit detection</td>
</tr>
<tr>
<td>All Gains/Losses</td>
<td>Partial handling</td>
<td>Complete handling</td>
</tr>
<tr>
<td>Boundary Values</td>
<td>None</td>
<td>Result clamping</td>
</tr>
<tr>
<td>Minimum Movement</td>
<td>None</td>
<td>Significance threshold</td>
</tr>
<tr>
<td>Warm-up Period</td>
<td>None</td>
<td>Explicit handling</td>
</tr>
</tbody>
</table>
<p><strong>Critical Edge Cases in Technical Analysis</strong>:</p>
<ol>
<li>
<p><strong>Initialization Period</strong>:</p>
<ul>
<li>Insufficient data for calculation</li>
<li>First valid result determination</li>
<li>Handling partial windows</li>
<li>Initial reference values</li>
<li>Warm-up period indication</li>
</ul>
</li>
<li>
<p><strong>Extreme Market Conditions</strong>:</p>
<ul>
<li>All prices increasing/decreasing</li>
<li>No price movement periods</li>
<li>Minimum significant movement</li>
<li>Maximum/minimum value handling</li>
<li>Result boundary conditions</li>
</ul>
</li>
<li>
<p><strong>Calculation Edge Cases</strong>:</p>
<ul>
<li>Division by zero prevention</li>
<li>Overflow/underflow conditions</li>
<li>Minimum precision requirements</li>
<li>Insignificant change filtering</li>
<li>Result range validation</li>
</ul>
</li>
<li>
<p><strong>Operational Transitions</strong>:</p>
<ul>
<li>Market open/close handling</li>
<li>Trading session boundaries</li>
<li>Data gap management</li>
<li>Instrument suspension periods</li>
<li>Calendar event adjustments</li>
</ul>
</li>
</ol>
<p>The current technical analysis system implements moderate edge case handling, focusing on critical aspects like division by zero protection and extreme value management, while maintaining relatively straightforward state machines. This approach balances robustness with implementation complexity, appropriate for the reliable execution of well-defined calculations.</p>
<h4 id="resource-utilization-impact">Resource Utilization Impact</h4>
<p>State machine complexity directly affects resource utilization:</p>
<p><strong>Simple State Machine Resources</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Simple 3-state machine</span>
<span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, CALCULATE = <span class="hljs-number">1</span>, DONE = <span class="hljs-number">2</span>;
<span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state = IDLE;  <span class="hljs-comment">// 2-bit state register</span>
</div></code></pre>
<p>Resource requirements:</p>
<ul>
<li>State Register: 2 bits</li>
<li>Next State Logic: ~4-6 LUTs</li>
<li>Output Logic: ~4-8 LUTs</li>
<li>Total Flip-Flops: 2 + output registers</li>
<li>Total LUTs: ~10-15</li>
<li>Control Signals: 1-2</li>
</ul>
<p><strong>Complex State Machine Resources</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Complex state machine</span>
<span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, INIT = <span class="hljs-number">1</span>, CHECK = <span class="hljs-number">2</span>, PROCESS = <span class="hljs-number">3</span>, 
           CALCULATE = <span class="hljs-number">4</span>, VALIDATE = <span class="hljs-number">5</span>, DONE = <span class="hljs-number">6</span>, ERROR = <span class="hljs-number">7</span>;
<span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = IDLE;  <span class="hljs-comment">// 3-bit state register</span>

<span class="hljs-comment">// Additional control registers</span>
<span class="hljs-keyword">reg</span> initialization_complete = <span class="hljs-number">0</span>;
<span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] sample_count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] error_code = <span class="hljs-number">0</span>;
<span class="hljs-keyword">reg</span> processing_phase = <span class="hljs-number">0</span>;
</div></code></pre>
<p>Resource requirements:</p>
<ul>
<li>State Register: 3 bits</li>
<li>Next State Logic: ~12-20 LUTs</li>
<li>Output Logic: ~15-25 LUTs</li>
<li>Additional Control Registers: ~10-15 bits</li>
<li>Total Flip-Flops: 15-20 + output registers</li>
<li>Total LUTs: ~30-50</li>
<li>Control Signals: 5-10</li>
</ul>
<p><strong>State Encoding Impact</strong>:</p>
<table>
<thead>
<tr>
<th>Encoding Method</th>
<th>State Bits</th>
<th>LUT Usage</th>
<th>Characteristics</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binary (default)</td>
<td>log2(states)</td>
<td>Moderate</td>
<td>Balanced</td>
</tr>
<tr>
<td>One-hot</td>
<td>states</td>
<td>Higher</td>
<td>Clear, fast</td>
</tr>
<tr>
<td>Gray code</td>
<td>log2(states)</td>
<td>Moderate</td>
<td>Glitch-free</td>
</tr>
<tr>
<td>Custom</td>
<td>varies</td>
<td>Varies</td>
<td>Application-specific</td>
</tr>
</tbody>
</table>
<p>For an 8-state machine:</p>
<ul>
<li>Binary: 3 bits, ~15-25 LUTs</li>
<li>One-hot: 8 bits, ~20-30 LUTs</li>
<li>Gray code: 3 bits, ~15-25 LUTs</li>
</ul>
<p><strong>State Machine Scaling Analysis</strong>:</p>
<table>
<thead>
<tr>
<th>State Count</th>
<th>Register Bits</th>
<th>LUT Usage</th>
<th>Control FF</th>
<th>Total Resources</th>
</tr>
</thead>
<tbody>
<tr>
<td>2-4 states</td>
<td>2 bits</td>
<td>8-15 LUTs</td>
<td>2-4 bits</td>
<td>Minimal</td>
</tr>
<tr>
<td>5-8 states</td>
<td>3 bits</td>
<td>15-30 LUTs</td>
<td>5-10 bits</td>
<td>Low</td>
</tr>
<tr>
<td>9-16 states</td>
<td>4 bits</td>
<td>25-50 LUTs</td>
<td>10-20 bits</td>
<td>Moderate</td>
</tr>
<tr>
<td>17-32 states</td>
<td>5 bits</td>
<td>40-80 LUTs</td>
<td>15-30 bits</td>
<td>High</td>
</tr>
<tr>
<td>32+ states</td>
<td>6+ bits</td>
<td>70-150+ LUTs</td>
<td>20-50+ bits</td>
<td>Very High</td>
</tr>
</tbody>
</table>
<p><strong>Feature Resource Impact</strong>:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Register Impact</th>
<th>LUT Impact</th>
<th>Overall Impact</th>
</tr>
</thead>
<tbody>
<tr>
<td>Error Detection</td>
<td>3-5 bits</td>
<td>5-10 LUTs</td>
<td>Low-Moderate</td>
</tr>
<tr>
<td>Error Recovery</td>
<td>5-10 bits</td>
<td>10-20 LUTs</td>
<td>Moderate</td>
</tr>
<tr>
<td>Edge Case Handling</td>
<td>5-10 bits</td>
<td>10-20 LUTs</td>
<td>Moderate</td>
</tr>
<tr>
<td>Status Reporting</td>
<td>3-5 bits</td>
<td>5-10 LUTs</td>
<td>Low-Moderate</td>
</tr>
<tr>
<td>Configuration Options</td>
<td>3-5 bits</td>
<td>10-15 LUTs</td>
<td>Moderate</td>
</tr>
<tr>
<td>Advanced Control</td>
<td>5-10 bits</td>
<td>15-25 LUTs</td>
<td>Moderate-High</td>
</tr>
</tbody>
</table>
<p><strong>Resource Optimization Techniques</strong>:</p>
<ol>
<li>
<p><strong>State Minimization</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Combining similar states</span>
<span class="hljs-keyword">if</span> (state == CHECK || state == VALIDATE) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Common functionality</span>
    <span class="hljs-keyword">if</span> (condition1)
        next_state = PROCESS;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2)
        next_state = ERROR;
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>Merge states with similar transitions</li>
<li>Eliminate unnecessary states</li>
<li>Simplify transition conditions</li>
<li>Reduce state register width</li>
<li>Minimize next-state logic</li>
</ul>
</li>
<li>
<p><strong>Efficient State Encoding</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Optimized state encoding for common transitions</span>
<span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">3&#x27;b000</span>, PROC1 = <span class="hljs-number">3&#x27;b001</span>, PROC2 = <span class="hljs-number">3&#x27;b011</span>;
</div></code></pre>
<ul>
<li>Choose encoding to minimize bit changes</li>
<li>Position related states with similar encodings</li>
<li>Optimize for common transitions</li>
<li>Consider FPGA architecture</li>
<li>Balance encoding complexity</li>
</ul>
</li>
</ol>
<p>The technical analysis system balances state machine complexity with resource utilization, implementing relatively simple state machines with focused functionality. This approach minimizes resource usage while providing the necessary features for reliable indicator calculation and trading signal generation.</p>
<h4 id="verification-complexity-considerations">Verification Complexity Considerations</h4>
<p>State machine complexity significantly impacts verification effort:</p>
<p><strong>Simple State Machine Verification</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Simple 3-state machine testbench</span>
<span class="hljs-keyword">module</span> simple_ma_fsm_tb;
    <span class="hljs-comment">// Testbench signals</span>
    <span class="hljs-keyword">reg</span> clk = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> rst = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> start = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] new_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] oldest_price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg;
    <span class="hljs-keyword">wire</span> done;
    
    <span class="hljs-comment">// DUT instantiation</span>
    moving_average_fsm dut (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.start</span>(start),
        <span class="hljs-variable">.new_price</span>(new_price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.moving_avg</span>(moving_avg),
        <span class="hljs-variable">.done</span>(done)
    );
    
    <span class="hljs-comment">// Clock generation</span>
    <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;
    
    <span class="hljs-comment">// Test sequence</span>
    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Reset</span>
        rst = <span class="hljs-number">1</span>;
        #<span class="hljs-number">20</span> rst = <span class="hljs-number">0</span>;
        
        <span class="hljs-comment">// Test case 1: Basic calculation</span>
        #<span class="hljs-number">10</span> new_price = <span class="hljs-number">100</span>;
        oldest_price = <span class="hljs-number">80</span>;
        start = <span class="hljs-number">1</span>;
        #<span class="hljs-number">10</span> start = <span class="hljs-number">0</span>;
        
        <span class="hljs-comment">// Wait for completion</span>
        <span class="hljs-keyword">wait</span>(done);
        
        <span class="hljs-comment">// Verify result</span>
        <span class="hljs-keyword">if</span> (moving_avg == (<span class="hljs-number">100</span>-<span class="hljs-number">80</span>)/<span class="hljs-number">20</span>)
            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Test passed&quot;</span>);
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Test failed&quot;</span>);
        
        <span class="hljs-comment">// End simulation</span>
        #<span class="hljs-number">100</span> <span class="hljs-built_in">$finish</span>;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Verification characteristics:</p>
<ul>
<li>Few test cases required</li>
<li>Simple expected outcomes</li>
<li>Linear execution path</li>
<li>Limited state coverage</li>
<li>Straightforward assertions</li>
</ul>
<p><strong>Complex State Machine Verification</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Complex state machine testbench</span>
<span class="hljs-keyword">module</span> complex_rsi_fsm_tb;
    <span class="hljs-comment">// Testbench signals</span>
    <span class="hljs-keyword">reg</span> clk = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> rst = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> start = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rsi;
    <span class="hljs-keyword">wire</span> done;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] error_code;
    <span class="hljs-keyword">wire</span> error_active;
    
    <span class="hljs-comment">// DUT instantiation</span>
    complex_rsi_fsm dut (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.start</span>(start),
        <span class="hljs-variable">.price</span>(price),
        <span class="hljs-variable">.rsi</span>(rsi),
        <span class="hljs-variable">.done</span>(done),
        <span class="hljs-variable">.error_code</span>(error_code),
        <span class="hljs-variable">.error_active</span>(error_active)
    );
    
    <span class="hljs-comment">// Clock generation</span>
    <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;
    
    <span class="hljs-comment">// State monitoring</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] prev_state;
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)
        prev_state &lt;= dut<span class="hljs-variable">.state</span>;
    
    <span class="hljs-comment">// Test configuration</span>
    <span class="hljs-keyword">int</span> test_cases_run = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> test_cases_passed = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Assertion monitoring</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// State transition checks</span>
        <span class="hljs-keyword">if</span> (dut<span class="hljs-variable">.state</span> != prev_state) <span class="hljs-keyword">begin</span>
            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;State transition: %d -&gt; %d at time %t&quot;</span>, 
                    prev_state, dut<span class="hljs-variable">.state</span>, <span class="hljs-built_in">$time</span>);
            
            <span class="hljs-comment">// Validate legal transitions</span>
            <span class="hljs-keyword">case</span> (prev_state)
                <span class="hljs-number">0</span>: <span class="hljs-keyword">assert</span>(dut<span class="hljs-variable">.state</span> <span class="hljs-keyword">inside</span> {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}) 
                    <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;Invalid transition from IDLE&quot;</span>);
                <span class="hljs-comment">// Additional state checks...</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
        
        <span class="hljs-comment">// Data integrity checks</span>
        <span class="hljs-keyword">if</span> (dut<span class="hljs-variable">.gain_sum</span> + dut<span class="hljs-variable">.loss_sum</span> &lt; dut<span class="hljs-variable">.gain_sum</span>)
            <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;Overflow detected in accumulation&quot;</span>);
        
        <span class="hljs-comment">// Protocol checks</span>
        <span class="hljs-keyword">if</span> (done &amp;&amp; dut<span class="hljs-variable">.state</span> != <span class="hljs-number">6</span>)
            <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;Done signal asserted in invalid state&quot;</span>);
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Define extensive test cases</span>
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
        <span class="hljs-keyword">string</span> name;
        <span class="hljs-keyword">bit</span> reset_first;
        <span class="hljs-keyword">int</span> num_prices;
        <span class="hljs-keyword">int</span> price_sequence[];
        <span class="hljs-keyword">bit</span> expect_error;
        <span class="hljs-keyword">int</span> expected_rsi;
        <span class="hljs-keyword">int</span> tolerance;
    } TestCase;
    
    TestCase test_cases[] = {
        <span class="hljs-comment">// Normal operation</span>
        {name: <span class="hljs-string">&quot;Basic calculation&quot;</span>, reset_first: <span class="hljs-number">1</span>, num_prices: <span class="hljs-number">15</span>,
         price_sequence: &#x27;{<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">101</span>, <span class="hljs-number">103</span>, <span class="hljs-number">102</span>, <span class="hljs-number">104</span>, <span class="hljs-number">103</span>, <span class="hljs-number">105</span>, <span class="hljs-number">104</span>,
                          <span class="hljs-number">106</span>, <span class="hljs-number">105</span>, <span class="hljs-number">107</span>, <span class="hljs-number">106</span>, <span class="hljs-number">108</span>},
         expect_error: <span class="hljs-number">0</span>, expected_rsi: <span class="hljs-number">50</span>, tolerance: <span class="hljs-number">2</span>},
         
        <span class="hljs-comment">// Edge case: All rising prices</span>
        {name: <span class="hljs-string">&quot;All rising&quot;</span>, reset_first: <span class="hljs-number">1</span>, num_prices: <span class="hljs-number">15</span>,
         price_sequence: &#x27;{<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>, <span class="hljs-number">108</span>, <span class="hljs-number">109</span>,
                          <span class="hljs-number">110</span>, <span class="hljs-number">111</span>, <span class="hljs-number">112</span>, <span class="hljs-number">113</span>, <span class="hljs-number">114</span>},
         expect_error: <span class="hljs-number">0</span>, expected_rsi: <span class="hljs-number">100</span>, tolerance: <span class="hljs-number">0</span>},
         
        <span class="hljs-comment">// Edge case: All falling prices</span>
        {name: <span class="hljs-string">&quot;All falling&quot;</span>, reset_first: <span class="hljs-number">1</span>, num_prices: <span class="hljs-number">15</span>,
         price_sequence: &#x27;{<span class="hljs-number">114</span>, <span class="hljs-number">113</span>, <span class="hljs-number">112</span>, <span class="hljs-number">111</span>, <span class="hljs-number">110</span>, <span class="hljs-number">109</span>, <span class="hljs-number">108</span>, <span class="hljs-number">107</span>, <span class="hljs-number">106</span>, <span class="hljs-number">105</span>,
                          <span class="hljs-number">104</span>, <span class="hljs-number">103</span>, <span class="hljs-number">102</span>, <span class="hljs-number">101</span>, <span class="hljs-number">100</span>},
         expect_error: <span class="hljs-number">0</span>, expected_rsi: <span class="hljs-number">0</span>, tolerance: <span class="hljs-number">0</span>},
         
        <span class="hljs-comment">// Edge case: No price change</span>
        {name: <span class="hljs-string">&quot;No change&quot;</span>, reset_first: <span class="hljs-number">1</span>, num_prices: <span class="hljs-number">15</span>,
         price_sequence: &#x27;{<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>,
                          <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>},
         expect_error: <span class="hljs-number">0</span>, expected_rsi: <span class="hljs-number">50</span>, tolerance: <span class="hljs-number">0</span>},
         
        <span class="hljs-comment">// Error case: Invalid price</span>
        {name: <span class="hljs-string">&quot;Invalid price&quot;</span>, reset_first: <span class="hljs-number">1</span>, num_prices: <span class="hljs-number">5</span>,
         price_sequence: &#x27;{<span class="hljs-number">100</span>, <span class="hljs-number">65535</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>},
         expect_error: <span class="hljs-number">1</span>, expected_rsi: <span class="hljs-number">0</span>, tolerance: <span class="hljs-number">0</span>}
    };
    
    <span class="hljs-comment">// Test execution task</span>
    <span class="hljs-keyword">task</span> run_test_case(TestCase tc);
        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Running test case: %s&quot;</span>, tc<span class="hljs-variable">.name</span>);
        test_cases_run++;
        
        <span class="hljs-keyword">if</span> (tc<span class="hljs-variable">.reset_first</span>) <span class="hljs-keyword">begin</span>
            rst = <span class="hljs-number">1</span>;
            #<span class="hljs-number">20</span> rst = <span class="hljs-number">0</span>;
            #<span class="hljs-number">10</span>;
        <span class="hljs-keyword">end</span>
        
        <span class="hljs-comment">// Apply price sequence</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tc<span class="hljs-variable">.num_prices</span>; i++) <span class="hljs-keyword">begin</span>
            price = tc<span class="hljs-variable">.price_sequence</span>[i];
            start = <span class="hljs-number">1</span>;
            #<span class="hljs-number">10</span> start = <span class="hljs-number">0</span>;
            
            <span class="hljs-comment">// Wait for completion or error</span>
            <span class="hljs-keyword">wait</span>(done || error_active);
            #<span class="hljs-number">10</span>;
        <span class="hljs-keyword">end</span>
        
        <span class="hljs-comment">// Verify results</span>
        <span class="hljs-keyword">if</span> (tc<span class="hljs-variable">.expect_error</span> &amp;&amp; error_active) <span class="hljs-keyword">begin</span>
            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Test passed: Expected error detected&quot;</span>);
            test_cases_passed++;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tc<span class="hljs-variable">.expect_error</span> &amp;&amp; !error_active &amp;&amp;
                    (rsi &gt;= tc<span class="hljs-variable">.expected_rsi</span> - tc<span class="hljs-variable">.tolerance</span>) &amp;&amp;
                    (rsi &lt;= tc<span class="hljs-variable">.expected_rsi</span> + tc<span class="hljs-variable">.tolerance</span>)) <span class="hljs-keyword">begin</span>
            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Test passed: RSI = %d (expected %d +/- %d)&quot;</span>,
                    rsi, tc<span class="hljs-variable">.expected_rsi</span>, tc<span class="hljs-variable">.tolerance</span>);
            test_cases_passed++;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Test failed: RSI = %d, error = %d (expected RSI = %d +/- %d, error = %d)&quot;</span>,
                    rsi, error_active, tc<span class="hljs-variable">.expected_rsi</span>, tc<span class="hljs-variable">.tolerance</span>, tc<span class="hljs-variable">.expect_error</span>);
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endtask</span>
    
    <span class="hljs-comment">// Test sequence</span>
    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
        <span class="hljs-comment">// Run all test cases</span>
        <span class="hljs-keyword">foreach</span> (test_cases[i])
            run_test_case(test_cases[i]);
        
        <span class="hljs-comment">// Report results</span>
        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Tests complete: %d/%d passed&quot;</span>, test_cases_passed, test_cases_run);
        #<span class="hljs-number">100</span> <span class="hljs-built_in">$finish</span>;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>Verification characteristics:</p>
<ul>
<li>Numerous test cases required</li>
<li>Complex expected outcomes</li>
<li>Multiple execution paths</li>
<li>Comprehensive state coverage</li>
<li>Advanced assertions</li>
</ul>
<p><strong>Verification Complexity Factors</strong>:</p>
<table>
<thead>
<tr>
<th>Complexity Factor</th>
<th>Simple FSM</th>
<th>Complex FSM</th>
</tr>
</thead>
<tbody>
<tr>
<td>State Count</td>
<td>3-4 states</td>
<td>8+ states</td>
</tr>
<tr>
<td>Transition Paths</td>
<td>3-5 paths</td>
<td>15+ paths</td>
</tr>
<tr>
<td>Test Cases</td>
<td>2-5 cases</td>
<td>10-20+ cases</td>
</tr>
<tr>
<td>Edge Cases</td>
<td>1-2 cases</td>
<td>5-10+ cases</td>
</tr>
<tr>
<td>Assertions</td>
<td>2-5 assertions</td>
<td>10-20+ assertions</td>
</tr>
<tr>
<td>Simulation Time</td>
<td>Short</td>
<td>Extended</td>
</tr>
</tbody>
</table>
<p><strong>Verification Methodologies for Different Complexities</strong>:</p>
<ol>
<li>
<p><strong>Directed Testing (Simple FSMs)</strong>:</p>
<ul>
<li>Manual test case definition</li>
<li>Predictable execution paths</li>
<li>Limited state space exploration</li>
<li>Focused result verification</li>
<li>Minimal testbench infrastructure</li>
</ul>
</li>
<li>
<p><strong>Coverage-Driven Verification (Complex FSMs)</strong>:</p>
<ul>
<li>Systematic coverage goals</li>
<li>State/transition coverage</li>
<li>Comprehensive test plan</li>
<li>Automated test generation</li>
<li>Advanced testbench architecture</li>
</ul>
</li>
<li>
<p><strong>Formal Verification (Both)</strong>:</p>
<ul>
<li>Property specification</li>
<li>Exhaustive state space analysis</li>
<li>Automatic counterexample generation</li>
<li>Comprehensive verification</li>
<li>Tool-specific implementation</li>
</ul>
</li>
</ol>
<p><strong>State Machine Verification Metrics</strong>:</p>
<table>
<thead>
<tr>
<th>Verification Metric</th>
<th>Calculation</th>
<th>Simple Example</th>
<th>Complex Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>State Coverage</td>
<td>states_visited / total_states</td>
<td>3/3 (100%)</td>
<td>6/8 (75%)</td>
</tr>
<tr>
<td>Transition Coverage</td>
<td>transitions_covered / possible_transitions</td>
<td>3/3 (100%)</td>
<td>12/20 (60%)</td>
</tr>
<tr>
<td>Path Coverage</td>
<td>paths_tested / possible_paths</td>
<td>1/1 (100%)</td>
<td>4/10+ (40%)</td>
</tr>
<tr>
<td>Edge Case Coverage</td>
<td>edge_cases_tested / identified_edge_cases</td>
<td>1/2 (50%)</td>
<td>6/10 (60%)</td>
</tr>
<tr>
<td>Code Coverage</td>
<td>lines_executed / total_lines</td>
<td>15/20 (75%)</td>
<td>80/150 (53%)</td>
</tr>
</tbody>
</table>
<p>The current technical analysis system balances state machine complexity with verification effort, implementing relatively straightforward state machines that can be thoroughly verified with reasonable effort. This approach ensures system reliability while maintaining manageable verification complexity.</p>
<h4 id="recommended-design-patterns">Recommended Design Patterns</h4>
<p>Based on the analysis of state machine complexity tradeoffs, several recommended design patterns emerge:</p>
<p><strong>1. Layered State Machine Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> layered_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Top-level control state machine (simple)</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, ACTIVE = <span class="hljs-number">1</span>, DONE = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] control_state = IDLE;
    
    <span class="hljs-comment">// Processing state machine (more complex)</span>
    <span class="hljs-keyword">localparam</span> INIT = <span class="hljs-number">0</span>, PROC1 = <span class="hljs-number">1</span>, PROC2 = <span class="hljs-number">2</span>, PROC3 = <span class="hljs-number">3</span>, FINISH = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] proc_state = INIT;
    
    <span class="hljs-comment">// Top-level control FSM</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (control_state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (start) <span class="hljs-keyword">begin</span>
                    control_state &lt;= ACTIVE;
                    proc_state &lt;= INIT;  <span class="hljs-comment">// Initialize processing FSM</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            ACTIVE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Processing FSM completion detection</span>
                <span class="hljs-keyword">if</span> (proc_state == FINISH) <span class="hljs-keyword">begin</span>
                    control_state &lt;= DONE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            DONE: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">1</span>;
                control_state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Processing FSM - only active when in ACTIVE control state</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (control_state == ACTIVE) <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (proc_state)
                INIT: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Initialization</span>
                    proc_state &lt;= PROC1;
                <span class="hljs-keyword">end</span>
                
                PROC1, PROC2, PROC3: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Processing steps</span>
                    <span class="hljs-comment">// ...</span>
                    proc_state &lt;= proc_state + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">end</span>
                
                FINISH: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Finalization</span>
                    <span class="hljs-comment">// No state transition - detected by control FSM</span>
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This pattern provides:</p>
<ul>
<li>Separation of control and processing logic</li>
<li>Simple top-level state machine for interface</li>
<li>Detailed processing state machine for functionality</li>
<li>Clear boundary between interface and implementation</li>
<li>Simplified verification of each layer</li>
</ul>
<p><strong>2. Modular State Machine Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> modular_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Core functionality in separate module</span>
    <span class="hljs-keyword">wire</span> internal_done;
    <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] internal_result;
    
    calculation_core calculator (
        <span class="hljs-variable">.clk</span>(clk),
        <span class="hljs-variable">.rst</span>(rst),
        <span class="hljs-variable">.start</span>(internal_start),
        <span class="hljs-variable">.new_price</span>(new_price),
        <span class="hljs-variable">.oldest_price</span>(oldest_price),
        <span class="hljs-variable">.result</span>(internal_result),
        <span class="hljs-variable">.done</span>(internal_done)
    );
    
    <span class="hljs-comment">// Interface state machine</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, VALIDATE = <span class="hljs-number">1</span>, CALCULATE = <span class="hljs-number">2</span>, PROCESS = <span class="hljs-number">3</span>, DONE = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-comment">// Interface FSM</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> (state)
            IDLE: <span class="hljs-keyword">begin</span>
                <span class="hljs-keyword">if</span> (start)
                    state &lt;= VALIDATE;
            <span class="hljs-keyword">end</span>
            
            VALIDATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Input validation</span>
                <span class="hljs-keyword">if</span> (valid_inputs)
                    state &lt;= CALCULATE;
                <span class="hljs-keyword">else</span>
                    state &lt;= DONE;  <span class="hljs-comment">// Skip calculation</span>
            <span class="hljs-keyword">end</span>
            
            CALCULATE: <span class="hljs-keyword">begin</span>
                <span class="hljs-comment">// Trigger core calculation</span>
                internal_start &lt;= <span class="hljs-number">1</span>;
                state &lt;= PROCESS;
            <span class="hljs-keyword">end</span>
            
            PROCESS: <span class="hljs-keyword">begin</span>
                internal_start &lt;= <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (internal_done) <span class="hljs-keyword">begin</span>
                    moving_avg &lt;= internal_result;
                    state &lt;= DONE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
            
            DONE: <span class="hljs-keyword">begin</span>
                done &lt;= <span class="hljs-number">1</span>;
                state &lt;= IDLE;
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This pattern provides:</p>
<ul>
<li>Clean separation of interface and implementation</li>
<li>Reusable calculation core</li>
<li>Simplified interface state machine</li>
<li>Focused testing of each component</li>
<li>Improved maintainability</li>
</ul>
<p><strong>3. Table-Driven State Machine Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> table_driven_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// State definitions</span>
    <span class="hljs-keyword">localparam</span> STATE_COUNT = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, CALCULATE = <span class="hljs-number">1</span>, FILTER = <span class="hljs-number">2</span>, DONE = <span class="hljs-number">3</span>;
    
    <span class="hljs-comment">// Transition table [current_state][input] = next_state</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] next_state_table [<span class="hljs-number">0</span>:STATE_COUNT-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] = {
        {IDLE,      CALCULATE},  <span class="hljs-comment">// IDLE transitions</span>
        {CALCULATE, FILTER},     <span class="hljs-comment">// CALCULATE transitions</span>
        {FILTER,    DONE},       <span class="hljs-comment">// FILTER transitions</span>
        {DONE,      IDLE}        <span class="hljs-comment">// DONE transitions</span>
    };
    
    <span class="hljs-comment">// Output table [state] = {output1, output2, ...}</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] output_table [<span class="hljs-number">0</span>:STATE_COUNT-<span class="hljs-number">1</span>] = {
        <span class="hljs-number">3&#x27;b000</span>,  <span class="hljs-comment">// IDLE outputs</span>
        <span class="hljs-number">3&#x27;b010</span>,  <span class="hljs-comment">// CALCULATE outputs</span>
        <span class="hljs-number">3&#x27;b100</span>,  <span class="hljs-comment">// FILTER outputs</span>
        <span class="hljs-number">3&#x27;b001</span>   <span class="hljs-comment">// DONE outputs</span>
    };
    
    <span class="hljs-comment">// State register</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-comment">// Next state logic</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (rst)
            state &lt;= IDLE;
        <span class="hljs-keyword">else</span>
            state &lt;= next_state_table[state][start];
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Output logic</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        {calculating, filtering, done} &lt;= output_table[state];
    <span class="hljs-keyword">end</span>
    
    <span class="hljs-comment">// Data path (separate from state control)</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (calculating)
            sum &lt;= sum + new_price - oldest_price;
            
        <span class="hljs-keyword">if</span> (filtering)
            moving_avg &lt;= sum / WINDOW;
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This pattern provides:</p>
<ul>
<li>Clear separation of control and datapath</li>
<li>Tabular representation of state transitions</li>
<li>Simplified maintenance of complex state machines</li>
<li>Explicit output encoding</li>
<li>Improved readability for complex machines</li>
</ul>
<p><strong>4. Error-Handling State Machine Pattern</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">module</span> error_handling_fsm #(
    <span class="hljs-keyword">parameter</span> WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> DW = <span class="hljs-number">16</span>
)(
    <span class="hljs-comment">// Ports...</span>
);
    <span class="hljs-comment">// Main processing state machine</span>
    <span class="hljs-keyword">localparam</span> IDLE = <span class="hljs-number">0</span>, CALCULATE = <span class="hljs-number">1</span>, DONE = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] state = IDLE;
    
    <span class="hljs-comment">// Error handling state machine</span>
    <span class="hljs-keyword">localparam</span> ERR_NONE = <span class="hljs-number">0</span>, ERR_DETECTED = <span class="hljs-number">1</span>, ERR_HANDLING = <span class="hljs-number">2</span>, ERR_RECOVERY = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] error_state = ERR_NONE;
    
    <span class="hljs-comment">// Error code register</span>
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] error_code = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Main FSM only active when no errors</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">if</span> (error_state == ERR_NONE) <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (state)
                IDLE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> (start)
                        state &lt;= CALCULATE;
                <span class="hljs-keyword">end</span>
                
                CALCULATE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Check for error conditions</span>
                    <span class="hljs-keyword">if</span> (new_price &gt; MAX_VALID_PRICE) <span class="hljs-keyword">begin</span>
                        error_state &lt;= ERR_DETECTED;
                        error_code &lt;= <span class="hljs-number">3&#x27;b001</span>;  <span class="hljs-comment">// Invalid price</span>
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WINDOW == <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
                        error_state &lt;= ERR_DETECTED;
                        error_code &lt;= <span class="hljs-number">3&#x27;b010</span>;  <span class="hljs-comment">// Divide by zero</span>
                    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
                        <span class="hljs-comment">// Normal calculation</span>
                        sum &lt;= sum + new_price - oldest_price;
                        moving_avg &lt;= sum / WINDOW;
                        state &lt;= DONE;
                    <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">end</span>
                
                DONE: <span class="hljs-keyword">begin</span>
                    done &lt;= <span class="hljs-number">1</span>;
                    state &lt;= IDLE;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-comment">// Error handling FSM</span>
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst) <span class="hljs-keyword">begin</span> <span class="hljs-comment">// Added reset sensitivity</span>
        <span class="hljs-keyword">if</span> (rst) <span class="hljs-keyword">begin</span> <span class="hljs-comment">// Reset condition for error FSM</span>
            error_state &lt;= ERR_NONE;
            error_code &lt;= <span class="hljs-number">0</span>;
            error_active &lt;= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">case</span> (error_state)
                ERR_NONE: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Normal operation, main FSM is active</span>
                    <span class="hljs-comment">// Error detection happens within the main FSM states</span>
                <span class="hljs-keyword">end</span>

                ERR_DETECTED: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Error detected by main FSM, signal error</span>
                    error_active &lt;= <span class="hljs-number">1</span>;
                    <span class="hljs-comment">// Optionally pause main FSM or reset it to IDLE</span>
                    state &lt;= IDLE; <span class="hljs-comment">// Ensure main FSM stops processing</span>
                    error_state &lt;= ERR_HANDLING;
                    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;[%t] Error detected: code %d&quot;</span>, <span class="hljs-built_in">$time</span>, error_code);
                <span class="hljs-keyword">end</span>

                ERR_HANDLING: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Wait for acknowledgment or implement automatic recovery timeout</span>
                    <span class="hljs-comment">// Example: wait for error_ack signal</span>
                    <span class="hljs-keyword">if</span> (error_ack) <span class="hljs-keyword">begin</span>
                        error_state &lt;= ERR_RECOVERY;
                    <span class="hljs-keyword">end</span>
                    <span class="hljs-comment">// Could add a timeout counter here</span>
                    <span class="hljs-comment">// if (timeout_counter &gt; MAX_WAIT_CYCLES) begin</span>
                    <span class="hljs-comment">//     error_state &lt;= ERR_RECOVERY; // Auto-recover after timeout</span>
                    <span class="hljs-comment">// end</span>
                <span class="hljs-keyword">end</span>

                ERR_RECOVERY: <span class="hljs-keyword">begin</span>
                    <span class="hljs-comment">// Perform recovery actions based on error code</span>
                    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;[%t] Recovering from error: code %d&quot;</span>, <span class="hljs-built_in">$time</span>, error_code);
                    <span class="hljs-keyword">case</span> (error_code)
                        <span class="hljs-number">3&#x27;b001</span>: <span class="hljs-keyword">begin</span> <span class="hljs-comment">// Invalid price</span>
                            <span class="hljs-comment">// Option 1: Log and continue, skipping the data point.</span>
                            <span class="hljs-comment">// Option 2: Use last valid price or default.</span>
                            <span class="hljs-comment">// Option 3: Reset relevant calculation state.</span>
                            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Recovery Action: Skipped invalid price data.&quot;</span>);
                        <span class="hljs-keyword">end</span>
                        <span class="hljs-number">3&#x27;b010</span>: <span class="hljs-keyword">begin</span> <span class="hljs-comment">// Divide by zero</span>
                            <span class="hljs-comment">// Option 1: Set result to a default value (e.g., 0 or max).</span>
                            <span class="hljs-comment">// Option 2: Use previous valid result.</span>
                            <span class="hljs-comment">// Option 3: Signal invalid output.</span>
                            moving_avg &lt;= <span class="hljs-number">0</span>; <span class="hljs-comment">// Example: Set output to 0</span>
                            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Recovery Action: Set MA to 0 due to divide by zero attempt.&quot;</span>);
                        <span class="hljs-keyword">end</span>
                        <span class="hljs-comment">// Add more error codes and recovery actions as needed</span>
                        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">begin</span>
                            <span class="hljs-comment">// Generic recovery, e.g., reset calculation state</span>
                            sum &lt;= <span class="hljs-number">0</span>;
                            moving_avg &lt;= <span class="hljs-number">0</span>;
                            <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;Recovery Action: Performed generic reset.&quot;</span>);
                        <span class="hljs-keyword">end</span>
                    <span class="hljs-keyword">endcase</span>

                    <span class="hljs-comment">// Clear error status and return to normal operation</span>
                    error_active &lt;= <span class="hljs-number">0</span>;
                    error_code &lt;= <span class="hljs-number">0</span>;
                    error_state &lt;= ERR_NONE;
                    state &lt;= IDLE; <span class="hljs-comment">// Ensure main FSM is ready to restart from IDLE</span>
                <span class="hljs-keyword">end</span>

                <span class="hljs-keyword">default</span>: error_state &lt;= ERR_NONE; <span class="hljs-comment">// Safe default transition</span>
            <span class="hljs-keyword">endcase</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>This pattern provides:</p>
<ul>
<li>Clear separation between normal operation and error handling</li>
<li>Dedicated states for error detection, handling, and recovery</li>
<li>Error classification through error codes</li>
<li>Flexible recovery mechanisms</li>
<li>Improved system robustness</li>
</ul>
<p>These recommended design patterns offer structured approaches to managing state machine complexity, balancing functionality, maintainability, and resource utilization. Choosing the right pattern depends on the specific requirements of the module and the overall system architecture.</p>
<h3 id="memory-resource-optimization">Memory Resource Optimization</h3>
<p>The trading system implementation employs several strategies for optimizing memory resource utilization on FPGA platforms:</p>
<ol>
<li>
<p><strong>FIFO Buffer Reuse</strong>:</p>
<ul>
<li>The price memory module serves as a shared data source for both the Moving Average and RSI calculation modules</li>
<li>This centralized price history approach eliminates redundant storage of the same price data</li>
<li>Both indicator modules access the same physical memory, reducing block RAM usage</li>
</ul>
</li>
<li>
<p><strong>Register Repurposing</strong>:</p>
<ul>
<li>Temporary registers are reused across different FSM states rather than creating dedicated registers for each operation</li>
<li>For example, in the RSI FSM, the <code>curr_price</code> and <code>prev_price</code> registers are reused throughout the calculation process</li>
</ul>
</li>
<li>
<p><strong>Sequential vs. Parallel Processing</strong>:</p>
<ul>
<li>The implementation balances sequential and parallel processing to optimize resource utilization</li>
<li>Critical operations (MA and RSI calculations) occur in parallel to maximize throughput</li>
<li>Non-critical operations (like storing data and state transitions) occur sequentially to conserve resources</li>
</ul>
</li>
<li>
<p><strong>Distributed RAM Usage</strong>:</p>
<ul>
<li>For small memory structures like the price FIFO, distributed RAM (implemented using LUTs) is preferred over block RAM</li>
<li>This approach is particularly effective for FIFOs with depth  32 and width  32 bits</li>
<li>Enables efficient resource utilization while maintaining high-speed access</li>
</ul>
</li>
</ol>
<h3 id="computational-unit-sharing">Computational Unit Sharing</h3>
<p>The system implements strategic sharing of computational resources to maximize efficiency:</p>
<ol>
<li>
<p><strong>Arithmetic Unit Sharing</strong>:</p>
<ul>
<li>Addition and subtraction operations in the Moving Average FSM are multiplexed using a single hardware adder</li>
<li>The same physical comparator circuits are reused for different comparison operations within the FSM</li>
<li>Division operations, which are resource-intensive, are isolated to specific states to avoid duplication</li>
</ul>
</li>
<li>
<p><strong>Time-Division Multiplexing</strong>:</p>
<ul>
<li>Computational resources are time-multiplexed across different calculation phases</li>
<li>For example, comparators are used for price &gt; prev_price in one state and for sample_cnt &lt; 19 in another state</li>
<li>This approach reduces resource utilization while maintaining functional correctness</li>
</ul>
</li>
<li>
<p><strong>Pipeline Resource Sharing</strong>:</p>
<ul>
<li>The FSM-based design enables sharing of pipeline stages across different computational phases</li>
<li>Each pipeline stage serves multiple purposes depending on the current state</li>
<li>For example, the same registers are reused for storing intermediate results across different calculation steps</li>
</ul>
</li>
</ol>
<h3 id="logic-element-optimization">Logic Element Optimization</h3>
<p>Several techniques are employed to minimize the logic element utilization:</p>
<ol>
<li>
<p><strong>Optimized State Encoding</strong>:</p>
<ul>
<li>Binary encoding is used for FSM states to minimize flip-flop usage</li>
<li>The Moving Average FSM uses a 2-bit state register for 3 states</li>
<li>The RSI FSM uses a 3-bit state register for 6 states</li>
</ul>
</li>
<li>
<p><strong>Flag Consolidation</strong>:</p>
<ul>
<li>Status flags are derived from existing registers where possible</li>
<li>For example, the <code>full</code> status flag is generated directly from the counter value (count == DEPTH)</li>
<li>This approach eliminates the need for dedicated flag registers</li>
</ul>
</li>
<li>
<p><strong>Common Logic Extraction</strong>:</p>
<ul>
<li>Common logic patterns are identified and extracted to reduce redundancy</li>
<li>For instance, address wrap-around logic ((ptr + 1) % DEPTH) is implemented once and reused</li>
<li>Arithmetic operations with similar patterns are consolidated to minimize logic duplication</li>
</ul>
</li>
</ol>
<h2 id="power-optimization-approaches">Power Optimization Approaches</h2>
<h3 id="clock-management-strategies">Clock Management Strategies</h3>
<p>Effective clock management is essential for power-efficient FPGA designs:</p>
<ol>
<li>
<p><strong>Single Clock Domain Design</strong>:</p>
<ul>
<li>The entire system operates in a single clock domain, which eliminates the need for complex clock gating</li>
<li>This approach reduces power consumption by minimizing clock distribution resources</li>
<li>Simplified timing closure and reduced clock buffer utilization</li>
</ul>
</li>
<li>
<p><strong>Conditional Clocking</strong>:</p>
<ul>
<li>State-based clock enabling prevents unnecessary register updates</li>
<li>For example, registers in the RSI module are only updated when relevant to the current state</li>
<li>This significantly reduces dynamic power consumption due to toggling flip-flops</li>
</ul>
</li>
<li>
<p><strong>Clock Speed Optimization</strong>:</p>
<ul>
<li>The system is designed to operate efficiently at moderate clock speeds (100MHz range)</li>
<li>Critical paths are optimized to allow operation at lower frequencies if needed</li>
<li>The calculation latency (3-4 clock cycles) provides margin for timing optimization</li>
</ul>
</li>
</ol>
<h3 id="activity-minimization">Activity Minimization</h3>
<p>Reducing signal toggling is a key strategy for minimizing dynamic power consumption:</p>
<ol>
<li>
<p><strong>Strategic Register Updates</strong>:</p>
<ul>
<li>Registers are only updated when necessary based on state and conditions</li>
<li>For example, the FSM only updates <code>gain_sum</code> when there's an actual gain</li>
<li>This selective updating minimizes power-consuming switching activity</li>
</ul>
</li>
<li>
<p><strong>FIFO Implementation Considerations</strong>:</p>
<ul>
<li>The circular buffer approach in the price memory module minimizes data movement</li>
<li>Only pointers are updated during most operations, not the entire data array</li>
<li>This dramatically reduces switching activity compared to shift register implementations</li>
</ul>
</li>
<li>
<p><strong>Write/Read Enable Control</strong>:</p>
<ul>
<li>FIFO write/read operations are carefully controlled to occur only when necessary</li>
<li>Default state sets <code>fifo_wr_en</code> and <code>fifo_rd_en</code> to 0 at the beginning of each clock cycle</li>
<li>These signals are only asserted when specific conditions are met, reducing buffer activity</li>
</ul>
</li>
<li>
<p><strong>Idle State Power Management</strong>:</p>
<ul>
<li>In the IDLE state, all computational registers maintain their values without toggling</li>
<li>Only the minimal logic required to detect the <code>start</code> signal remains active</li>
<li>This approach significantly reduces power consumption during waiting periods</li>
</ul>
</li>
</ol>
<h3 id="power-aware-coding-practices">Power-Aware Coding Practices</h3>
<p>The Verilog implementation incorporates several power-aware coding practices:</p>
<ol>
<li>
<p><strong>Signal Width Optimization</strong>:</p>
<ul>
<li>Signal widths are carefully sized to minimize unnecessary bits</li>
<li>For example, RSI output is 8-bit (0-100 range) rather than 32-bit</li>
<li>Counter and pointer registers use the minimum required width (e.g., 4-5 bits for small FIFOs)</li>
</ul>
</li>
<li>
<p><strong>Reset Strategy</strong>:</p>
<ul>
<li>Asynchronous resets are used sparingly and only for essential initialization</li>
<li>Not all registers require reset, reducing power-hungry reset tree distribution</li>
<li>Reset signal activates only the minimal set of registers required for proper initialization</li>
</ul>
</li>
<li>
<p><strong>Sequential Logic Patterns</strong>:</p>
<ul>
<li>Case statements with default cases prevent latches</li>
<li>Clear register initialization reduces power during startup</li>
<li>Synchronous design patterns minimize glitching and spurious transitions</li>
</ul>
</li>
<li>
<p><strong>Memory Access Optimization</strong>:</p>
<ul>
<li>Memory read operations only occur when the data is needed</li>
<li>Write operations are batched where possible to minimize memory activity</li>
<li>FIFO depth is precisely sized to application requirements to avoid excessive memory</li>
</ul>
</li>
</ol>
<h2 id="design-considerations-and-tradeoffs">Design Considerations and Tradeoffs</h2>
<h3 id="integer-vs-fixed-point-arithmetic">Integer vs. Fixed-Point Arithmetic</h3>
<p>The implementation currently uses integer arithmetic throughout the design, which presents several tradeoffs:</p>
<h4 id="precision-analysis">Precision Analysis</h4>
<p>Integer arithmetic limits precision in several key areas:</p>
<ol>
<li>
<p><strong>Moving Average Calculation</strong>:</p>
<ul>
<li>Integer division (sum / WINDOW) truncates fractional values</li>
<li>For a 10-point MA with sum = 10005, the result would be 1000 (discarding 0.5)</li>
<li>This can lead to cumulative rounding errors, especially with small price differences</li>
</ul>
</li>
<li>
<p><strong>RSI Calculation</strong>:</p>
<ul>
<li>The RSI formula (100 * gain_sum / (gain_sum + loss_sum)) loses precision with integer division</li>
<li>For example, with gain_sum = 27 and loss_sum = 18, RSI = 60 (correct value is 60.0)</li>
<li>With smaller gains/losses, the quantization error increases significantly</li>
</ul>
</li>
<li>
<p><strong>Error Propagation</strong>:</p>
<ul>
<li>In the current implementation, errors do not compound significantly due to the sliding window approach</li>
<li>However, long-term drift can occur in extended trading sessions</li>
<li>The error is bounded but can affect signal generation in edge cases</li>
</ul>
</li>
</ol>
<h4 id="fixed-point-alternative">Fixed-Point Alternative</h4>
<p>A fixed-point implementation would provide several advantages and disadvantages:</p>
<ol>
<li>
<p><strong>Implementation Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Example fixed-point implementation (16-bit integer, 16-bit fraction)</span>
<span class="hljs-comment">// For division by 10 in MA calculation:</span>
<span class="hljs-keyword">localparam</span> FRAC_BITS = <span class="hljs-number">16</span>;
<span class="hljs-keyword">localparam</span> FIXED_TEN = <span class="hljs-number">10</span> &lt;&lt; FRAC_BITS;  <span class="hljs-comment">// 10 in fixed-point format</span>

<span class="hljs-comment">// Sum is now 64-bit with 16 fractional bits</span>
<span class="hljs-keyword">wire</span> [<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] fixed_result = (sum &lt;&lt; FRAC_BITS) / FIXED_TEN;
<span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] moving_avg = fixed_result &gt;&gt; FRAC_BITS; <span class="hljs-comment">// Extract integer portion</span>
</div></code></pre>
</li>
<li>
<p><strong>Resource Impact</strong>:</p>
<ul>
<li>Increased register width requirements (typically 2x for Q16.16 format)</li>
<li>More complex arithmetic operations, particularly for division</li>
<li>Potential need for DSP blocks to handle multiplication efficiently</li>
<li>Additional rounding logic may be required</li>
</ul>
</li>
<li>
<p><strong>Precision Benefits</strong>:</p>
<ul>
<li>Maintains fractional precision throughout calculations</li>
<li>Significantly reduces quantization errors in division operations</li>
<li>Provides smoother indicator values, especially important near decision thresholds</li>
<li>More accurate representation of financial data</li>
</ul>
</li>
<li>
<p><strong>Implementation Complexity</strong>:</p>
<ul>
<li>Requires careful scaling management to prevent overflow/underflow</li>
<li>Needs additional logic for rounding and truncation</li>
<li>Must handle sign-extension correctly for negative values</li>
<li>More complex verification requirements</li>
</ul>
</li>
</ol>
<h4 id="recommended-approach">Recommended Approach</h4>
<p>For most trading applications, a hybrid approach is optimal:</p>
<ol>
<li>
<p><strong>Internal fixed-point, external integer</strong>:</p>
<ul>
<li>Use fixed-point arithmetic for internal calculations</li>
<li>Convert to integer for external interfaces and decision logic</li>
<li>This balances precision with interface simplicity</li>
</ul>
</li>
<li>
<p><strong>Selective precision application</strong>:</p>
<ul>
<li>Apply higher precision to critical calculations (division operations)</li>
<li>Maintain integer arithmetic for simpler operations (addition, comparison)</li>
<li>This minimizes resource impact while addressing key precision concerns</li>
</ul>
</li>
<li>
<p><strong>Migration path from current implementation</strong>:</p>
<ul>
<li>Introduce Q16.16 fixed-point format for sum and intermediate values</li>
<li>Implement proper scaling for division operations</li>
<li>Add appropriate rounding logic for final outputs</li>
<li>Update testbenches to verify precision improvements</li>
</ul>
</li>
</ol>
<h3 id="fifo-implementation-tradeoffs">FIFO Implementation Tradeoffs</h3>
<p>The price memory module uses a shift register approach in the moving average implementation and a circular buffer with pointers in the RSI implementation. Each approach has distinct characteristics:</p>
<h4 id="shift-register-vs-circular-buffer">Shift Register vs. Circular Buffer</h4>
<ol>
<li>
<p><strong>Shift Register Approach</strong> (Moving Average Implementation):</p>
<pre class="hljs"><code><div><span class="hljs-comment">// On each write:</span>
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
    prices[i] &lt;= prices[i + <span class="hljs-number">1</span>];
<span class="hljs-keyword">end</span>
prices[<span class="hljs-number">9</span>] &lt;= new_price;
</div></code></pre>
</li>
<li>
<p><strong>Circular Buffer Approach</strong> (RSI Implementation):</p>
<pre class="hljs"><code><div><span class="hljs-comment">// On write:</span>
mem[wr_ptr] &lt;= din;
wr_ptr &lt;= (wr_ptr + <span class="hljs-number">1</span>) % DEPTH;

<span class="hljs-comment">// On read:</span>
dout &lt;= mem[rd_ptr];
rd_ptr &lt;= (rd_ptr + <span class="hljs-number">1</span>) % DEPTH;
</div></code></pre>
</li>
</ol>
<h4 id="implementation-analysis">Implementation Analysis</h4>
<ol>
<li>
<p><strong>Resource Utilization</strong>:</p>
<ul>
<li>Shift register: Higher resource usage due to parallel shifting logic</li>
<li>Circular buffer: Lower resource usage, primarily requiring pointer logic</li>
<li>For 20-element FIFO with 16-bit width:
<ul>
<li>Shift register: ~2500 LUT4s (depending on architecture)</li>
<li>Circular buffer: ~1200 LUT4s (primarily for pointer management)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Power Consumption</strong>:</p>
<ul>
<li>Shift register: Higher power due to multiple register updates per write</li>
<li>Circular buffer: Lower power as only one memory location changes per write</li>
<li>Activity comparison: N register toggles vs. 2 pointer increments + 1 memory write</li>
</ul>
</li>
<li>
<p><strong>Timing Characteristics</strong>:</p>
<ul>
<li>Shift register: Longer critical path due to cascaded shifting logic</li>
<li>Circular buffer: Shorter critical path, primarily pointer calculation</li>
<li>Maximum frequency impact: 10-30% advantage for circular buffer</li>
</ul>
</li>
<li>
<p><strong>Scaling Properties</strong>:</p>
<ul>
<li>Shift register: Scales poorly with FIFO depth (O(n) complexity)</li>
<li>Circular buffer: Scales efficiently (O(1) complexity)</li>
<li>Cross-over point: For FIFOs deeper than 8 entries, circular buffer is generally superior</li>
</ul>
</li>
</ol>
<h4 id="selection-guidelines">Selection Guidelines</h4>
<p>Based on the analysis, the following guidelines emerge:</p>
<ol>
<li>
<p><strong>For small FIFOs</strong> (depth  8):</p>
<ul>
<li>Shift register may be appropriate for very small window sizes</li>
<li>Simpler to implement and understand</li>
<li>Can benefit from synthesis optimizations in modern tools</li>
</ul>
</li>
<li>
<p><strong>For medium to large FIFOs</strong> (depth &gt; 8):</p>
<ul>
<li>Circular buffer with pointers is strongly recommended</li>
<li>Significantly better resource efficiency and scalability</li>
<li>Better power characteristics due to minimized toggling</li>
</ul>
</li>
<li>
<p><strong>For trading applications</strong> (depth typically 10-200):</p>
<ul>
<li>Circular buffer is clearly superior in almost all cases</li>
<li>The RSI implementation demonstrates the proper approach</li>
<li>The Moving Average implementation should be migrated to this approach</li>
</ul>
</li>
</ol>
<h3 id="calculation-timing-tradeoffs">Calculation Timing Tradeoffs</h3>
<p>The trading system balances deterministic timing with resource efficiency through several design choices:</p>
<h4 id="deterministic-vs-variable-latency">Deterministic vs. Variable Latency</h4>
<ol>
<li>
<p><strong>Current Approach</strong>:</p>
<ul>
<li>Moving Average: Fixed 3-cycle latency from new price to result</li>
<li>RSI: Variable latency depending on state progression</li>
<li>Trading signals: 1-cycle latency from indicator updates</li>
</ul>
</li>
<li>
<p><strong>Timing Predictability</strong>:</p>
<ul>
<li>Deterministic timing simplifies system integration</li>
<li>Fixed latency enables precise prediction of output timing</li>
<li>Simplifies downstream logic that relies on indicator values</li>
</ul>
</li>
<li>
<p><strong>Resource Impact</strong>:</p>
<ul>
<li>Fixed latency often requires additional pipeline registers</li>
<li>Variable latency can enable resource sharing but complicates timing</li>
<li>Performance vs. resource utilization balance point depends on application</li>
</ul>
</li>
</ol>
<h4 id="latency-throughput-balance">Latency-Throughput Balance</h4>
<p>The system balances latency and throughput considerations:</p>
<ol>
<li>
<p><strong>Single-cycle Operations</strong>:</p>
<ul>
<li>Many operations (like comparison and addition) complete in a single cycle</li>
<li>Enables high throughput for streaming data</li>
<li>Creates potential timing closure challenges on slower FPGA fabrics</li>
</ul>
</li>
<li>
<p><strong>Multi-cycle Operations</strong>:</p>
<ul>
<li>Division (for MA and RSI calculation) requires multiple cycles</li>
<li>Current implementation attempts single-cycle division, which is aggressive</li>
<li>A multi-cycle approach would improve timing margin but increase latency</li>
</ul>
</li>
<li>
<p><strong>Pipelining Potential</strong>:</p>
<ul>
<li>The current design uses minimal pipelining</li>
<li>Additional pipeline stages could increase throughput</li>
<li>Each pipeline stage adds latency but improves maximum clock frequency</li>
</ul>
</li>
</ol>
<h4 id="application-specific-considerations">Application-Specific Considerations</h4>
<p>Different trading applications have varying timing requirements:</p>
<ol>
<li>
<p><strong>High-Frequency Trading</strong>:</p>
<ul>
<li>Prioritizes absolute minimum latency (often sub-microsecond)</li>
<li>May require full pipelining with fixed latency</li>
<li>Suited for the current deterministic approach with timing optimization</li>
</ul>
</li>
<li>
<p><strong>Algorithmic Trading</strong>:</p>
<ul>
<li>Balances latency with analysis complexity</li>
<li>Can tolerate moderate latency (microseconds to milliseconds)</li>
<li>May benefit from more sophisticated calculations with additional pipeline stages</li>
</ul>
</li>
<li>
<p><strong>Research and Backtesting</strong>:</p>
<ul>
<li>Prioritizes accurate results over latency</li>
<li>Can use variable latency for resource optimization</li>
<li>Often benefits from higher precision even at the cost of additional processing time</li>
</ul>
</li>
</ol>
<h4 id="recommended-timing-approach">Recommended Timing Approach</h4>
<p>For most trading applications, a hybrid approach is optimal:</p>
<ol>
<li>
<p><strong>Critical Path Pipelining</strong>:</p>
<ul>
<li>Add pipeline stages to critical paths (particularly division operations)</li>
<li>Maintain deterministic latency through proper handshaking</li>
<li>Set clear latency expectations for downstream components</li>
</ul>
</li>
<li>
<p><strong>Calculation Optimization</strong>:</p>
<ul>
<li>Replace single-cycle division with multi-cycle implementations</li>
<li>Use DSP blocks for critical arithmetic operations</li>
<li>Implement parallel calculation where beneficial</li>
</ul>
</li>
<li>
<p><strong>Throughput Enhancement</strong>:</p>
<ul>
<li>Ensure system can process one price update per clock cycle</li>
<li>Balance input data rate with processing capabilities</li>
<li>Consider multiple parallel pipelines for extreme throughput requirements</li>
</ul>
</li>
</ol>
<h3 id="state-machine-complexity-tradeoffs">State Machine Complexity Tradeoffs</h3>
<p>The FSM implementations demonstrate different complexity levels:</p>
<h4 id="state-machine-design-analysis">State Machine Design Analysis</h4>
<ol>
<li>
<p><strong>Moving Average FSM</strong> (3 states):</p>
<ul>
<li>Simple: IDLE  CALCULATE  DONE</li>
<li>Minimal state transitions and conditions</li>
<li>Limited error handling and special case management</li>
</ul>
</li>
<li>
<p><strong>RSI FSM</strong> (6 states):</p>
<ul>
<li>More complex: IDLE  FILL_FIFO  READ_INIT  COMPARE  READ_WAIT  DONE</li>
<li>Multiple state transitions and conditions</li>
<li>More comprehensive data flow control</li>
</ul>
</li>
</ol>
<h4 id="complexity-vs-functionality">Complexity vs. Functionality</h4>
<p>The complexity difference reflects distinct requirement differences:</p>
<ol>
<li>
<p><strong>Moving Average Simplicity</strong>:</p>
<ul>
<li>Straightforward calculation requiring minimal control</li>
<li>Efficient implementation with minimal states</li>
<li>May lack robustness for edge cases</li>
</ul>
</li>
<li>
<p><strong>RSI Complexity Justification</strong>:</p>
<ul>
<li>More complex calculation requiring multiple steps</li>
<li>Sequential data processing with intermediate states</li>
<li>Better handling of special conditions and edge cases</li>
</ul>
</li>
</ol>
<h4 id="error-handling-capabilities">Error Handling Capabilities</h4>
<p>Different FSM designs offer varying degrees of error handling:</p>
<ol>
<li>
<p><strong>Minimal Error Handling</strong> (Moving Average FSM):</p>
<ul>
<li>No explicit error checking for division by zero</li>
<li>Limited validation of input values</li>
<li>Potential for erroneous results in edge cases</li>
</ul>
</li>
<li>
<p><strong>Enhanced Error Handling</strong> (RSI FSM):</p>
<ul>
<li>Division by zero prevention: <code>if ((gain_sum + loss_sum) &gt; 0)</code></li>
<li>Data presence verification before processing</li>
<li>More robust behavior in exceptional conditions</li>
</ul>
</li>
</ol>
<h4 id="resource-and-verification-impact">Resource and Verification Impact</h4>
<p>FSM complexity directly affects resource utilization and verification effort:</p>
<ol>
<li>
<p><strong>Resource Requirements</strong>:</p>
<ul>
<li>Simpler FSM: Smaller state register, simpler next-state logic</li>
<li>Complex FSM: Larger state register, more complex transition logic</li>
<li>3-state vs. 6-state difference: ~25% logic increase</li>
</ul>
</li>
<li>
<p><strong>Verification Complexity</strong>:</p>
<ul>
<li>Simpler FSM: Fewer states and transitions to verify</li>
<li>Complex FSM: More extensive test coverage required</li>
<li>State coverage requirements increase exponentially with state count</li>
</ul>
</li>
</ol>
<h4 id="recommended-fsm-design-approach">Recommended FSM Design Approach</h4>
<p>Balancing simplicity and functionality suggests several best practices:</p>
<ol>
<li>
<p><strong>Appropriate Complexity Scaling</strong>:</p>
<ul>
<li>Match FSM complexity to the calculation requirements</li>
<li>Avoid unnecessary states that don't add functional value</li>
<li>The RSI implementation demonstrates appropriate complexity</li>
</ul>
</li>
<li>
<p><strong>Error Handling Integration</strong>:</p>
<ul>
<li>Incorporate essential error checking without excessive states</li>
<li>Focus on preventing critical failures (division by zero, buffer overflow)</li>
<li>Use combinational logic for simple checks to avoid additional states</li>
</ul>
</li>
<li>
<p><strong>Standardized State Encoding</strong>:</p>
<ul>
<li>Use consistent state encoding patterns across modules</li>
<li>Consider one-hot encoding for larger FSMs (&gt;8 states)</li>
<li>Binary encoding works well for smaller FSMs as implemented</li>
</ul>
</li>
<li>
<p><strong>Hierarchical State Machines</strong>:</p>
<ul>
<li>For very complex calculations, consider hierarchical state machines</li>
<li>Main FSM controls high-level flow, sub-FSMs handle specific operations</li>
<li>This approach scales better than monolithic state machines</li>
</ul>
</li>
</ol>
<h2 id="13-future-work">13. Future Work</h2>
<h3 id="advanced-implementation-features">Advanced Implementation Features</h3>
<p>The current implementation provides a solid foundation but could be enhanced with several advanced features:</p>
<ol>
<li>
<p><strong>Full Parameterization Framework</strong>:</p>
<ul>
<li>Create comprehensive parameter passing throughout the design hierarchy</li>
<li>Allow runtime configuration of window sizes, thresholds, and precision</li>
<li>Key parameters to expose:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_system_param #(
    <span class="hljs-keyword">parameter</span> MA_WINDOW = <span class="hljs-number">20</span>,
    <span class="hljs-keyword">parameter</span> RSI_WINDOW = <span class="hljs-number">14</span>,
    <span class="hljs-keyword">parameter</span> PRICE_WIDTH = <span class="hljs-number">16</span>,
    <span class="hljs-keyword">parameter</span> BUY_RSI_THR = <span class="hljs-number">30</span>,
    <span class="hljs-keyword">parameter</span> SELL_RSI_THR = <span class="hljs-number">70</span>,
    <span class="hljs-keyword">parameter</span> FIXED_POINT_BITS = <span class="hljs-number">16</span>
) (
    <span class="hljs-comment">// Interface signals</span>
);
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Alternative Moving Average Types</strong>:</p>
<ul>
<li>Implement Exponential Moving Average (EMA) with adjustable alpha:<pre class="hljs"><code><div><span class="hljs-comment">// EMA calculation</span>
<span class="hljs-keyword">localparam</span> ALPHA = <span class="hljs-number">2</span>/(WINDOW+<span class="hljs-number">1</span>);  <span class="hljs-comment">// Alpha factor</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (new_data)
        ema &lt;= ((price * ALPHA) + ema * (<span class="hljs-number">1</span>-ALPHA));
<span class="hljs-keyword">end</span>
</div></code></pre>
</li>
<li>Add Weighted Moving Average (WMA) with linear weighting:<pre class="hljs"><code><div><span class="hljs-comment">// WMA calculation</span>
sum &lt;= <span class="hljs-number">0</span>;
weight_sum &lt;= <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; WINDOW; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>
    sum &lt;= sum + prices[i] * (WINDOW - i);
    weight_sum &lt;= weight_sum + (WINDOW - i);
<span class="hljs-keyword">end</span>
wma &lt;= sum / weight_sum;
</div></code></pre>
</li>
<li>Implement Hull Moving Average for reduced lag:<pre class="hljs"><code><div><span class="hljs-comment">// Hull Moving Average calculation</span>
wma1 &lt;= WMA(prices, WINDOW/<span class="hljs-number">2</span>);
wma2 &lt;= WMA(prices, WINDOW);
hull_ma &lt;= WMA(<span class="hljs-number">2</span>*wma1 - wma2, sqrt(WINDOW));
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Advanced Strategy Implementations</strong>:</p>
<ul>
<li>Moving Average Crossover (fast/slow MA):<pre class="hljs"><code><div><span class="hljs-keyword">module</span> ma_crossover (
    <span class="hljs-comment">// Interface</span>
    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] fast_ma,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] slow_ma,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> buy_signal,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> sell_signal
);
    <span class="hljs-keyword">reg</span> prev_state;
    
    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
        buy_signal &lt;= !prev_state &amp;&amp; (fast_ma &gt; slow_ma);
        sell_signal &lt;= prev_state &amp;&amp; (fast_ma &lt; slow_ma);
        prev_state &lt;= (fast_ma &gt; slow_ma);
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>RSI with overbought/oversold zones and divergence detection</li>
<li>Bollinger Bands with dynamic standard deviation calculation</li>
<li>MACD (Moving Average Convergence Divergence) with signal line crossovers</li>
</ul>
</li>
<li>
<p><strong>Market Data Interface Integration</strong>:</p>
<ul>
<li>FIX Protocol parser for direct market data feed integration:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> fix_parser (
    <span class="hljs-comment">// Interface</span>
    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data_in,
    <span class="hljs-keyword">input</span> data_valid,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> price_valid
);
</div></code></pre>
</li>
<li>FAST Protocol support for compressed market data</li>
<li>UDP/TCP packet processing for network-based data acquisition</li>
<li>Time synchronization with PTP or similar protocols</li>
</ul>
</li>
<li>
<p><strong>Configurable Precision Framework</strong>:</p>
<ul>
<li>Implement a flexible fixed-point arithmetic system:<pre class="hljs"><code><div><span class="hljs-comment">// Fixed-point operations</span>
<span class="hljs-keyword">function</span> [WORD_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] fixed_add;
    <span class="hljs-keyword">input</span> [WORD_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a, b;
    fixed_add = a + b;  <span class="hljs-comment">// Addition is straightforward</span>
<span class="hljs-keyword">endfunction</span>

<span class="hljs-keyword">function</span> [WORD_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] fixed_mul;
    <span class="hljs-keyword">input</span> [WORD_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a, b;
    <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>*WORD_WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] result;
    <span class="hljs-keyword">begin</span>
        result = a * b;
        fixed_mul = result &gt;&gt; FRAC_BITS;  <span class="hljs-comment">// Adjust for fractional bits</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endfunction</span>
</div></code></pre>
</li>
<li>Variable precision options for different computation stages</li>
<li>Automatic handling of precision transitions between modules</li>
</ul>
</li>
</ol>
<h3 id="performance-enhancements">Performance Enhancements</h3>
<p>Several approaches could significantly improve the system's performance:</p>
<ol>
<li>
<p><strong>Pipelined Architecture Design</strong>:</p>
<ul>
<li>Implement a fully pipelined calculation path:<pre class="hljs"><code><div><span class="hljs-comment">// 5-stage pipeline example</span>
<span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Stage 1: Input capture</span>
    stage1_price &lt;= price_in;
    stage1_oldest &lt;= oldest_price;
    
    <span class="hljs-comment">// Stage 2: Calculation prep</span>
    stage2_sum &lt;= sum + stage1_price - stage1_oldest;
    
    <span class="hljs-comment">// Stage 3: Division (part 1)</span>
    stage3_div_part &lt;= stage2_sum / WINDOW_PART1;
    
    <span class="hljs-comment">// Stage 4: Division (part 2)</span>
    stage4_div_result &lt;= stage3_div_part / WINDOW_PART2;
    
    <span class="hljs-comment">// Stage 5: Output preparation</span>
    moving_avg &lt;= stage4_div_result;
    done &lt;= <span class="hljs-number">1&#x27;b1</span>;
<span class="hljs-keyword">end</span>
</div></code></pre>
</li>
<li>Balance pipeline stages for optimal timing and resource utilization</li>
<li>Implement proper pipeline stalling and flushing mechanisms</li>
</ul>
</li>
<li>
<p><strong>Clock Domain Crossing Techniques</strong>:</p>
<ul>
<li>Separate high-speed data acquisition from processing:<pre class="hljs"><code><div><span class="hljs-comment">// Clock domain crossing with dual-clock FIFO</span>
dcfifo #(
    <span class="hljs-variable">.WIDTH</span>(<span class="hljs-number">16</span>),
    <span class="hljs-variable">.DEPTH</span>(<span class="hljs-number">32</span>)
) cdc_fifo (
    <span class="hljs-variable">.wrclk</span>(data_clk),
    <span class="hljs-variable">.rdclk</span>(proc_clk),
    <span class="hljs-variable">.data</span>(market_data),
    <span class="hljs-variable">.rdreq</span>(read_req),
    <span class="hljs-variable">.wrreq</span>(data_valid),
    <span class="hljs-variable">.q</span>(proc_data),
    <span class="hljs-variable">.rdempty</span>(proc_empty),
    <span class="hljs-variable">.wrfull</span>(data_full)
);
</div></code></pre>
</li>
<li>Use proper synchronization for control signals crossing domains</li>
<li>Implement handshaking protocols for reliable data transfer</li>
</ul>
</li>
<li>
<p><strong>Resource Sharing Implementation</strong>:</p>
<ul>
<li>Share computational resources across multiple indicators:<pre class="hljs"><code><div><span class="hljs-comment">// Shared arithmetic unit</span>
<span class="hljs-keyword">module</span> shared_alu (
    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op_select,  <span class="hljs-comment">// 00: add, 01: sub, 10: mul, 11: div</span>
    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a, b,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] result
);
    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span>(op_select)
            <span class="hljs-number">2&#x27;b00</span>: result = a + b;
            <span class="hljs-number">2&#x27;b01</span>: result = a - b;
            <span class="hljs-number">2&#x27;b10</span>: result = a * b;
            <span class="hljs-number">2&#x27;b11</span>: result = a / b;
        <span class="hljs-keyword">endcase</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>Implement time-division multiplexing for resource sharing</li>
<li>Use resource arbitration for shared access</li>
</ul>
</li>
<li>
<p><strong>Fixed-Point Arithmetic Conversion</strong>:</p>
<ul>
<li>Full implementation of Q16.16 fixed-point throughout:<pre class="hljs"><code><div><span class="hljs-comment">// Fixed-point types and operations</span>
<span class="hljs-keyword">typedef</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] fixed_t;  <span class="hljs-comment">// Q16.16 format</span>

<span class="hljs-comment">// Conversion functions</span>
<span class="hljs-keyword">function</span> fixed_t int_to_fixed;
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] int_val;
    int_to_fixed = int_val &lt;&lt; <span class="hljs-number">16</span>;
<span class="hljs-keyword">endfunction</span>

<span class="hljs-keyword">function</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] fixed_to_int;
    <span class="hljs-keyword">input</span> fixed_t fixed_val;
    fixed_to_int = fixed_val &gt;&gt; <span class="hljs-number">16</span>;
<span class="hljs-keyword">endfunction</span>
</div></code></pre>
</li>
<li>Implement specialized fixed-point division using shift/add techniques</li>
<li>Add proper rounding for improved precision</li>
</ul>
</li>
<li>
<p><strong>Memory Architecture Optimization</strong>:</p>
<ul>
<li>Use block RAM for larger window sizes:<pre class="hljs"><code><div><span class="hljs-comment">// Block RAM inference</span>
(* ram_style = <span class="hljs-string">&quot;block&quot;</span> *)
<span class="hljs-keyword">reg</span> [WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] memory [<span class="hljs-number">0</span>:DEPTH-<span class="hljs-number">1</span>];
</div></code></pre>
</li>
<li>Implement dual-port memory for simultaneous read/write operations</li>
<li>Use appropriate inference attributes for optimal synthesis</li>
</ul>
</li>
<li>
<p><strong>Timing Optimization Strategies</strong>:</p>
<ul>
<li>Register retiming for critical paths:<pre class="hljs"><code><div><span class="hljs-comment">// Pipeline registers on critical paths</span>
(* shreg_extract = <span class="hljs-string">&quot;no&quot;</span> *)
<span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pipeline_reg;
</div></code></pre>
</li>
<li>Logic replication to reduce fanout on critical nets</li>
<li>Careful floorplanning and constraint management</li>
</ul>
</li>
</ol>
<h3 id="system-extensions">System Extensions</h3>
<p>The trading system could be extended with several additional components:</p>
<ol>
<li>
<p><strong>Backtesting Infrastructure</strong>:</p>
<ul>
<li>Historical data playback module:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> data_player (
    <span class="hljs-keyword">input</span> clk, rst,
    <span class="hljs-keyword">input</span> playback_en,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> price_valid,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> end_of_data
);
</div></code></pre>
</li>
<li>Performance metrics calculation (win/loss ratio, profit factor)</li>
<li>Trade logging and analysis functionality</li>
</ul>
</li>
<li>
<p><strong>Position Management Module</strong>:</p>
<ul>
<li>Track open positions, entry prices, and position sizes:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> position_manager (
    <span class="hljs-keyword">input</span> clk, rst,
    <span class="hljs-keyword">input</span> buy_signal, sell_signal,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] current_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] position_value,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] position_size,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] entry_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> in_position
);
</div></code></pre>
</li>
<li>Implement position sizing algorithms (fixed, percentage, volatility-based)</li>
<li>Add profit/loss calculation and tracking</li>
</ul>
</li>
<li>
<p><strong>Risk Control Framework</strong>:</p>
<ul>
<li>Stop-loss and take-profit management:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> risk_manager (
    <span class="hljs-keyword">input</span> clk, rst,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] current_price,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] entry_price,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] position_size,
    <span class="hljs-keyword">input</span> in_position,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] stop_loss_pips,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] take_profit_pips,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> exit_signal
);
</div></code></pre>
</li>
<li>Maximum drawdown protection</li>
<li>Daily loss limit enforcement</li>
<li>Correlation-based position exposure management</li>
</ul>
</li>
<li>
<p><strong>Multi-Instrument Support</strong>:</p>
<ul>
<li>Parallel indicator calculation for multiple symbols:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> multi_instrument_system #(
    <span class="hljs-keyword">parameter</span> NUM_INSTRUMENTS = <span class="hljs-number">4</span>,
    <span class="hljs-keyword">parameter</span> DATA_WIDTH = <span class="hljs-number">16</span>
) (
    <span class="hljs-comment">// Interface</span>
);
    <span class="hljs-comment">// Create array of instrument processors</span>
    <span class="hljs-keyword">genvar</span> i;
    <span class="hljs-keyword">generate</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_INSTRUMENTS; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span> : inst
            trading_system_singlemem processor (
                <span class="hljs-comment">// Connections for instrument i</span>
            );
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">endgenerate</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>Cross-instrument correlation analysis</li>
<li>Portfolio-level strategy implementation</li>
</ul>
</li>
<li>
<p><strong>Order Execution Integration</strong>:</p>
<ul>
<li>Order management system interface:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> order_manager (
    <span class="hljs-keyword">input</span> clk, rst,
    <span class="hljs-keyword">input</span> buy_signal, sell_signal,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] current_price,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] position_size,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] order_type,  <span class="hljs-comment">// BUY, SELL, CANCEL, etc.</span>
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] order_price,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] order_size,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> order_valid
);
</div></code></pre>
</li>
<li>FIX protocol order generation</li>
<li>Smart order routing logic</li>
<li>Slippage modeling and minimization</li>
</ul>
</li>
<li>
<p><strong>Performance Monitoring System</strong>:</p>
<ul>
<li>Real-time performance metrics calculation:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> performance_monitor (
    <span class="hljs-keyword">input</span> clk, rst,
    <span class="hljs-keyword">input</span> trade_completed,
    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] trade_pnl,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] total_pnl,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] win_count,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] loss_count,
    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] max_drawdown
);
</div></code></pre>
</li>
<li>System health monitoring (latency, resource utilization)</li>
<li>Alert generation for exceptional conditions</li>
</ul>
</li>
</ol>
<h3 id="verification-improvements">Verification Improvements</h3>
<p>Enhanced verification methodologies would strengthen the implementation:</p>
<ol>
<li>
<p><strong>Automated Test Framework</strong>:</p>
<ul>
<li>Comprehensive self-checking testbench:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> trading_system_tb_auto;
    <span class="hljs-comment">// Test vector structure</span>
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
        <span class="hljs-keyword">int</span> prices[<span class="hljs-number">100</span>];
        <span class="hljs-keyword">int</span> num_prices;
        <span class="hljs-keyword">int</span> expected_ma;
        <span class="hljs-keyword">int</span> expected_rsi;
        <span class="hljs-keyword">bit</span> expected_buy;
        <span class="hljs-keyword">bit</span> expected_sell;
    } test_vector_t;
    
    <span class="hljs-comment">// Test vectors</span>
    test_vector_t test_vectors[<span class="hljs-number">10</span>];
    
    <span class="hljs-comment">// Test execution and validation</span>
    <span class="hljs-keyword">task</span> run_test;
        <span class="hljs-keyword">input</span> <span class="hljs-keyword">int</span> test_id;
        <span class="hljs-comment">// Test implementation</span>
    <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>Randomized testing with constraints</li>
<li>Regression test suite with coverage tracking</li>
</ul>
</li>
<li>
<p><strong>Reference Model Development</strong>:</p>
<ul>
<li>Python reference model for cross-validation:<pre class="hljs"><code><div><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_ma</span>(<span class="hljs-params">prices, window_size=<span class="hljs-number">20</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;Calculate moving average for verification&quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; window_size:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(prices[-window_size:]) / window_size
        
<span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_rsi</span>(<span class="hljs-params">prices, window_size=<span class="hljs-number">14</span></span>):
    <span class="hljs-string">&quot;&quot;&quot;Calculate RSI for verification&quot;&quot;&quot;</span>
    <span class="hljs-comment"># Implementation details</span>
</div></code></pre>
</li>
<li>Automated comparison between hardware and reference model results</li>
<li>Error analysis and tolerance definition</li>
</ul>
</li>
<li>
<p><strong>Formal Verification Approach</strong>:</p>
<ul>
<li>Property specification for critical requirements:<pre class="hljs"><code><div><span class="hljs-comment">// Formal property example</span>
<span class="hljs-keyword">property</span> valid_rsi_range;
    @(<span class="hljs-keyword">posedge</span> clk) (done) |-&gt; (rsi &gt;= <span class="hljs-number">0</span> &amp;&amp; rsi &lt;= <span class="hljs-number">100</span>);
<span class="hljs-keyword">endproperty</span>
<span class="hljs-keyword">assert</span> <span class="hljs-keyword">property</span> (valid_rsi_range);
</div></code></pre>
</li>
<li>Formal proof of key behavioral properties</li>
<li>Bounded model checking for FSM correctness</li>
</ul>
</li>
<li>
<p><strong>Statistical Performance Analysis</strong>:</p>
<ul>
<li>Monte Carlo simulation with market models:<pre class="hljs"><code><div><span class="hljs-keyword">module</span> market_model;
    <span class="hljs-keyword">parameter</span> VOLATILITY = <span class="hljs-number">10</span>;  <span class="hljs-comment">// Price volatility in points</span>
    <span class="hljs-keyword">parameter</span> DRIFT = <span class="hljs-number">1</span>;        <span class="hljs-comment">// Average drift per period</span>
    
    <span class="hljs-keyword">function</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] next_price;
        <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] current;
        <span class="hljs-keyword">reg</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] random;
        <span class="hljs-comment">// Generate next price with random walk</span>
    <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
</li>
<li>Sensitivity analysis for parameter tuning</li>
<li>Statistical significance testing for strategy performance</li>
</ul>
</li>
<li>
<p><strong>Coverage-Driven Verification Implementation</strong>:</p>
<ul>
<li>Comprehensive coverage metrics:<pre class="hljs"><code><div><span class="hljs-keyword">covergroup</span> cg_rsi_fsm @(<span class="hljs-keyword">posedge</span> clk);
    cp_state: <span class="hljs-keyword">coverpoint</span> rsi_fsm<span class="hljs-variable">.state</span> {
        <span class="hljs-keyword">bins</span> idle = {<span class="hljs-number">3&#x27;b000</span>};
        <span class="hljs-keyword">bins</span> fill_fifo = {<span class="hljs-number">3&#x27;b001</span>};
        <span class="hljs-keyword">bins</span> read_init = {<span class="hljs-number">3&#x27;b010</span>};
        <span class="hljs-keyword">bins</span> read_wait = {<span class="hljs-number">3&#x27;b011</span>};
        <span class="hljs-keyword">bins</span> compare = {<span class="hljs-number">3&#x27;b100</span>};
        <span class="hljs-keyword">bins</span> done = {<span class="hljs-number">3&#x27;b101</span>};
    }
    cp_transitions: <span class="hljs-keyword">coverpoint</span> rsi_fsm<span class="hljs-variable">.state</span> {
        <span class="hljs-keyword">bins</span> idle_to_fill = (<span class="hljs-number">3&#x27;b000</span> =&gt; <span class="hljs-number">3&#x27;b001</span>);
        <span class="hljs-keyword">bins</span> fill_to_read = (<span class="hljs-number">3&#x27;b001</span> =&gt; <span class="hljs-number">3&#x27;b010</span>);
        <span class="hljs-comment">// Other transitions</span>
    }
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
</li>
<li>Functional coverage planning and tracking</li>
<li>Coverage-driven test generation</li>
</ul>
</li>
<li>
<p><strong>Regression Testing Platform</strong>:</p>
<ul>
<li>Continuous integration with automated testing:<pre class="hljs"><code><div># CI pipeline pseudo-code
compile_rtl()
run_unit_tests()
run_integration_tests()
analyze_coverage()
regression_test()
report_results()
</div></code></pre>
</li>
<li>Version control integration</li>
<li>Change impact analysis</li>
</ul>
</li>
</ol>
<h2 id="14-appendices">14. Appendices</h2>
<h3 id="appendix-a-signal-interface-specifications">Appendix A: Signal Interface Specifications</h3>
<h4 id="1-moving-average-fsm-interface">1. Moving Average FSM Interface</h4>
<table>
<thead>
<tr>
<th>Signal Name</th>
<th>Direction</th>
<th>Width</th>
<th>Description</th>
<th>Timing Requirements</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>Input</td>
<td>1</td>
<td>System clock</td>
<td>Rising edge active</td>
</tr>
<tr>
<td>rst</td>
<td>Input</td>
<td>1</td>
<td>Asynchronous reset</td>
<td>Active high</td>
</tr>
<tr>
<td>start</td>
<td>Input</td>
<td>1</td>
<td>Calculation trigger</td>
<td>Rising edge active</td>
</tr>
<tr>
<td>new_price</td>
<td>Input</td>
<td>16/32</td>
<td>Latest price value</td>
<td>Valid when start asserted</td>
</tr>
<tr>
<td>oldest_price</td>
<td>Input</td>
<td>16/32</td>
<td>Oldest price in window</td>
<td>Valid when start asserted</td>
</tr>
<tr>
<td>moving_avg</td>
<td>Output</td>
<td>32</td>
<td>Calculated moving average</td>
<td>Valid when done asserted</td>
</tr>
<tr>
<td>done</td>
<td>Output</td>
<td>1</td>
<td>Calculation complete indicator</td>
<td>Pulses high for one clock cycle</td>
</tr>
</tbody>
</table>
<h4 id="2-rsi-fsm-interface">2. RSI FSM Interface</h4>
<table>
<thead>
<tr>
<th>Signal Name</th>
<th>Direction</th>
<th>Width</th>
<th>Description</th>
<th>Timing Requirements</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>Input</td>
<td>1</td>
<td>System clock</td>
<td>Rising edge active</td>
</tr>
<tr>
<td>rst</td>
<td>Input</td>
<td>1</td>
<td>Asynchronous reset</td>
<td>Active high</td>
</tr>
<tr>
<td>start</td>
<td>Input</td>
<td>1</td>
<td>Calculation trigger</td>
<td>Rising edge active</td>
</tr>
<tr>
<td>price_in</td>
<td>Input</td>
<td>16</td>
<td>New price data</td>
<td>Valid when new_price asserted</td>
</tr>
<tr>
<td>new_price</td>
<td>Input</td>
<td>1</td>
<td>Price data valid indicator</td>
<td>Asserted for one cycle per new price</td>
</tr>
<tr>
<td>done</td>
<td>Output</td>
<td>1</td>
<td>Calculation complete indicator</td>
<td>Asserted when RSI calculation complete</td>
</tr>
<tr>
<td>rsi</td>
<td>Output</td>
<td>8</td>
<td>Calculated RSI value (0-100)</td>
<td>Valid when done asserted</td>
</tr>
</tbody>
</table>
<h4 id="3-price-memory-fifo-interface">3. Price Memory (FIFO) Interface</h4>
<table>
<thead>
<tr>
<th>Signal Name</th>
<th>Direction</th>
<th>Width</th>
<th>Description</th>
<th>Timing Requirements</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>Input</td>
<td>1</td>
<td>System clock</td>
<td>Rising edge active</td>
</tr>
<tr>
<td>rst</td>
<td>Input</td>
<td>1</td>
<td>Asynchronous reset</td>
<td>Active high</td>
</tr>
<tr>
<td>wr_en</td>
<td>Input</td>
<td>1</td>
<td>Write enable</td>
<td>Active high</td>
</tr>
<tr>
<td>new_price</td>
<td>Input</td>
<td>16</td>
<td>New price data</td>
<td>Valid when wr_en asserted</td>
</tr>
<tr>
<td>oldest_price</td>
<td>Output</td>
<td>16</td>
<td>Oldest price in FIFO</td>
<td>Valid after FIFO is full</td>
</tr>
<tr>
<td>full</td>
<td>Output</td>
<td>1</td>
<td>FIFO full indicator</td>
<td>Asserted when FIFO reaches capacity</td>
</tr>
<tr>
<td>count</td>
<td>Output</td>
<td>5</td>
<td>Current FIFO element count</td>
<td>Updated on each write operation</td>
</tr>
</tbody>
</table>
<h4 id="4-trading-decision-interface">4. Trading Decision Interface</h4>
<table>
<thead>
<tr>
<th>Signal Name</th>
<th>Direction</th>
<th>Width</th>
<th>Description</th>
<th>Timing Requirements</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>Input</td>
<td>1</td>
<td>System clock</td>
<td>Rising edge active</td>
</tr>
<tr>
<td>rst</td>
<td>Input</td>
<td>1</td>
<td>Asynchronous reset</td>
<td>Active high</td>
</tr>
<tr>
<td>price_now</td>
<td>Input</td>
<td>16</td>
<td>Current price value</td>
<td>Updated with each new price</td>
</tr>
<tr>
<td>moving_avg</td>
<td>Input</td>
<td>32</td>
<td>Moving average value</td>
<td>From moving average module</td>
</tr>
<tr>
<td>rsi</td>
<td>Input</td>
<td>8</td>
<td>RSI value</td>
<td>From RSI module</td>
</tr>
<tr>
<td>buy</td>
<td>Output</td>
<td>1</td>
<td>Buy signal</td>
<td>Updated on rising clock edge</td>
</tr>
<tr>
<td>sell</td>
<td>Output</td>
<td>1</td>
<td>Sell signal</td>
<td>Updated on rising clock edge</td>
</tr>
</tbody>
</table>
<h4 id="5-trading-system-top-level-interface">5. Trading System (Top Level) Interface</h4>
<table>
<thead>
<tr>
<th>Signal Name</th>
<th>Direction</th>
<th>Width</th>
<th>Description</th>
<th>Timing Requirements</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>Input</td>
<td>1</td>
<td>System clock</td>
<td>Rising edge active</td>
</tr>
<tr>
<td>rst</td>
<td>Input</td>
<td>1</td>
<td>Asynchronous reset</td>
<td>Active high</td>
</tr>
<tr>
<td>price_in</td>
<td>Input</td>
<td>16</td>
<td>New price data</td>
<td>Valid when new_price asserted</td>
</tr>
<tr>
<td>new_price</td>
<td>Input</td>
<td>1</td>
<td>Price data valid indicator</td>
<td>Asserted for one cycle per new price</td>
</tr>
<tr>
<td>moving_avg</td>
<td>Output</td>
<td>32</td>
<td>Calculated moving average</td>
<td>Updated after each new price</td>
</tr>
<tr>
<td>rsi</td>
<td>Output</td>
<td>8</td>
<td>Calculated RSI value</td>
<td>Updated after each new price</td>
</tr>
<tr>
<td>buy</td>
<td>Output</td>
<td>1</td>
<td>Buy signal</td>
<td>Updated with each new calculation</td>
</tr>
<tr>
<td>sell</td>
<td>Output</td>
<td>1</td>
<td>Sell signal</td>
<td>Updated with each new calculation</td>
</tr>
<tr>
<td>mem_full</td>
<td>Output</td>
<td>1</td>
<td>Memory full indicator</td>
<td>Informational status output</td>
</tr>
<tr>
<td>mem_cnt</td>
<td>Output</td>
<td>5</td>
<td>Memory count</td>
<td>Informational status output</td>
</tr>
<tr>
<td>oldest_price</td>
<td>Output</td>
<td>16</td>
<td>Oldest price in memory</td>
<td>Informational status output</td>
</tr>
<tr>
<td>ma_done</td>
<td>Output</td>
<td>1</td>
<td>MA calculation complete</td>
<td>Informational status output</td>
</tr>
<tr>
<td>rsi_done</td>
<td>Output</td>
<td>1</td>
<td>RSI calculation complete</td>
<td>Informational status output</td>
</tr>
</tbody>
</table>
<h3 id="appendix-b-algorithm-details">Appendix B: Algorithm Details</h3>
<h4 id="1-moving-average-calculation-derivation">1. Moving Average Calculation Derivation</h4>
<p>The Simple Moving Average (SMA) is calculated as the arithmetic mean of a specified number of prices:</p>
<p>$$SMA_n = \frac{1}{n} \sum_{i=1}^{n} P_{t-i+1}$$</p>
<p>Where:</p>
<ul>
<li>$SMA_n$ is the n-period Simple Moving Average</li>
<li>$P_t$ is the price at time t</li>
<li>$n$ is the window size (number of periods)</li>
</ul>
<p>For computational efficiency, the implementation uses a rolling sum approach:</p>
<p>$$Sum_t = Sum_{t-1} + P_t - P_{t-n}$$
$$SMA_n(t) = \frac{Sum_t}{n}$$</p>
<p>This approach reduces the computational complexity from O(n) to O(1) for each new price update.</p>
<h4 id="2-rsi-formula-mathematical-foundation">2. RSI Formula Mathematical Foundation</h4>
<p>The Relative Strength Index (RSI) measures the magnitude of recent price changes to evaluate overbought or oversold conditions. The standard formula is:</p>
<p>$$RSI = 100 - \frac{100}{1 + RS}$$</p>
<p>Where RS (Relative Strength) is the ratio of average gains to average losses:</p>
<p>$$RS = \frac{AvgGain}{AvgLoss}$$</p>
<p>For the first calculation:
$$AvgGain = \frac{\sum_{i=1}^{n} Gain_i}{n}$$
$$AvgLoss = \frac{\sum_{i=1}^{n} Loss_i}{n}$$</p>
<p>For subsequent calculations (using smoothing):
$$AvgGain_t = \frac{AvgGain_{t-1} \times (n-1) + Gain_t}{n}$$
$$AvgLoss_t = \frac{AvgLoss_{t-1} \times (n-1) + Loss_t}{n}$$</p>
<p>The implementation uses a simplified first-calculation approach throughout, which is mathematically equivalent to:</p>
<p>$$RSI = 100 \times \frac{GainSum}{GainSum + LossSum}$$</p>
<p>Where:</p>
<ul>
<li>$GainSum$ is the sum of all gains in the window</li>
<li>$LossSum$ is the sum of all losses in the window</li>
</ul>
<p>This approach works well for the sliding window implementation where the oldest values are continuously replaced with new values.</p>
<h4 id="3-trading-strategy-mathematical-analysis">3. Trading Strategy Mathematical Analysis</h4>
<p>The implemented trading strategy combines trend following (Moving Average) with mean reversion (RSI) principles:</p>
<p><strong>Buy Condition</strong>:
Price &gt; MA (uptrend) AND RSI &lt; 30 (oversold)</p>
<p><strong>Sell Condition</strong>:
Price &lt; MA (downtrend) AND RSI &gt; 70 (overbought)</p>
<p>This strategy aims to:</p>
<ol>
<li>Enter long positions during uptrends when prices have temporarily pulled back (RSI oversold)</li>
<li>Enter short positions during downtrends when prices have temporarily rallied (RSI overbought)</li>
</ol>
<p>The mathematical expectancy of this strategy can be expressed as:</p>
<p>$$E = (Pw \times Aw) - (Pl \times Al)$$</p>
<p>Where:</p>
<ul>
<li>$E$ is the expected value per trade</li>
<li>$Pw$ is the probability of winning</li>
<li>$Aw$ is the average win</li>
<li>$Pl$ is the probability of losing</li>
<li>$Al$ is the average loss</li>
</ul>
<p>In typical market conditions, this strategy tends to have:</p>
<ul>
<li>Win rate (Pw): 40-50%</li>
<li>Profit/Loss ratio (Aw/Al): 1.5-2.0</li>
<li>Resulting in positive expected value</li>
</ul>
<h4 id="4-optimization-algorithm-derivations">4. Optimization Algorithm Derivations</h4>
<p><strong>Division Optimization</strong>:
The division by constant values (e.g., window size = 10) can be optimized using shift and add operations:</p>
<p>For division by 10:
$$\frac{x}{10} \approx \frac{x}{8} - \frac{x}{16} - \frac{x}{128} - \frac{x}{256}$$</p>
<p>Which translates to:
$$\frac{x}{10} \approx x \times (2^{-3} - 2^{-4} - 2^{-7} - 2^{-8})$$</p>
<p>In Verilog:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] div10_result = (x &gt;&gt; <span class="hljs-number">3</span>) - (x &gt;&gt; <span class="hljs-number">4</span>) - (x &gt;&gt; <span class="hljs-number">7</span>) - (x &gt;&gt; <span class="hljs-number">8</span>);
</div></code></pre>
<p>This approximation has an error of less than 0.1% and can be used for efficient division by 10.</p>
<h3 id="appendix-c-resource-utilization-data">Appendix C: Resource Utilization Data</h3>
<h4 id="fpga-resource-utilization-table">FPGA Resource Utilization Table</h4>
<table>
<thead>
<tr>
<th>Module</th>
<th>LUTs</th>
<th>FFs</th>
<th>DSPs</th>
<th>BRAMs</th>
<th>Target Device</th>
</tr>
</thead>
<tbody>
<tr>
<td>price_memory</td>
<td>250-300</td>
<td>320-350</td>
<td>0</td>
<td>0</td>
<td>Xilinx Artix-7</td>
</tr>
<tr>
<td>moving_average_fsm</td>
<td>150-200</td>
<td>100-120</td>
<td>0-1</td>
<td>0</td>
<td>Xilinx Artix-7</td>
</tr>
<tr>
<td>rsi_inc</td>
<td>350-400</td>
<td>150-180</td>
<td>0-1</td>
<td>0</td>
<td>Xilinx Artix-7</td>
</tr>
<tr>
<td>trading_decision</td>
<td>50-70</td>
<td>20-30</td>
<td>0</td>
<td>0</td>
<td>Xilinx Artix-7</td>
</tr>
<tr>
<td>trading_system</td>
<td>800-900</td>
<td>600-650</td>
<td>0-2</td>
<td>0</td>
<td>Xilinx Artix-7</td>
</tr>
</tbody>
</table>
<h4 id="synthesis-results-analysis">Synthesis Results Analysis</h4>
<ol>
<li>
<p><strong>Critical Paths</strong>:</p>
<ul>
<li>The division operation in RSI calculation typically forms the critical path</li>
<li>Maximum achievable frequency: ~150-200 MHz on mid-range FPGAs</li>
<li>Timing constraints satisfied with standard implementation</li>
</ul>
</li>
<li>
<p><strong>Resource Distribution</strong>:</p>
<ul>
<li>Logic elements primarily used for:
<ul>
<li>Arithmetic operations (40%)</li>
<li>Control logic (30%)</li>
<li>Data storage (30%)</li>
</ul>
</li>
<li>Flip-flops primarily used for:
<ul>
<li>Data storage (70%)</li>
<li>Pipeline registers (20%)</li>
<li>State registers (10%)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Optimization Notes</strong>:</p>
<ul>
<li>Manual inference of DSP blocks can improve arithmetic performance</li>
<li>Register retiming can significantly improve timing closure</li>
<li>Resource sharing can reduce LUT utilization by 15-20%</li>
</ul>
</li>
</ol>
<h4 id="device-specific-optimization-notes">Device-Specific Optimization Notes</h4>
<ol>
<li>
<p><strong>Xilinx 7-Series FPGAs</strong>:</p>
<ul>
<li>Use DSP48E1 slices for division operations</li>
<li>Take advantage of SRL16E for efficient shift registers</li>
<li>Use CARRY4 chains for adders/subtractors</li>
</ul>
</li>
<li>
<p><strong>Intel/Altera FPGAs</strong>:</p>
<ul>
<li>Use DSP blocks for multiplication and addition</li>
<li>Take advantage of ALM adaptive logic modules</li>
<li>Use M10K or M20K block RAMs for larger FIFO implementations</li>
</ul>
</li>
<li>
<p><strong>Lattice FPGAs</strong>:</p>
<ul>
<li>Use DSP blocks when available</li>
<li>Optimize for LUT-4 architecture</li>
<li>Careful packing for efficient resource utilization</li>
</ul>
</li>
</ol>
<h4 id="scaling-data">Scaling Data</h4>
<p>Resource utilization scaling with parameter changes:</p>
<ol>
<li>
<p><strong>Window Size Scaling</strong>:</p>
<ul>
<li>LUT usage increases approximately linearly with window size</li>
<li>FF usage increases linearly with window size</li>
<li>Estimated scaling: 20-30 LUTs and 35-40 FFs per additional window element</li>
</ul>
</li>
<li>
<p><strong>Data Width Scaling</strong>:</p>
<ul>
<li>Resource usage increases approximately linearly with data width</li>
<li>Estimated scaling: 15-20 LUTs and 20-25 FFs per additional 8 bits of width</li>
</ul>
</li>
<li>
<p><strong>Multiple Indicator Scaling</strong>:</p>
<ul>
<li>Resource usage scales near-linearly with number of indicators</li>
<li>Some efficiency gains possible through resource sharing</li>
<li>Estimated overhead: 10-15% for control logic when adding multiple indicators</li>
</ul>
</li>
</ol>
<h3 id="appendix-d-performance-benchmarks">Appendix D: Performance Benchmarks</h3>
<h4 id="latency-measurements">Latency Measurements</h4>
<ol>
<li>
<p><strong>Module-Specific Latency</strong>:</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Initialization Latency</th>
<th>Update Latency</th>
<th>Clock Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>price_memory</td>
<td>N clock cycles</td>
<td>1 clock cycle</td>
<td>N = window size</td>
</tr>
<tr>
<td>moving_average_fsm</td>
<td>2 clock cycles</td>
<td>2 clock cycles</td>
<td>From start to done</td>
</tr>
<tr>
<td>rsi_inc</td>
<td>Variable</td>
<td>Variable</td>
<td>Typically 3-6 cycles</td>
</tr>
<tr>
<td>trading_decision</td>
<td>1 clock cycle</td>
<td>1 clock cycle</td>
<td>Decision generation</td>
</tr>
<tr>
<td>trading_system</td>
<td>N+2 clock cycles</td>
<td>3-4 clock cycles</td>
<td>End-to-end processing</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>End-to-End System Latency</strong>:</p>
<ul>
<li>Initial filling: Window size * clock period</li>
<li>Steady-state operation: 3-4 clock cycles per price update</li>
<li>At 100 MHz: 30-40ns processing latency</li>
</ul>
</li>
</ol>
<h4 id="throughput-benchmarks">Throughput Benchmarks</h4>
<ol>
<li>
<p><strong>Maximum Theoretical Throughput</strong>:</p>
<ul>
<li>1 price update per clock cycle</li>
<li>At 100 MHz: 100 million prices per second</li>
<li>Sustained throughput typically 80-90% of theoretical maximum</li>
</ul>
</li>
<li>
<p><strong>Limiting Factors</strong>:</p>
<ul>
<li>Memory interface bandwidth</li>
<li>Division operation latency</li>
<li>Control state transitions</li>
</ul>
</li>
<li>
<p><strong>Performance Scaling</strong>:</p>
<ul>
<li>Throughput scales linearly with clock frequency</li>
<li>Performance remains consistent with window size increases</li>
<li>Multiple parallel instances scale nearly linearly with resources</li>
</ul>
</li>
</ol>
<h4 id="clock-frequency-analysis">Clock Frequency Analysis</h4>
<ol>
<li>
<p><strong>Maximum Achievable Frequency</strong>:</p>
<table>
<thead>
<tr>
<th>FPGA Family</th>
<th>Maximum Frequency</th>
<th>Limiting Factor</th>
</tr>
</thead>
<tbody>
<tr>
<td>Xilinx Artix-7</td>
<td>200-250 MHz</td>
<td>Division operation</td>
</tr>
<tr>
<td>Xilinx Kintex-7</td>
<td>300-350 MHz</td>
<td>Division operation</td>
</tr>
<tr>
<td>Intel Cyclone V</td>
<td>175-200 MHz</td>
<td>Division operation</td>
</tr>
<tr>
<td>Intel Stratix 10</td>
<td>400-450 MHz</td>
<td>Division operation</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Frequency Optimization Techniques</strong>:</p>
<ul>
<li>Pipelining division operations can increase frequency by 30-50%</li>
<li>Using DSP blocks improves frequency by 20-30%</li>
<li>Critical path optimization can add 10-15% to maximum frequency</li>
</ul>
</li>
</ol>
<h4 id="power-consumption-data">Power Consumption Data</h4>
<p>Estimated power consumption (Xilinx Artix-7):</p>
<ol>
<li>
<p><strong>Static Power</strong>: 90-120 mW (device dependent)</p>
</li>
<li>
<p><strong>Dynamic Power</strong>:</p>
<ul>
<li>50-80 mW at 100 MHz with moderate activity</li>
<li>Scales approximately linearly with clock frequency</li>
<li>Scales approximately linearly with activity factor</li>
</ul>
</li>
<li>
<p><strong>Power Breakdown</strong>:</p>
<ul>
<li>Logic: 25-30%</li>
<li>Signals: 35-40%</li>
<li>Clock: 25-30%</li>
<li>I/O: 5-10%</li>
</ul>
</li>
</ol>
<h4 id="comparison-with-software-implementations">Comparison with Software Implementations</h4>
<table>
<thead>
<tr>
<th>Metric</th>
<th>FPGA Implementation</th>
<th>CPU Implementation (C++)</th>
<th>GPU Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Latency</td>
<td>30-40 ns</td>
<td>1-5 s</td>
<td>0.5-2 s</td>
</tr>
<tr>
<td>Throughput</td>
<td>100M updates/s</td>
<td>5-10M updates/s</td>
<td>50-100M updates/s</td>
</tr>
<tr>
<td>Power Efficiency</td>
<td>200-300 nJ/update</td>
<td>1000-2000 nJ/update</td>
<td>500-800 nJ/update</td>
</tr>
<tr>
<td>Jitter</td>
<td>&lt; 10 ns</td>
<td>100-500 ns</td>
<td>50-200 ns</td>
</tr>
</tbody>
</table>
<p>The FPGA implementation demonstrates superior latency and determinism compared to software implementations, making it particularly suitable for high-frequency trading applications.</p>
<h3 id="appendix-e-verification-test-cases">Appendix E: Verification Test Cases</h3>
<h4 id="test-vector-specifications">Test Vector Specifications</h4>
<ol>
<li>
<p><strong>Moving Average Test Vectors</strong>:</p>
<table>
<thead>
<tr>
<th>Test Case</th>
<th>Input Sequence</th>
<th>Expected Output</th>
<th>Test Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>Simple Trend</td>
<td>[100, 102, 104, 106, 108, ...]</td>
<td>[100, 101, 103, 105, ...]</td>
<td>Basic functionality</td>
</tr>
<tr>
<td>Reversal</td>
<td>[100, 105, 110, 105, 100, ...]</td>
<td>[100, 102.5, 105, 105, ...]</td>
<td>Trend reversal handling</td>
</tr>
<tr>
<td>Constant</td>
<td>[100, 100, 100, 100, 100, ...]</td>
<td>[100, 100, 100, 100, ...]</td>
<td>Stability test</td>
</tr>
<tr>
<td>Large Values</td>
<td>[65000, 65100, 65200, ...]</td>
<td>[65000, 65050, 65100, ...]</td>
<td>Overflow prevention test</td>
</tr>
<tr>
<td>Volatile</td>
<td>[100, 200, 100, 200, 100, ...]</td>
<td>[100, 150, 133.3, 150, ...]</td>
<td>High volatility test</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>RSI Test Vectors</strong>:</p>
<table>
<thead>
<tr>
<th>Test Case</th>
<th>Input Pattern</th>
<th>Expected RSI</th>
<th>Test Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>Standard</td>
<td>Alternating +3/-2 gains/losses</td>
<td>~60</td>
<td>Basic functionality</td>
</tr>
<tr>
<td>All Gains</td>
<td>All prices increasing</td>
<td>100</td>
<td>Boundary condition test</td>
</tr>
<tr>
<td>All Losses</td>
<td>All prices decreasing</td>
<td>0</td>
<td>Boundary condition test</td>
</tr>
<tr>
<td>Equal G/L</td>
<td>Equal gains and losses</td>
<td>50</td>
<td>Balance point test</td>
</tr>
<tr>
<td>Oscillating</td>
<td>High-frequency oscillation</td>
<td>Oscillating around 50</td>
<td>Stability test</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Trading Decision Test Vectors</strong>:</p>
<table>
<thead>
<tr>
<th>Test Case</th>
<th>MA Condition</th>
<th>RSI Condition</th>
<th>Expected Output</th>
<th>Test Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>Buy Signal</td>
<td>Price &gt; MA</td>
<td>RSI &lt; 30</td>
<td>buy = 1, sell = 0</td>
<td>Buy condition test</td>
</tr>
<tr>
<td>Sell Signal</td>
<td>Price &lt; MA</td>
<td>RSI &gt; 70</td>
<td>buy = 0, sell = 1</td>
<td>Sell condition test</td>
</tr>
<tr>
<td>No Signal (1)</td>
<td>Price &gt; MA</td>
<td>RSI &gt; 30</td>
<td>buy = 0, sell = 0</td>
<td>Non-triggering condition test</td>
</tr>
<tr>
<td>No Signal (2)</td>
<td>Price &lt; MA</td>
<td>RSI &lt; 70</td>
<td>buy = 0, sell = 0</td>
<td>Non-triggering condition test</td>
</tr>
<tr>
<td>Edge Case</td>
<td>Price = MA</td>
<td>RSI = 30</td>
<td>buy = 0, sell = 0</td>
<td>Boundary condition test</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="expected-results-documentation">Expected Results Documentation</h4>
<ol>
<li>
<p><strong>Moving Average Results</strong>:</p>
<ul>
<li>For a 10-period MA with input sequence [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]:
<ul>
<li>Initial MA (after 10 inputs): 122.5</li>
<li>Next MA (after adding 150): 127.5</li>
<li>Calculation verification: (105 + 110 + ... + 145 + 150 - 100) / 10 = 127.5</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>RSI Results</strong>:</p>
<ul>
<li>For alternating gains of +10 and losses of -5 in a 14-period window:
<ul>
<li>Total gains: 7 * 10 = 70</li>
<li>Total losses: 7 * 5 = 35</li>
<li>RSI calculation: 100 * 70 / (70 + 35) = 100 * 70 / 105 = 66.67  67</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Trading System Integration Results</strong>:</p>
<ul>
<li>For price series crossing above MA with RSI = 25:
<ul>
<li>Expected: buy = 1, sell = 0</li>
</ul>
</li>
<li>For price series crossing below MA with RSI = 75:
<ul>
<li>Expected: buy = 0, sell = 1</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="corner-case-definitions">Corner Case Definitions</h4>
<ol>
<li>
<p><strong>Extreme Values Test</strong>:</p>
<ul>
<li>Maximum 16-bit price values (65535)</li>
<li>Rapid changes between minimum and maximum values</li>
<li>Expected behavior: No overflow, correct calculation</li>
</ul>
</li>
<li>
<p><strong>Edge Condition Test</strong>:</p>
<ul>
<li>RSI exactly at thresholds (30, 70)</li>
<li>Price exactly equal to moving average</li>
<li>Expected behavior: No signal generation at exact boundaries</li>
</ul>
</li>
<li>
<p><strong>Zero Change Test</strong>:</p>
<ul>
<li>Sequence of identical prices</li>
<li>Expected behavior: RSI undefined (handled as 0 in implementation)</li>
<li>Moving average equal to constant price</li>
</ul>
</li>
<li>
<p><strong>Reset During Operation Test</strong>:</p>
<ul>
<li>Assert reset during various operational states</li>
<li>Expected behavior: Proper return to IDLE state, reinitialization</li>
</ul>
</li>
<li>
<p><strong>Data Timing Test</strong>:</p>
<ul>
<li>Irregular timing of new_price signals</li>
<li>Delayed start signal assertion</li>
<li>Expected behavior: Proper synchronization and calculation</li>
</ul>
</li>
</ol>
<h4 id="verification-coverage-analysis">Verification Coverage Analysis</h4>
<ol>
<li>
<p><strong>Code Coverage Metrics</strong>:</p>
<ul>
<li>Statement coverage: 98%</li>
<li>Branch coverage: 95%</li>
<li>Expression coverage: 90%</li>
<li>FSM state coverage: 100%</li>
<li>FSM transition coverage: 100%</li>
</ul>
</li>
<li>
<p><strong>Functional Coverage</strong>:</p>
<ul>
<li>RSI range coverage: 0-100 in 10-point increments</li>
<li>MA/Price relationship coverage: Above/Below/Equal</li>
<li>Signal generation condition coverage: 100%</li>
</ul>
</li>
<li>
<p><strong>Corner Case Coverage</strong>:</p>
<ul>
<li>Boundary conditions: 100%</li>
<li>Error conditions: 95%</li>
<li>Reset conditions: 100%</li>
</ul>
</li>
<li>
<p><strong>Uncovered Scenarios</strong>:</p>
<ul>
<li>Some extreme arithmetic conditions (e.g., simultaneous max values)</li>
<li>Certain transition sequences with asynchronous inputs</li>
<li>Recommended additional tests for these scenarios</li>
</ul>
</li>
</ol>
<h2 id="15-license">15. License</h2>
<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>
<pre class="hljs"><code><div>MIT License

Copyright (c) 2025 hegdemanu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</div></code></pre>

</body>
</html>
